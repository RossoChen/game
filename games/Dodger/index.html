<!doctype html>
<html lang="zh-Hant" data-theme="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
  <title>One-Thumb Dodger</title>

  <meta name="theme-color" content="#0b1220" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Dodger" />

  <link rel="manifest" href="/game/manifest.webmanifest">
  <link rel="apple-touch-icon" href="/game/icons/icon-192.png">

  <style>
    :root{
      color-scheme: dark light;
      --homebar-guard: max(env(safe-area-inset-bottom), 34px);
      --homebar-extra: 18px;
      --maxw: 560px;
    }
    html[data-theme="dark"]{
      --bg:#0b1220;
      --panel:rgba(255,255,255,.08);
      --panel2:rgba(255,255,255,.06);
      --border:rgba(255,255,255,.18);
      --border2:rgba(255,255,255,.14);
      --fg:#e7eefc;
      --muted:rgba(231,238,252,.86);
      --board:#0a0f1c;
      --grid:#e7eefc;
      --danger:#ff668a;
      --good:#7cf7b6;
      --accent:#57b8ff;
      --warn:#ffcc66;
      --toast:#ff9ab0;
    }
    html[data-theme="light"]{
      --bg:#f6f7fb;
      --panel:rgba(0,0,0,.06);
      --panel2:rgba(0,0,0,.04);
      --border:rgba(0,0,0,.12);
      --border2:rgba(0,0,0,.10);
      --fg:#0b1220;
      --muted:rgba(11,18,32,.78);
      --board:#ffffff;
      --grid:#0b1220;
      --danger:#d23a5a;
      --good:#1ea972;
      --accent:#1e79c8;
      --warn:#d9822b;
      --toast:#d23a5a;
    }

    html, body{
      margin:0; height:100%;
      overflow:hidden;
      overscroll-behavior:none;
      background:var(--bg);
      color:var(--fg);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", Arial, sans-serif;
      -webkit-user-select:none; user-select:none;
      touch-action:none;
    }
    body{ position:fixed; inset:0; }

    .app{
      height:100svh;
      padding-top: calc(env(safe-area-inset-top) + 14px);
      padding-right: calc(env(safe-area-inset-right) + 12px);
      padding-bottom: calc(var(--homebar-guard) + var(--homebar-extra));
      padding-left: calc(env(safe-area-inset-left) + 12px);
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:center;
    }

    .hud{
      width:min(var(--maxw), 96vw);
      display:flex;
      flex-direction:column;
      gap:10px;
      position:relative;
    }
    .hudTop{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .hudBottom{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
      align-items:center;
    }

    .pill{
      border:1px solid var(--border2);
      background:var(--panel2);
      border-radius:999px;
      padding:12px 14px;
      font-size:14px;
      text-align:center;
      white-space:nowrap;
      backdrop-filter: blur(8px);
    }
    .pill strong{ font-weight:900; }

    .btn{
      border:1px solid var(--border);
      background:var(--panel);
      color:var(--fg);
      border-radius:16px;
      padding:12px 14px;
      font-size:15px;
      font-weight:900;
      cursor:pointer;
      -webkit-tap-highlight-color:transparent;
      white-space:nowrap;
      min-height:48px;
      touch-action:manipulation;
      backdrop-filter: blur(8px);
    }
    .btn:active{ transform:scale(0.985); }

    .toast{
      position:absolute;
      left:50%;
      top:-6px;
      transform:translateX(-50%);
      border:1px solid var(--border2);
      background:var(--panel);
      border-radius:999px;
      padding:8px 10px;
      font-size:13px;
      font-weight:900;
      white-space:nowrap;
      opacity:0;
      pointer-events:none;
      transition: opacity .15s ease;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 24px rgba(0,0,0,.18);
    }
    .toast.show{ opacity:1; }
    .toast b{ color:var(--toast); }

    .stage{
      width:min(var(--maxw), 96vw);
      flex:1;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:14px;
      min-height:0;
    }

    .board{
      width: min(var(--maxw), 96vw, 56svh);
      height:min(var(--maxw), 96vw, 56svh);
      border-radius:18px;
      border:1px solid var(--border2);
      background:var(--board);
      position:relative;
      overflow:hidden;
      pointer-events:none; /* âœ… æ£‹ç›¤ä¸åƒæ§åˆ¶ */
    }
    canvas{ width:100%; height:100%; display:block; }

    .overlay{
      position:absolute; inset:0;
      display:none;
      align-items:center; justify-content:center;
      text-align:center;
      padding:16px;
      background:rgba(0,0,0,.35);
      backdrop-filter:blur(8px);
      pointer-events:none;
    }
    html[data-theme="light"] .overlay{ background:rgba(255,255,255,.55); }
    .overlay.show{ display:flex; }
    .overlay h2{ margin:0 0 8px; font-size:18px; }
    .overlay p{ margin:0; opacity:.88; font-size:13px; line-height:1.5; color:var(--muted); }

    /* âœ… Touchpadï¼šç›¸å°æ§åˆ¶ï¼ˆåƒæ–æ¡¿ï¼‰ */
    .touchpad{
      width:min(var(--maxw), 96vw);
      border-radius:18px;
      border:1px solid var(--border);
      background:var(--panel);
      min-height:84px;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      overflow:hidden;
      touch-action:none;
      backdrop-filter: blur(8px);
      padding-bottom: calc(var(--homebar-guard) + var(--homebar-extra));
    }
    .touchpadHint{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:900;
      font-size:14px;
      opacity:.72;
      pointer-events:none;
    }
    .touchpadBar{
      position:absolute;
      left:14px; right:14px;
      height:8px;
      bottom: calc(14px + var(--homebar-guard));
      border-radius:999px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      pointer-events:none;
    }
    html[data-theme="light"] .touchpadBar{
      background: rgba(0,0,0,.06);
      border: 1px solid rgba(0,0,0,.08);
    }
    .knob{
      position:absolute;
      width:44px; height:44px;
      border-radius:999px;
      border:1px solid var(--border2);
      background: rgba(255,255,255,.10);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:18px;
      font-weight:1000;
      transform: translate(-50%, -50%);
      left:50%; top:50%;
      pointer-events:none;
      opacity:0;
      transition: opacity .12s ease;
    }
    .knob.show{ opacity:1; }

    @media (max-width: 360px){
      .hudBottom{ grid-template-columns: 1fr 1fr; }
      #startBtn, #restartBtn, #backBtn, #themeBtn{ width:100%; }
      .hudTop{ flex-direction:column; align-items:stretch; }
      .toast{ top:-10px; }
      .touchpad{ min-height:92px; }
    }

    @media (max-height: 720px){
      .pill{ padding:10px 12px; }
      .btn{ padding:11px 12px; min-height:46px; }
      .board{
        width: min(var(--maxw), 96vw, 52svh);
        height:min(var(--maxw), 96vw, 52svh);
      }
      .stage{ gap:12px; }
      .touchpad{ min-height:76px; }
    }
  </style>
</head>

<body>
  <div class="app">
    <div class="hud">
      <div class="toast" id="toast"></div>

      <div class="hudTop">
        <button class="btn" id="backBtn">â† Back</button>
        <button class="btn" id="themeBtn">ä¸»é¡Œï¼šæ·±è‰²</button>
        <div class="pill">ç‹€æ…‹ï¼š<strong id="status">ç„¡</strong></div>
      </div>

      <div class="hudBottom">
        <div class="pill">æ™‚é–“ï¼š<strong id="time">0.0</strong>s</div>
        <div class="pill">æœ€ä½³ï¼š<strong id="best">0.0</strong>s</div>
        <div style="display:flex; gap:10px; justify-content:flex-end;">
          <button class="btn" id="startBtn" style="flex:1;">é–‹å§‹</button>
          <button class="btn" id="restartBtn" style="flex:1;">é‡ä¾†</button>
        </div>
      </div>
    </div>

    <div class="stage">
      <div class="boardWrap" style="position:relative;">
        <div class="board">
          <canvas id="cv"></canvas>
        </div>
        <div class="overlay show" id="overlay">
          <div>
            <h2 id="ovTitle">æº–å‚™</h2>
            <p id="ovText">åœ¨ä¸‹æ–¹è§¸æ§æ¿å·¦å³æ‹–æ›³ç§»å‹•</p>
          </div>
        </div>
      </div>

      <div class="touchpad" id="pad">
        <div class="touchpadHint" id="padHint">åœ¨é€™è£¡å·¦å³æ‹–æ›³æ§åˆ¶ï¼ˆç›¸å°æ–æ¡¿ï¼‰</div>
        <div class="touchpadBar"></div>
        <div class="knob" id="knob">â†”</div>
      </div>
    </div>
  </div>

<script>
(() => {
  document.addEventListener("touchmove", (e) => e.preventDefault(), { passive:false });

  // ====== èª¿é›£åº¦æ”¹é€™å€ ======
  const WORLD_W = 1000;
  const WORLD_H = 1000;

  const PLAYER_Y = 900;
  const PLAYER_SPEED = 1000;  // è§’è‰²æœ€å¤§å·¦å³é€Ÿåº¦ï¼ˆè¶Šå¤§è¶Šéˆæ•ï¼‰

  const BULLET_BASE_SPD = 520;
  const BULLET_SPD_GROW = 18;
  const BULLET_BASE_RATE = 1.10;
  const BULLET_RATE_GROW = 0.040;
  const BULLET_MAX = 120;

  const HIT_GRACE_MS = 280;

  const ITEM_BASE_RATE = 0.22;
  const ITEM_RATE_GROW = 0.006;
  const ITEM_MAX = 3;
  const ITEM_FALL_SPD = 420;

  const SLOW_T = 6.0;
  const SHRINK_T = 7.0;
  const MAGNET_T = 7.5;

  const MAGNET_RADIUS = 150;
  const MAGNET_PULL = 1400;

  // âœ… Touchpad åƒæ•¸ï¼ˆç›¸å°æ–æ¡¿æ‰‹æ„Ÿï¼‰
  const PAD_DEADZONE_PX = 10;      // å°æŠ–å‹•å¿½ç•¥
  const PAD_FULLSCALE_PX = 999;    // æ‹–åˆ°é€™è·é›¢ = 100% é€Ÿåº¦
  const PAD_AXIS_SMOOTH = 0.99;    // 0~1ï¼Œè¶Šå¤§è¶Šã€Œè·Ÿæ‰‹ã€ï¼Œè¶Šå°è¶Šã€Œæ»‘ã€

  const BEST_KEY = "dodger_best_v4_relative_pad";
  const THEME_KEY = "dodger_theme_v1";

  // ====== DOM ======
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");

  const elTime = document.getElementById("time");
  const elBest = document.getElementById("best");
  const elStatus = document.getElementById("status");

  const startBtn = document.getElementById("startBtn");
  const restartBtn = document.getElementById("restartBtn");
  const backBtn = document.getElementById("backBtn");
  const themeBtn = document.getElementById("themeBtn");

  const overlay = document.getElementById("overlay");
  const ovTitle = document.getElementById("ovTitle");
  const ovText  = document.getElementById("ovText");

  const pad = document.getElementById("pad");
  const padHint = document.getElementById("padHint");
  const knob = document.getElementById("knob");

  const toast = document.getElementById("toast");
  let toastTimer = 0;
  function showToast(html, ms=900){
    toast.innerHTML = html;
    toast.classList.add("show");
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => toast.classList.remove("show"), ms);
  }

  // Theme
  function systemTheme(){
    return window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches ? "light" : "dark";
  }
  function applyTheme(mode){
    const final = (mode === "system") ? systemTheme() : mode;
    document.documentElement.dataset.theme = final;
    const meta = document.querySelector('meta[name="theme-color"]');
    if(meta) meta.setAttribute("content", final === "light" ? "#f6f7fb" : "#0b1220");
    themeBtn.textContent = `ä¸»é¡Œï¼š${final === "light" ? "æ·ºè‰²" : "æ·±è‰²"}`;
  }
  function getThemeMode(){ return localStorage.getItem(THEME_KEY) || "system"; }
  function setThemeMode(mode){ localStorage.setItem(THEME_KEY, mode); applyTheme(mode); }
  applyTheme(getThemeMode());
  if(window.matchMedia){
    window.matchMedia("(prefers-color-scheme: light)").addEventListener?.("change", () => {
      if(getThemeMode() === "system") applyTheme("system");
    });
  }
  themeBtn.addEventListener("click", () => {
    const cur = document.documentElement.dataset.theme;
    setThemeMode(cur === "light" ? "dark" : "light");
  });

  // Back
  backBtn.addEventListener("click", () => {
    const hub = "/game/";
    try{
      if(document.referrer && document.referrer.includes("/game/")) history.back();
      else location.href = hub;
    }catch(_){
      location.href = hub;
    }
  });

  // Best
  let best = Number(localStorage.getItem(BEST_KEY) || 0) || 0;
  elBest.textContent = best.toFixed(1);

  // Canvas
  let dpr=1, sizeCss=1;
  function resizeCanvas(){
    const rect = cv.parentElement.getBoundingClientRect();
    sizeCss = Math.max(1, Math.floor(Math.min(rect.width, rect.height)));
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    cv.width = Math.floor(sizeCss * dpr);
    cv.height = Math.floor(sizeCss * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", () => {
    resizeCanvas();
    if(initialized) draw();
  });

  // State
  let initialized=false, running=false, gameOver=false;

  let tSurvive=0;
  let lastT=0;

  let player = { x: WORLD_W/2, y: PLAYER_Y, r: 26 };
  let bullets = [];
  let items = [];

  // âœ… Touchpad axisï¼ˆç›¸å°æ§åˆ¶ï¼‰
  let padActive=false;
  let padDownX=0;
  let padAxisTarget=0;  // ç›®æ¨™ axis
  let padAxis=0;        // å¹³æ»‘å¾Œ axisï¼ˆå¯¦éš›ç”¨ï¼‰
  let padMoved=false;

  // hold/shield
  let hold=false;
  let hitFreezeUntil=0;

  // effects
  let shield=0;
  let slowT=0;
  let shrinkT=0;
  let magnetT=0;

  const ITEM_TYPES = ["SHIELD","SLOW","CLEAR","MAGNET","SHRINK"];

  function cssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function rand(a,b){ return a + Math.random()*(b-a); }

  function setOverlay(show, title, text){
    if(show){
      ovTitle.textContent = title;
      ovText.textContent = text;
      overlay.classList.add("show");
    }else overlay.classList.remove("show");
  }

  function statusLabel(){
    const p=[];
    if(shield>0) p.push(`è­·ç›¾(${shield})`);
    if(slowT>0) p.push(`æ¸›é€Ÿ(${slowT.toFixed(1)})`);
    if(shrinkT>0) p.push(`ç¸®å°(${shrinkT.toFixed(1)})`);
    if(magnetT>0) p.push(`å¸é™„(${magnetT.toFixed(1)})`);
    if(hold) p.push(`ç­‰å¾…ç§»å‹•`);
    return p.length ? p.join(" / ") : "ç„¡";
  }

  function syncUI(){
    elTime.textContent = tSurvive.toFixed(1);
    elBest.textContent = best.toFixed(1);
    elStatus.textContent = statusLabel();
    startBtn.textContent = running ? "æš«åœ" : "é–‹å§‹";
  }

  function resetGame(){
    tSurvive=0;
    lastT=0;

    player.x = WORLD_W/2;
    player.r = 26;

    bullets = [];
    items = [];

    padActive=false;
    padDownX=0;
    padAxisTarget=0;
    padAxis=0;
    padMoved=false;

    hold=false;
    hitFreezeUntil=0;

    shield=0;
    slowT=0;
    shrinkT=0;
    magnetT=0;

    running=false;
    gameOver=false;

    knob.classList.remove("show");
    padHint.style.opacity = "0.72";

    syncUI();
    draw();
    setOverlay(true, "æº–å‚™", "åœ¨ä¸‹æ–¹è§¸æ§æ¿å·¦å³æ‹–æ›³ç§»å‹•");
  }

  function ensureInit(){
    if(initialized) return;
    resizeCanvas();
    resetGame();
    initialized=true;
  }

  function setRunning(v){
    if(gameOver && v) return;
    if(hold && v) return;
    running=v;
    syncUI();
    if(running){
      setOverlay(false);
      requestAnimationFrame(loop);
    }else{
      setOverlay(true, "æš«åœä¸­", "æŒ‰ã€Œé–‹å§‹ã€ç¹¼çºŒ");
    }
  }

  // Spawn
  function bulletRate(){ return BULLET_BASE_RATE + BULLET_RATE_GROW * tSurvive; }
  function bulletSpeed(){
    const base = BULLET_BASE_SPD + BULLET_SPD_GROW * tSurvive;
    return base * ((slowT>0) ? 0.55 : 1.0);
  }
  function itemRate(){ return ITEM_BASE_RATE + ITEM_RATE_GROW * tSurvive; }

  function spawnBullet(){
    if(bullets.length >= BULLET_MAX) return;
    const r = rand(10, 18);
    bullets.push({
      x: rand(r, WORLD_W-r),
      y: -r-10,
      r,
      vy: bulletSpeed() * rand(0.86, 1.18)
    });
  }

  function spawnItem(){
    if(items.length >= ITEM_MAX) return;
    const type = ITEM_TYPES[Math.floor(Math.random()*ITEM_TYPES.length)];
    const r = 18;
    items.push({
      x: rand(r, WORLD_W-r),
      y: -r-10,
      r,
      vy: ITEM_FALL_SPD * rand(0.92, 1.14),
      type,
      spin: rand(0, Math.PI*2)
    });
  }

  function applyItem(type){
    if(type==="SHIELD"){
      shield += 1;
      showToast(`å–å¾— <b>è­·ç›¾</b>ï¼ˆ+1ï¼‰`);
      return;
    }
    if(type==="SLOW"){
      slowT = Math.max(slowT, SLOW_T);
      showToast(`å–å¾— <b>æ¸›é€Ÿ</b>ï¼ˆ${SLOW_T}sï¼‰`);
      return;
    }
    if(type==="CLEAR"){
      bullets = [];
      showToast(`å•Ÿå‹• <b>æ¸…å ´</b>`);
      return;
    }
    if(type==="MAGNET"){
      magnetT = Math.max(magnetT, MAGNET_T);
      showToast(`å–å¾— <b>å¸é™„</b>ï¼ˆ${MAGNET_T}sï¼‰`);
      return;
    }
    if(type==="SHRINK"){
      shrinkT = Math.max(shrinkT, SHRINK_T);
      showToast(`å–å¾— <b>ç¸®å°</b>ï¼ˆ${SHRINK_T}sï¼‰`);
      return;
    }
  }

  function consumeShieldHold(){
    if(shield>0){
      shield -= 1;
      hold = true;
      running = true;
      hitFreezeUntil = performance.now() + HIT_GRACE_MS;
      showToast(`<b>è­·ç›¾æ“‹ä¸‹ï¼</b> è§¸æ§æ¿æ‹–ä¸€ä¸‹ç¹¼çºŒ`, 1100);
      syncUI();
      setOverlay(false);
      lastT = 0;
      requestAnimationFrame(loop);
      return true;
    }
    return false;
  }

  function dist2(ax,ay,bx,by){
    const dx=ax-bx, dy=ay-by;
    return dx*dx + dy*dy;
  }

  function update(dt){
    // effects
    if(slowT>0) slowT = Math.max(0, slowT - dt);
    if(shrinkT>0) shrinkT = Math.max(0, shrinkT - dt);
    if(magnetT>0) magnetT = Math.max(0, magnetT - dt);

    // player radius smoothing
    const targetR = (shrinkT>0) ? 18 : 26;
    player.r += (targetR - player.r) * 0.22;

    // axis smoothing
    padAxis += (padAxisTarget - padAxis) * PAD_AXIS_SMOOTH;

    // hold: å¿…é ˆã€ŒçœŸçš„æ‹–æ›³ã€æ‰è§£é™¤
    if(hold){
      if(padActive && padMoved){
        hold = false;
        showToast(`ç¹¼çºŒï¼`, 450);
        lastT = 0;
      }else{
        return;
      }
    }

    // âœ… ç›¸å°æ§åˆ¶ï¼šåªé  axis å·¦å³ç§»å‹•ï¼ˆå®Œå…¨ä¸æœƒç¬ç§»åˆ°è½é»ï¼‰
    player.x += padAxis * PLAYER_SPEED * dt;
    player.x = clamp(player.x, player.r, WORLD_W - player.r);

    // spawn bullets
    let spawnCount = bulletRate() * dt;
    while(spawnCount > 0){
      if(Math.random() < spawnCount) spawnBullet();
      spawnCount -= 1;
    }

    // spawn items
    const ir = itemRate() * dt;
    if(items.length < ITEM_MAX && Math.random() < ir){
      spawnItem();
    }

    // update bullets
    const spdBase = bulletSpeed();
    for(const b of bullets){
      b.y += (b.vy / (BULLET_BASE_SPD || 1)) * spdBase * dt;
    }
    bullets = bullets.filter(b => b.y < WORLD_H + b.r + 30);

    // update items
    for(const it of items){
      it.y += it.vy * dt;
      it.spin += dt * 2.2;
    }
    items = items.filter(it => it.y < WORLD_H + it.r + 40);

    // magnet: pull items
    if(magnetT>0){
      for(const it of items){
        const dx = player.x - it.x;
        const dy = player.y - it.y;
        const d = Math.sqrt(dx*dx + dy*dy);
        if(d > 1 && d < MAGNET_RADIUS){
          const pull = MAGNET_PULL * dt * (1 - d / MAGNET_RADIUS);
          it.x += (dx / d) * pull;
          it.y += (dy / d) * pull;
        }
      }
    }

    // item collision
    for(let i=items.length-1;i>=0;i--){
      const it = items[i];
      const rr = (player.r + it.r);
      if(dist2(player.x, player.y, it.x, it.y) <= rr*rr){
        items.splice(i,1);
        applyItem(it.type);
      }
    }

    // grace after shield
    const now = performance.now();
    if(now < hitFreezeUntil) return;

    // bullet collision
    for(const b of bullets){
      const rr = (player.r + b.r);
      if(dist2(player.x, player.y, b.x, b.y) <= rr*rr){
        if(consumeShieldHold()) return;

        running=false;
        gameOver=true;

        if(tSurvive > best){
          best = tSurvive;
          localStorage.setItem(BEST_KEY, String(best));
        }
        syncUI();
        draw(true);
        setOverlay(true, "çµæŸ", "æŒ‰ã€Œé‡ä¾†ã€å†æŒ‘æˆ°");
        return;
      }
    }
  }

  function draw(isOver=false){
    const w = sizeCss || 1;
    const h = sizeCss || 1;

    ctx.clearRect(0,0,w,h);

    const sx = w / WORLD_W;
    const sy = h / WORLD_H;

    // grid
    ctx.globalAlpha = 0.08;
    ctx.beginPath();
    const step = 100;
    for(let i=1;i<WORLD_W/step;i++){
      const x = i*step*sx;
      ctx.moveTo(x,0); ctx.lineTo(x,h);
    }
    for(let j=1;j<WORLD_H/step;j++){
      const y = j*step*sy;
      ctx.moveTo(0,y); ctx.lineTo(w,y);
    }
    ctx.strokeStyle = cssVar("--grid");
    ctx.stroke();
    ctx.globalAlpha = 1;

    // bullets
    ctx.fillStyle = cssVar("--danger");
    for(const b of bullets){
      const x=b.x*sx, y=b.y*sy;
      ctx.beginPath();
      ctx.arc(x,y, b.r*sx, 0, Math.PI*2);
      ctx.fill();
    }

    // items
    for(const it of items){
      const x=it.x*sx, y=it.y*sy;
      let ring = cssVar("--warn");
      let icon = "?";
      if(it.type==="SHIELD"){ ring = cssVar("--toast"); icon = "ğŸ›¡"; }
      if(it.type==="SLOW"){ ring = cssVar("--accent"); icon = "ğŸ§Š"; }
      if(it.type==="CLEAR"){ ring = cssVar("--warn"); icon = "ğŸ§¹"; }
      if(it.type==="MAGNET"){ ring = cssVar("--accent"); icon = "ğŸ§²"; }
      if(it.type==="SHRINK"){ ring = cssVar("--good"); icon = "âœ¨"; }

      ctx.save();
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = ring;
      ctx.beginPath();
      ctx.arc(x,y, it.r*sx, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = cssVar("--bg");
      ctx.font = `${Math.max(12, it.r*sx*1.05)}px system-ui`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.translate(x,y);
      ctx.rotate(Math.sin(it.spin)*0.08);
      ctx.fillText(icon, 0, 1);
      ctx.restore();
    }

    // player
    const px=player.x*sx, py=player.y*sy;
    ctx.save();
    if(shield>0){
      ctx.globalAlpha = 0.9;
      ctx.strokeStyle = cssVar("--toast");
      ctx.lineWidth = Math.max(2, player.r*sx*0.22);
      ctx.beginPath();
      ctx.arc(px,py, player.r*sx*1.35, 0, Math.PI*2);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
    ctx.fillStyle = cssVar("--good");
    ctx.beginPath();
    ctx.arc(px,py, player.r*sx, 0, Math.PI*2);
    ctx.fill();

    // eyes
    ctx.fillStyle = cssVar("--bg");
    ctx.beginPath();
    ctx.arc(px - player.r*sx*0.28, py - player.r*sx*0.12, Math.max(2, player.r*sx*0.12), 0, Math.PI*2);
    ctx.arc(px + player.r*sx*0.18, py - player.r*sx*0.12, Math.max(2, player.r*sx*0.10), 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    if(isOver){
      ctx.globalAlpha = 0.10;
      ctx.fillStyle = cssVar("--danger");
      ctx.fillRect(0,0,w,h);
      ctx.globalAlpha = 1;
    }

    elStatus.textContent = statusLabel();
  }

  function loop(ts){
    if(!running) return;

    if(!lastT) lastT = ts;
    const dt = Math.min(0.033, (ts - lastT) / 1000);
    lastT = ts;

    update(dt);

    if(!hold && !gameOver){
      tSurvive += dt;
    }

    syncUI();
    draw();

    requestAnimationFrame(loop);
  }

  // ====== Relative Touchpad Input ======
  function ensureLoopRunning(){
    ensureInit();
    if(gameOver) return;
    if(!running){
      running = true;
      syncUI();
      lastT = 0;
      requestAnimationFrame(loop);
    }
  }

  function axisFromDeltaPx(dx){
    const adx = Math.abs(dx);
    if(adx <= PAD_DEADZONE_PX) return 0;
    const sign = Math.sign(dx);
    const scaled = clamp((adx - PAD_DEADZONE_PX) / PAD_FULLSCALE_PX, 0, 1);
    return sign * scaled;
  }

  pad.addEventListener("pointerdown", (e) => {
    ensureInit();
    if(gameOver) return;
    e.preventDefault();

    pad.setPointerCapture?.(e.pointerId);
    padActive = true;
    padMoved = false;
    padDownX = e.clientX;

    padAxisTarget = 0; // âœ… down ä¸å‹•
    knob.classList.add("show");
    padHint.style.opacity = "0.40";

    // knob å…ˆæ”¾åœ¨æŒ‰ä¸‹é»
    const rect = pad.getBoundingClientRect();
    const x = clamp((e.clientX - rect.left), 16, rect.width - 16);
    knob.style.left = `${x}px`;
    knob.style.top  = `${rect.height * 0.42}px`;

    ensureLoopRunning();
  }, {passive:false});

  pad.addEventListener("pointermove", (e) => {
    if(!padActive || gameOver) return;

    const dx = e.clientX - padDownX;
    if(Math.abs(dx) > PAD_DEADZONE_PX) padMoved = true;

    padAxisTarget = axisFromDeltaPx(dx);

    // knob è·Ÿè‘—æ‰‹æŒ‡ï¼ˆè¦–è¦ºç”¨ï¼‰
    const rect = pad.getBoundingClientRect();
    const x = clamp((e.clientX - rect.left), 16, rect.width - 16);
    knob.style.left = `${x}px`;
    knob.style.top  = `${rect.height * 0.42}px`;
  }, {passive:true});

  function padUp(){
    padActive = false;
    padMoved = false;
    padAxisTarget = 0;   // âœ… æ”¾é–‹å°±åœ
    knob.classList.remove("show");
    padHint.style.opacity = "0.72";
  }
  pad.addEventListener("pointerup", padUp, {passive:true});
  pad.addEventListener("pointercancel", padUp, {passive:true});
  pad.addEventListener("pointerleave", padUp, {passive:true});

  // Buttons
  startBtn.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    ensureInit();
    if(gameOver) return;
    if(hold) return;
    setRunning(!running);
  }, {passive:false});

  restartBtn.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    ensureInit();
    resetGame();
    running = true;
    syncUI();
    lastT = 0;
    setOverlay(false);
    requestAnimationFrame(loop);
  }, {passive:false});

  // Keyboard (desktop)
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if(k === " "){
      ensureInit();
      if(gameOver) return;
      if(hold) return;
      setRunning(!running);
    }
  }, {passive:false});

  // init
  requestAnimationFrame(() => ensureInit());
})();
</script>
</body>
</html>