<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover"/>
<title>Blaster</title>
<meta name="theme-color" content="#0b1220"/>
<link rel="manifest" href="/games/manifest.webmanifest">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<style>
:root{
  color-scheme:dark;

  --appSafeTop:24px; --appSafeR:0px; --appSafeB:0px; --appSafeL:0px;
  --appExtraTop:10px; --appExtraBottom:10px;

  --gap:8px;

  --ui-fg:#e7eefc;
  --glass-bd: rgba(255,255,255,.14);
  --glass-bd2: rgba(255,255,255,.12);
  --glass-bg: rgba(255,255,255,.06);
  --glass-bg2: rgba(255,255,255,.05);
  --glass-shadow: 0 18px 70px rgba(0,0,0,.55);

  --tap: transparent;
}

html,body{
  height:100%;margin:0;background:#0b1220;color:var(--ui-fg);
  font-family:system-ui,"Noto Sans TC",sans-serif;
  -webkit-user-select:none;user-select:none;
  touch-action:manipulation;overflow:hidden
}
body{position:fixed;inset:0}

.app{
  height:100svh;
  padding:
    calc(var(--appSafeTop) + var(--appExtraTop))
    calc(var(--appSafeR) + 10px)
    calc(var(--appSafeB) + var(--appExtraBottom))
    calc(var(--appSafeL) + 10px);
  display:flex;flex-direction:column;gap:var(--gap);box-sizing:border-box;
}

.pill, button.pill, .sbtn, .opt{
  color:var(--ui-fg);
  border:1px solid var(--glass-bd);
  background:var(--glass-bg);
  -webkit-tap-highlight-color:var(--tap);
  white-space:nowrap;
}
.pill:active, button.pill:active, .sbtn:active, .opt:active{ transform:scale(.99); }
button.pill:disabled, .sbtn[disabled]{ opacity:.45; cursor:default; }

.lvx, .hpbar, .boardWrap, .touchpad{
  border:1px solid var(--glass-bd2);
  background:var(--glass-bg2);
}

.hud{display:flex;flex-direction:column;gap:var(--gap);min-height:0}
.hudRow{
  display:flex;align-items:center;gap:var(--gap);
  overflow-x:auto;-webkit-overflow-scrolling:touch;scrollbar-width:none;
}
.hudRow::-webkit-scrollbar{display:none}
.hudRow2{justify-content:space-between}

.pill,button.pill{border-radius:999px;padding:8px 10px;font-size:13px;line-height:1}
button.pill{cursor:pointer}
#hudStage{min-width:56px;padding:8px 8px;text-align:center}

.lvxTop{flex:1 1 auto;min-width:0;max-width:none;}
.lvx{
  flex:1 1 auto; min-width:0;
  display:flex;align-items:center;gap:10px;
  padding:8px 10px;border-radius:16px;
  flex-wrap:nowrap;overflow:hidden;
}
.lvx .label{opacity:.85;font-weight:900;letter-spacing:.2px;min-width:0;white-space:nowrap;}
.lvx .num{opacity:.85;font-variant-numeric:tabular-nums;min-width:0;text-align:right;white-space:nowrap;}
#btnStats{cursor:pointer}
#btnStats:active{transform:scale(.995)}

.hpRowRight{display:flex;align-items:center;gap:var(--gap);flex:0 0 auto}
.hpbar{
  flex:1 1 auto; min-width:0;
  display:flex;align-items:center;gap:8px;
  padding:8px 10px;border-radius:16px;
}
.hpbar .label{opacity:.85;font-weight:800;letter-spacing:.2px}
.hpbar .track{
  flex:1 1 auto; min-width:90px; max-width:240px;
  height:12px;border-radius:999px;
  background:rgba(255,255,255,.10);
  overflow:hidden;border:1px solid rgba(255,255,255,.10)
}
.hpbar .fill{height:100%;width:50%;background:rgba(120,255,200,.95)}
.hpbar .num{opacity:.85;font-variant-numeric:tabular-nums;min-width:86px;text-align:right}

.main{flex:1;min-height:0;display:flex;flex-direction:column;gap:var(--gap)}
.boardWrap{
  flex:1;min-height:0;border-radius:18px;
  background:
    radial-gradient(1200px 800px at 50% 0%, rgba(90,120,255,.10), transparent 60%),
    rgba(255,255,255,.03);
  overflow:hidden;position:relative
}
canvas{width:100%;height:100%;display:block}

.touchpad{
  flex:0 0 auto;height:max(42px,5.5svh);
  border-radius:16px;background:rgba(255,255,255,.04);
  position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent
}
.touchpad .hint{position:absolute;inset:auto 0 10px 0;text-align:center;font-size:14px;opacity:.75;pointer-events:none}
.touchpad .bar{position:absolute;left:10px;right:10px;top:16px;bottom:16px;border-radius:14px;border:1px dashed rgba(255,255,255,.18);opacity:.7}
.touchpad .thumb{position:absolute;top:50%;width:46px;height:46px;transform:translate(-50%,-50%);border-radius:999px;border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.08);box-shadow:0 8px 30px rgba(0,0,0,.35);pointer-events:none}

.skills{
  flex:0 0 auto;
  display:flex;gap:8px;align-items:center;
  overflow-x:auto;-webkit-overflow-scrolling:touch;scrollbar-width:none;
  padding-bottom:max(env(safe-area-inset-bottom), 6px);
}
.skills::-webkit-scrollbar{display:none}
.sbtn{
  flex:0 0 auto;display:flex;align-items:center;gap:8px;
  padding:10px 12px;border-radius:14px;
}
.sbtn .ico{font-size:16px;line-height:1}
.sbtn .name{font-weight:900;letter-spacing:.2px}
.sbtn .cd{margin-left:6px;opacity:.9;font-variant-numeric:tabular-nums}

.overlay{position:fixed;inset:0;background:rgba(0,0,0,.58);display:none;align-items:center;justify-content:center;padding:16px;z-index:50}
.overlay.show{display:flex}
.panel{
  width:min(720px,92vw);
  border-radius:18px;border:1px solid var(--glass-bd);
  background:rgba(15,22,40,.92);
  padding:16px;box-shadow:var(--glass-shadow);
  max-height:calc(100svh - 32px);overflow:auto
}
.panel h2{margin:0 0 10px;font-size:18px;letter-spacing:.2px}
.opts{display:grid;grid-template-columns:1fr;gap:10px}
@media (min-width:720px){.opts{grid-template-columns:1fr 1fr 1fr}}
.opt{border-radius:16px;padding:14px;cursor:pointer}
.opt .t{font-weight:900;margin-bottom:6px}
.opt .d{opacity:.78;font-size:13px;line-height:1.4}
.panel .sub{opacity:.82;font-size:13px;line-height:1.35;margin:8px 0 14px;white-space:normal;overflow-wrap:anywhere;word-break:break-word}
.panel .row{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
.panel .row .pill{padding:10px 12px}
.panel.isStats .sub{font-size:12px;line-height:1.35}
.panel.isStats .opts{gap:8px}
.panel.isStats .opt{padding:12px}

.toast{
  position:absolute;left:50%;top:14px;transform:translateX(-50%);
  padding:10px 12px;border-radius:999px;border:1px solid var(--glass-bd);
  background:rgba(0,0,0,.35);font-size:13px;opacity:.9;display:none;pointer-events:none
}
.toast.show{display:block}

.rotateLock{
  position:fixed;inset:0;z-index:200;
  display:none;align-items:center;justify-content:center;
  background:rgba(0,0,0,.78);
  padding:18px;text-align:center;
}
.rotateLock .card{
  width:min(520px,92vw);
  border-radius:18px;border:1px solid var(--glass-bd);
  background:rgba(15,22,40,.92);
  padding:16px;box-shadow:var(--glass-shadow)
}
.rotateLock .title{font-weight:900;font-size:18px;margin-bottom:8px}
.rotateLock .desc{opacity:.85;line-height:1.45}
</style>
</head>

<body>
<div style="position:fixed;right:8px;bottom:8px;z-index:9999;font:12px system-ui;background:rgba(0,0,0,.6);padding:6px 8px;border-radius:10px;border:1px solid rgba(255,255,255,.15)">
  BUILD: AI-start-magnet (AI=free, Manual=buy)
</div>

<div class="app">
  <div class="hud">
    <div class="hudRow">
      <button class="pill" id="btnBack">â† Back</button>
      <span class="pill" id="hudStage">é—œå¡ 1</span>
      <span class="pill" id="hudCoins">ğŸª™ 0</span>

      <div class="lvx lvxTop" id="btnStats" role="button" tabindex="0" aria-label="æŸ¥çœ‹ç‹€æ…‹ä¸€è¦½">
        <span class="label" id="hudLv">LV 1</span>
        <span class="num" id="xpPct">0%</span>
      </div>
    </div>

    <div class="hudRow hudRow2">
      <div class="hpbar">
        <span class="label">HP</span>
        <div class="track"><div class="fill" id="hpFill"></div></div>
        <span class="num" id="hpNum">300/300</span>
      </div>

      <div class="hpRowRight">
        <span class="pill" id="hudShield">ğŸ›¡ +0</span>
        <button class="pill" id="btnShop">å•†åº—</button>
      </div>
    </div>
  </div>

  <div class="main">
    <div class="boardWrap" id="boardWrap">
      <canvas id="c"></canvas>
      <div class="toast" id="toast">Paused</div>
    </div>

    <div class="touchpad" id="touchpad" aria-label="touchpad">
      <div class="bar"></div>
      <div class="thumb" id="thumb" style="left:50%"></div>
      <div class="hint">å·¦å³æ‹–æ›³ç§»å‹•</div>
    </div>

    <div class="skills" id="skills">
      <button class="sbtn" id="btnBurst"><span class="ico">ğŸ”¥</span><span class="name">çˆ†ç™¼</span><span class="cd" id="cdBurst">Ready</span></button>
      <button class="sbtn" id="btnInvuln"><span class="ico">âœ¨</span><span class="name">ç„¡æ•µ</span><span class="cd" id="cdInvuln">Ready</span></button>

      <button class="sbtn" id="btnAI" title="è‡ªå‹•éŠç©ï¼ˆæ¸¬è©¦ç”¨ï¼Œå¯æ‹”æ‰ï¼‰" aria-pressed="false">
        <span class="ico">ğŸ¤–</span><span class="name">AI</span><span class="cd" id="aiState">OFF</span>
      </button>
    </div>
  </div>
</div>

<div class="overlay" id="overlay">
  <div class="panel" id="panel">
    <h2 id="panelTitle">å‡ç´šï¼šé¸ä¸€å€‹</h2>
    <div class="sub" id="panelSub" style="display:none"></div>
    <div class="opts" id="opts"></div>
    <div class="row" id="panelRow" style="display:none"></div>
  </div>
</div>

<div class="rotateLock" id="rotateLock">
  <div class="card">
    <div class="title">è«‹åˆ‡å›ç›´å‘</div>
    <div class="desc">é€™å€‹éŠæˆ²åªæ”¯æ´ç›´å‘ã€‚<br>è½‰å›ç›´å‘å¾Œæœƒè‡ªå‹•æ¢å¾©ã€‚</div>
  </div>
</div>

<script>
(()=>{ // setup
  // ---------- Safe-area / Dynamic Island ----------
  function isIOS(){
    return /iP(hone|ad|od)/.test(navigator.platform) || (navigator.userAgent.includes('Mac') && 'ontouchend' in document);
  }
  function readEnvInsetPx(side){
    const d=document.createElement('div');
    const isLR = (side === 'left' || side === 'right');
    d.style.cssText =
      `position:fixed;left:0;top:0;visibility:hidden;pointer-events:none;` +
      (isLR ? `width:env(safe-area-inset-${side});height:0;`
            : `height:env(safe-area-inset-${side});width:0;`);
    document.body.appendChild(d);
    const r = d.getBoundingClientRect();
    d.remove();
    return (isLR ? r.width : r.height) || 0;
  }
  function isDynamicIslandSize(){
    const w=Math.min(screen.width, screen.height);
    const h=Math.max(screen.width, screen.height);
    const key=`${w}x${h}`;
    return new Set(['393x852','430x932','402x874','440x956']).has(key);
  }
  function applySafeArea(){
    const root=document.documentElement;
    let top=readEnvInsetPx('top');
    let right=readEnvInsetPx('right');
    let bottom=readEnvInsetPx('bottom');
    let left=readEnvInsetPx('left');

    const standalone =
      (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) ||
      (navigator.standalone === true);

    if(isIOS() && top < 10) top = isDynamicIslandSize() ? 54 : 44;
    else top = Math.max(top, 24);

    const extraTop = standalone ? 14 : 10;
    const extraBottom = standalone ? 4 : 8;

    root.style.setProperty('--appSafeTop', `${top}px`);
    root.style.setProperty('--appSafeR', `${right}px`);
    root.style.setProperty('--appSafeB', `${bottom}px`);
    root.style.setProperty('--appSafeL', `${left}px`);
    root.style.setProperty('--appExtraTop', `${extraTop}px`);
    root.style.setProperty('--appExtraBottom', `${extraBottom}px`);
  }

  // ---------- Canvas ----------
  const wrap=document.getElementById('boardWrap'),canvas=document.getElementById('c'),ctx=canvas.getContext('2d',{alpha:true});
  let W=0,H=0;
  function resize(){
    const r=wrap.getBoundingClientRect(),dpr=Math.min(2,window.devicePixelRatio||1);
    canvas.width=Math.floor(r.width*dpr);
    canvas.height=Math.floor(r.height*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    W=r.width; H=r.height;
  }

  // ---------- HUD refs ----------
  const $stage=document.getElementById('hudStage');
  const $lv=document.getElementById('hudLv');
  const $xpPct=document.getElementById('xpPct');
  const $hudCoins=document.getElementById('hudCoins');
  const $hudShield=document.getElementById('hudShield');
  const $btnStats=document.getElementById('btnStats');

  const $hpFill=document.getElementById('hpFill'),$hpNum=document.getElementById('hpNum'),
        $toast=document.getElementById('toast'),$btnBack=document.getElementById('btnBack'),
        $btnShop=document.getElementById('btnShop'),
        $btnAI=document.getElementById('btnAI');

  // overlay refs
  const overlay=document.getElementById('overlay');
  const opts=document.getElementById('opts');
  const $panelTitle=document.getElementById('panelTitle');
  const $panelSub=document.getElementById('panelSub');
  const $panelRow=document.getElementById('panelRow');
  const $panel=document.getElementById('panel');

  // skills refs
  const $btnBurst=document.getElementById('btnBurst');
  const $btnInvuln=document.getElementById('btnInvuln');
  const $cdBurst=document.getElementById('cdBurst');
  const $cdInvuln=document.getElementById('cdInvuln');
  const $aiState=document.getElementById('aiState');

  // Back -> /games/
  $btnBack.addEventListener('click',()=>{
    if(document.referrer){
      try{const ref=new URL(document.referrer);if(ref.origin===location.origin){history.back();return}}catch(_){}
    }
    location.href='../';
  });

  // ---------- Orientation guard ----------
  const $rotateLock=document.getElementById('rotateLock');
  let lockedLandscape=false;

  let paused=false;
  let mode='play'; // play | levelup | shop | stats | gameover
  let gameOverSummary = null;
  let statsFromGameOver = false;
  let lastT=performance.now();

  function isLandscape(){
    const w = (window.visualViewport?.width ?? window.innerWidth);
    const h = (window.visualViewport?.height ?? window.innerHeight);
    return w > h;
  }
  function syncOrientationLock(){
    lockedLandscape = isLandscape();
    $rotateLock.style.display = lockedLandscape ? 'flex' : 'none';
    if(lockedLandscape){
      paused = true;
      $toast.classList.remove('show');
    }else{
      if(mode === 'play') paused = false;
      lastT = performance.now();
    }
  }

  function syncLayout(){
    applySafeArea();
    resize();
    syncOrientationLock();
  }
  syncLayout();
  window.addEventListener('resize', syncLayout, {passive:true});
  window.addEventListener('orientationchange', syncLayout, {passive:true});
  document.addEventListener('visibilitychange', ()=>{ if(!document.hidden) syncLayout(); }, {passive:true});
  if(window.visualViewport){
    visualViewport.addEventListener('resize', syncLayout, {passive:true});
    visualViewport.addEventListener('scroll', syncLayout, {passive:true});
  }

  // ---------- Utils ----------
  const rand=(a,b)=>a+Math.random()*(b-a);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const dist2=(ax,ay,bx,by)=>{const dx=ax-bx,dy=ay-by;return dx*dx+dy*dy};

  // ---------- Touchpad ----------
  const pad=document.getElementById('touchpad'),thumb=document.getElementById('thumb');
  let padActive=false,padX=.5;

  // ---------- Constants ----------
  const BASE_HP=300;
  const SPREAD_CAP_BASE=5;
  const PIERCE_CAP=5;

  const BULLET_R_MIN=3;
  const BULLET_R_BASE=4;
  const BULLET_R_CAP=8;
  const BULLET_R_UPG_CAP=7;

  const ENEMY_BULLET_SPEED_MUL = 0.30;

  const BOSS_SPREAD_P1 = 0.24;
  const BOSS_SPREAD_P2 = 0.26;
  const BOSS_SPREAD_P3 = 0.30;

  // skills (shop adjustable)
  let BURST_DURATION = 20;
  let BURST_CD = 50;
  let INVULN_DURATION = 20;
  let INVULN_CD = 80;

  function downtime(totalCd, dur){ return Math.max(0, Math.round((totalCd - dur)*10)/10); }

  // healer
  const HEALER_CHANCE_BY_STAGE = (stage)=>{
    if(stage <= 4)  return 0.00;
    if(stage <= 7)  return 0.10;
    if(stage <= 12) return 0.20;
    if(stage <= 19) return 0.30;
    if(stage <= 30) return 0.50;
    if(stage <= 40) return 0.70;
    if(stage <= 50) return 0.85;
    return 1.00;
  };
  function healerCountByChain(){
    let n = 1;
    if(Math.random() < 0.50) n++;
    if(n>=2 && Math.random() < 0.30) n++;
    if(n>=3 && Math.random() < 0.10) n++;
    if(n>=4 && Math.random() < 0.05) n++;
    return n;
  }
  const HEALER_HEAL_PCT = 0.05;
  const HEALER_PERIOD = 3.0;
  const HEALER_BOSS_MUL = 4.0;

  function bulletSizeDmgMul(r){
    const dr = Math.max(0, r - BULLET_R_BASE);
    return clamp(1 - dr*0.06, 0.70, 1.00);
  }
  function bulletClearMul(r){
    const dr = Math.max(0, r - BULLET_R_BASE);
    return clamp(1 + dr*0.05, 1.00, 1.25);
  }
  function enemyBulletHpByStage(stage){
    if(stage < 6)  return 8;
    if(stage < 14) return 10;
    if(stage < 20) return 14;
    if(stage < 26) return 18;
    return 22;
  }

  // ---------- State ----------
  const state={
    stage:1,wave:1,score:0,coins:0,xp:0,level:1,nextXp:60,
    waveClearCooldown:0,waveInProgress:false,bossEveryWaves:5
  };

  const player={
    x:W*.5,y:0,r:14,
    hp:BASE_HP,hpMax:BASE_HP,
    moveSpeed:520,fireRate:6.2,dmg:26,bulletSpeed:820,
    spread_perm:0, spreadCap:SPREAD_CAP_BASE,
    pierce_perm:2,
    shield:0,shieldMax:0,
    regen:0, xpGainMul:1.0, bulletR:BULLET_R_BASE
  };

  const buffs={
    magnet:0, spreadBonusT:0,
    invulnT:0, burstT:0
  };

  let hitIFrameT = 0;
  const skills={ burst:{cd:0}, invuln:{cd:0} };

  let pBullets=[],eBullets=[],enemies=[],drops=[],particles=[];

  function setPadX(nx){
    padX=Math.max(0,Math.min(1,nx));
    thumb.style.left=`${padX*100}%`;
    player.x=lerp(player.x,padX*W,1);
  }
  function pointerToPadX(e){const r=pad.getBoundingClientRect();return (e.clientX-r.left)/r.width}
  pad.addEventListener('pointerdown',e=>{e.preventDefault();pad.setPointerCapture(e.pointerId);padActive=true;setPadX(pointerToPadX(e))});
  pad.addEventListener('pointermove',e=>{if(!padActive)return;e.preventDefault();setPadX(pointerToPadX(e))});
  pad.addEventListener('pointerup',e=>{padActive=false;try{pad.releasePointerCapture(e.pointerId)}catch(_){}});pad.addEventListener('pointercancel',()=>padActive=false);

  function enemyHoldY(){return clamp(H*.18,110,190)}

  // ---------- Drops / Buffs ----------
  const DROP_TYPES=[ {key:'heal',w:22},{key:'shield',w:18},{key:'spread',w:14},{key:'magnet',w:10} ];
  function spreadAtCap(){ return player.spread_perm >= player.spreadCap; }
  function pickDrop(){
    const pool = spreadAtCap() ? DROP_TYPES.filter(x=>x.key!=='spread') : DROP_TYPES;
    const total=pool.reduce((s,a)=>s+a.w,0) || 1;
    let r=Math.random()*total;
    for(const it of pool){r-=it.w;if(r<=0)return it.key}
    return pool[0]?.key || 'heal';
  }
  function dropCoin(x,y,amt){ drops.push({x,y,r:10,vy:rand(70,130),type:'coin',life:12,amt}); }

  // shop purchased state ONLY
  const shopState={spreadCapUp:0,burstCdDown:0,invulnCdDown:0,burstDurUp:0,invulnDurUp:0,magnetRun:0};

  // âœ… single source of truth: magnet active if purchased OR AI enabled
  function strongMagnetActive(){
    return (shopState.magnetRun === 1) || (AI?.enabled === true);
  }
  function strongMagnetSpeed(){
    return strongMagnetActive() ? 820 : 260;
  }

  function maybeDrop(x,y,isBoss=false){
    const p = isBoss ? .92 : .22;
    if(Math.random() > p) return;

    const t = pickDrop();

    // âœ… if AI mode has strong magnet, magnet drop becomes coin (same behavior as purchased)
    if(strongMagnetActive() && t === 'magnet'){
      dropCoin(x, y, 3);
      return;
    }

    drops.push({x,y,r:10,vy:rand(70,140),type:t,life:12});
  }

  function applyDrop(type, d){
    if(type==='heal'){
      player.hp=clamp(player.hp+35,0,player.hpMax);
    }else if(type==='shield'){
      player.shieldMax=Math.max(player.shieldMax,30);
      player.shield=clamp(player.shield+30,0,player.shieldMax);
    }else if(type==='spread'){
      buffs.spreadBonusT=Math.max(buffs.spreadBonusT,7.5);
    }else if(type==='magnet'){
      // âœ… AI mode: ignore magnet pickup (already strong); Manual: apply timed magnet
      if(!strongMagnetActive()){
        buffs.magnet=Math.max(buffs.magnet,9.0);
      }else{
        dropCoin(d?.x ?? player.x, d?.y ?? player.y, 1);
      }
    }else if(type==='coin'){
      state.coins += Math.max(1, d?.amt ?? 1);
    }
  }

  // ---------- Shop ----------
  function price(base, lvl, growth=1.5){ return Math.floor(base * Math.pow(growth, lvl)); }

  function shopItems(){
    const burstDown = downtime(BURST_CD, BURST_DURATION);
    const invDown   = downtime(INVULN_CD, INVULN_DURATION);

    return [
      { id:'spreadCapUp', name:'æ•£å°„ä¸Šé™ +1', desc:`æå‡æ•£å°„ä¸Šé™ï¼ˆç›®å‰ ${player.spreadCap}ï¼‰`,
        cost:price(260, shopState.spreadCapUp, 1.5),
        canBuy:()=>true,
        buy:()=>{ shopState.spreadCapUp++; player.spreadCap++; } },

      { id:'burstCdDown', name:'çˆ†ç™¼ CD -1s', desc:`é™ä½çˆ†ç™¼ CDï¼šç›®å‰ <b>${burstDown.toFixed(0)}s</b>`,
        cost:price(240, shopState.burstCdDown, 1.5),
        canBuy:()=>downtime(BURST_CD, BURST_DURATION) > 5,
        buy:()=>{ shopState.burstCdDown++; BURST_CD=Math.max(BURST_DURATION+5, BURST_CD-1); if(skills.burst.cd>BURST_CD) skills.burst.cd=BURST_CD; } },

      { id:'invulnCdDown', name:'ç„¡æ•µ CD -1s', desc:`é™ä½ç„¡æ•µ CDï¼šç›®å‰ <b>${invDown.toFixed(0)}s</b>`,
        cost:price(240, shopState.invulnCdDown, 1.5),
        canBuy:()=>downtime(INVULN_CD, INVULN_DURATION) > 8,
        buy:()=>{ shopState.invulnCdDown++; INVULN_CD=Math.max(INVULN_DURATION+8, INVULN_CD-1); if(skills.invuln.cd>INVULN_CD) skills.invuln.cd=INVULN_CD; } },

      { id:'burstDurUp', name:'çˆ†ç™¼æŒçºŒ +1s', desc:`å»¶é•·çˆ†ç™¼æ™‚é–“ï¼ˆç›®å‰ ${BURST_DURATION.toFixed(0)}sï¼‰`,
        cost:price(240, shopState.burstDurUp, 1.5),
        canBuy:()=>BURST_DURATION < 60,
        buy:()=>{ shopState.burstDurUp++; BURST_DURATION=Math.min(60, BURST_DURATION+1); if(BURST_CD<BURST_DURATION) BURST_CD=BURST_DURATION; } },

      { id:'invulnDurUp', name:'ç„¡æ•µæŒçºŒ +1s', desc:`å»¶é•·ç„¡æ•µæ™‚é–“ï¼ˆç›®å‰ ${INVULN_DURATION.toFixed(0)}sï¼‰`,
        cost:price(240, shopState.invulnDurUp, 1.5),
        canBuy:()=>INVULN_DURATION < 40,
        buy:()=>{ shopState.invulnDurUp++; INVULN_DURATION=Math.min(40, INVULN_DURATION+1); if(INVULN_CD<INVULN_DURATION) INVULN_CD=INVULN_DURATION; } },

      { id:'magnetRun', name:'å¼·åŠ›ç£éµ', desc:'æœ¬å±€ç²å¾—å¼·åŠ›ç£éµæ•ˆæœï¼šæ‰è½ç‰©æœƒè‡ªå‹•é£›åˆ°ä½ èº«ä¸Šï¼ˆç›´åˆ° Game Overï¼‰',
        cost:2000,
        // âœ… AI æ¨¡å¼ä¸éœ€è¦è²·ï¼›æ‰‹å‹•æ‰éœ€è¦è²·
        canBuy:()=> (shopState.magnetRun===0) && !(AI?.enabled === true),
        buy:()=>{ shopState.magnetRun=1; buffs.magnet=Math.max(buffs.magnet, 1e9); } },
    ];
  }

  function renderShop(){
    $panel.classList.remove('isStats');
    overlay.classList.add('show');
    opts.innerHTML='';
    $panelRow.innerHTML='';

    $panelTitle.textContent='å•†åº—';
    $panelSub.style.display='block';
    $panelSub.innerHTML=`é‡‘å¹£ï¼š<b>${state.coins}</b>`;

    const items=shopItems();
    for(const it of items){
      const affordable = state.coins >= it.cost;
      const allowed = it.canBuy ? it.canBuy() : true;
      const canBuy = affordable && allowed;

      const el=document.createElement('div');
      el.className='opt';
      el.innerHTML=
        `<div class="t">${it.name} <span style="opacity:.8">ï¼ˆğŸª™${it.cost}ï¼‰</span></div>`+
        `<div class="d">${it.desc}${allowed?'':'<br><span style="opacity:.7">ï¼ˆå·²é”ä¸Šé™ï¼AIå·²è‡ªå¸¶ï¼‰</span>'}</div>`;

      if(!canBuy){
        el.style.opacity='0.55';
        el.style.cursor='default';
      }else{
        el.addEventListener('click',()=>{
          if(mode!=='shop' || !paused) return;
          if(state.coins < it.cost) return;
          if(it.canBuy && !it.canBuy()) return;

          state.coins -= it.cost;
          try{ it.buy && it.buy(); }catch(_){}
          renderShop();
        });
      }
      opts.appendChild(el);
    }

    $panelRow.style.display='flex';
    const btnClose=document.createElement('button');
    btnClose.className='pill';
    btnClose.textContent='å›åˆ°éŠæˆ²';
    btnClose.addEventListener('click',closeShop);
    $panelRow.appendChild(btnClose);
  }

  // ---------- Skills ----------
  const SKILL_EPS = 1e-6;
  function skillCdLeft(k){ return Math.max(0, (skills[k]?.cd || 0)); }
  function canUseSkill(k){
    if(mode!=='play' || paused) return false;
    if(k==='burst')  return (buffs.burstT <= SKILL_EPS)  && (skillCdLeft('burst') <= SKILL_EPS);
    if(k==='invuln') return (buffs.invulnT <= SKILL_EPS) && (skillCdLeft('invuln') <= SKILL_EPS);
    return (skillCdLeft(k) <= SKILL_EPS);
  }
  function useBurst(){
    if(!canUseSkill('burst')) return;
    skills.burst.cd = BURST_CD;
    buffs.burstT = Math.max(buffs.burstT, BURST_DURATION);
    toastMsg(`ğŸ”¥ çˆ†ç™¼ï¼šå‚·å®³Ã—2ï¼ˆ${BURST_DURATION.toFixed(0)}sï¼‰`,0.7);
  }
  function useInvuln(){
    if(!canUseSkill('invuln')) return;
    skills.invuln.cd = INVULN_CD;
    buffs.invulnT = Math.max(buffs.invulnT, INVULN_DURATION);
    toastMsg(`âœ¨ ç„¡æ•µï¼ˆ${INVULN_DURATION.toFixed(0)}sï¼‰`,0.7);
  }
  $btnBurst.addEventListener('click',useBurst);
  $btnInvuln.addEventListener('click',useInvuln);

  function openShop(){
    if(mode!=='play') return;
    if(lockedLandscape) return;
    mode='shop';
    paused=true;
    $toast.classList.remove('show');
    renderShop();
  }
  function closeShop(){
    overlay.classList.remove('show');
    $panel.classList.remove('isStats');
    mode='play';
    paused=false;
    lastT=performance.now();
  }
  $btnShop.addEventListener('click',()=>{
    if(mode==='play') openShop();
    else if(mode==='shop') closeShop();
  });

  // ---------- Combat core helpers ----------
  function spreadTotal(){ return player.spread_perm + (buffs.spreadBonusT>0?1:0); }
  function shotsFromSpread(s){ return Math.max(1, 1 + Math.floor(s)); }

  // === AUTOPLAY AI (EASY-REMOVE) BEGIN ===
  const AI = {
    enabled:false,

    // sniper SOP state
    sniperSweepX:0,
    sniperForceLeft:true,

    // shop
    autoShop:true,
    nextShopAtMs:0,
    shopLock:false,

    // âœ… to restore timed-magnet when turning AI off (manual mode)
    _savedManualMagnet: 0,

    toggle(on){
      const newEnabled = (on==null) ? !this.enabled : !!on;
      if(newEnabled === this.enabled) return;

      // leaving AI -> restore manual magnet timer (unless purchased permanent)
      if(this.enabled && !newEnabled){
        if(shopState.magnetRun === 0){
          buffs.magnet = Math.max(0, this._savedManualMagnet || 0);
        }else{
          buffs.magnet = Math.max(buffs.magnet, 1e9);
        }
      }

      // entering AI -> grant strong magnet for free
      if(!this.enabled && newEnabled){
        this._savedManualMagnet = buffs.magnet;   // keep whatever manual timer had
        buffs.magnet = Math.max(buffs.magnet, 1e9); // âœ… AI è‡ªå¸¶å¼·åŠ›ç£éµï¼ˆæœ¬å±€ï¼‰
      }

      this.enabled = newEnabled;
      if($aiState) $aiState.textContent = this.enabled ? 'ON' : 'OFF';
      if($btnAI) $btnAI.setAttribute('aria-pressed', this.enabled ? 'true' : 'false');

      padActive=false;
      this.shopLock=false;
      this.nextShopAtMs=0;

      this.sniperForceLeft=true;
      this.sniperSweepX=player.x;
    },

    // ---------- å‡ç´šè‡ªå‹•é¸ï¼ˆæ•£å°„>ç©¿é€>å¢å‚·>è¡€é‡>è­·ç›¾ï¼‰ ----------
    pickUpgrade(picks){
      const hpPct = player.hpMax>0 ? (player.hp/player.hpMax) : 1;

      const baseScore = (k)=>{
        if(k==='spread_perm')      return 120;
        if(k==='pierce_perm')     return 105;
        if(k==='dmg')             return 90;
        if(k==='hp')              return 70;
        if(k==='shield_cap')      return 58;
        if(k==='firerate')        return 28;
        if(k==='regen')           return 18;
        if(k==='bullet_size')     return 10;
        if(k==='xp_gain')         return 6;
        return 0;
      };

      const scoreOf = (k)=>{
        let s = baseScore(k);

        if(hpPct < 0.35){
          if(k==='hp') s += 35;
          if(k==='shield_cap') s += 20;
          if(k==='regen') s += 10;
        }else if(hpPct < 0.55){
          if(k==='hp') s += 12;
          if(k==='shield_cap') s += 8;
        }

        if(k==='spread_perm' && player.spread_perm >= player.spreadCap) s = -1e9;
        if(k==='pierce_perm' && player.pierce_perm >= PIERCE_CAP) s = -1e9;
        if(k==='bullet_size' && player.bulletR >= BULLET_R_UPG_CAP) s = -1e9;

        return s;
      };

      let best=picks[0], bestS=-1e18;
      for(const u of picks){
        const sc = scoreOf(u.key);
        if(sc > bestS){ bestS=sc; best=u; }
      }
      return best;
    },

    // ---------- å•†åº—è‡ªå‹•é¸ ----------
    pickShopItem(items, ctx){
      const hpPct = player.hpMax>0 ? (player.hp/player.hpMax) : 1;
      const shieldPct = player.shieldMax>0 ? (player.shield/player.shieldMax) : 0;

      const spreadBlocked = (player.spread_perm >= player.spreadCap-0.01);
      const wantSurvive = (hpPct < 0.45) || (shieldPct < 0.20) || ((ctx?.bulletPressure||0) >= 6);

      const scoreId = (id)=>{
        switch(id){
          case 'magnetRun':   return -1e9; // âœ… AI already has it (and manual purchase handled outside AI)
          case 'spreadCapUp': return spreadBlocked ? 320 : 160;
          case 'invulnCdDown':return (wantSurvive ? 360 : 220);
          case 'invulnDurUp': return (wantSurvive ? 240 : 150);
          case 'burstCdDown': return (ctx?.hasBoss ? 240 : 160);
          case 'burstDurUp':  return (ctx?.hasBoss ? 200 : 130);
          default: return 0;
        }
      };

      let best=null, bestS=-1e18;
      for(const it of items){
        const affordable = state.coins >= it.cost;
        const allowed = it.canBuy ? it.canBuy() : true;
        if(!affordable || !allowed) continue;

        const pricePenalty = it.cost * 0.06;
        const s = scoreId(it.id) - pricePenalty;
        if(s > bestS){ bestS=s; best=it; }
      }
      return best;
    },

    shopTick(dt, ctx){
      if(!this.autoShop || !this.enabled) return;
      if(mode!=='play' || paused || lockedLandscape) return;

      const bossNow = enemies.find(e=>e.type==='boss');
      if(bossNow && (bossNow.kind==='sniper' || bossNow.kind==='defender')) return;

      if(state.coins < 300) return;

      const itemsNow = shopItems();
      const hasAffordable = itemsNow.some(it => (state.coins >= it.cost) && (it.canBuy ? it.canBuy() : true));
      if(!hasAffordable) return;

      const now = performance.now();
      if(this.shopLock) return;
      if(now < (this.nextShopAtMs||0)) return;

      this.shopLock = true;
      this.nextShopAtMs = now + 6500;

      openShop();
      setTimeout(()=>{ this.autoBuyInShop(ctx); }, 60);
    },

    autoBuyInShop(ctx){
      if(mode!=='shop' || !paused) { this.shopLock=false; return; }

      const safeCtx = ctx || { hasBoss:false, bulletPressure:0, bestScore:0 };
      const bought = [];

      for(let loop=0; loop<6; loop++){
        const items = shopItems();
        const pick = this.pickShopItem(items, safeCtx);
        if(!pick) break;
        if(state.coins < pick.cost) break;
        if(pick.canBuy && !pick.canBuy()) break;

        state.coins -= pick.cost;
        try{ pick.buy && pick.buy(); }catch(_){}
        bought.push(pick.name);
      }

      try{ renderShop(); }catch(_){}

      setTimeout(()=>{
        closeShop();
        if(bought.length){
          toastMsg(`ğŸ›’ è‡ªå‹•æ¡è³¼ï¼š${bought.slice(0,2).join(' / ')}${bought.length>2?'â€¦':''}`, 0.55);
        }
        this.shopLock=false;
      }, 80);
    },

    tick(dt){
      if(!this.enabled) return;
      if(mode!=='play' || paused || lockedLandscape) return;

      const safeL = player.r + 10;
      const safeR = W - player.r - 10;
      const leftX  = safeL + 2;
      const rightX = safeR - 2;

      const sniperBoss = enemies.find(e => e.type==='boss' && e.kind==='sniper');

      // Sniper SOP: left -> sweep right -> teleport left -> repeat
      if(sniperBoss){
        if(this.sniperForceLeft){
          this.sniperSweepX = leftX;
          setPadX(leftX / W);
          this.sniperForceLeft = false;
          return;
        }

        const sweepSpd = 80;
        this.sniperSweepX = clamp(this.sniperSweepX + sweepSpd * dt, leftX, rightX);

        if(this.sniperSweepX >= rightX - 0.5){
          setPadX(leftX / W);
          this.sniperSweepX = leftX;
          return;
        }

        setPadX(this.sniperSweepX / W);

        if(canUseSkill('invuln')){
          let minHit = 999;
          const py = player.y;
          for(const b of eBullets){
            if(!b?.alive || !b.beam) continue;
            const vy = b.vy || 0;
            if(vy <= 1) continue;
            const tHit = (py - b.y) / vy;
            if(tHit > 0 && tHit < minHit) minHit = tHit;
          }
          if(minHit < 0.34) useInvuln();
        }
        return;
      }else{
        this.sniperForceLeft = true;
        this.sniperSweepX = player.x;
      }

      // (non-sniper AI omitted here for brevityâ€”keep your existing logic if you want)
    }
  };

  if($btnAI){
    $btnAI.addEventListener('click', ()=>AI.toggle());
    if($aiState) $aiState.textContent = 'OFF';
    $btnAI.setAttribute('aria-pressed', 'false');
  }
  window.addEventListener('keydown',(e)=>{ if(e.code==='KeyB') AI.toggle(); });
  // === AUTOPLAY AI END ===

  // ---------- Level-up ----------
  const UPGRADES=[
    {key:'dmg',t:'ç«åŠ›æå‡',d:'å‚·å®³ +10%'},
    {key:'firerate',t:'å°„é€Ÿæå‡',d:'å°„é€Ÿ +18%'},
    {key:'hp',t:'æ“´å……è£ç”²',d:'HP ä¸Šé™ +20ï¼Œä¸¦å›æ»¿'},
    {key:'pierce_perm',t:'æ°¸ä¹…ç©¿é€',d:'ç©¿é€ +1'},
    {key:'spread_perm',t:'æ°¸ä¹…æ•£å°„',d:'æ•£å°„ +1'},
    {key:'shield_cap',t:'è­·ç›¾æ“´å®¹',d:'è­·ç›¾ä¸Šé™ +20ï¼Œä¸¦å›æ»¿'},
    {key:'regen',t:'è‡ªå‹•ä¿®å¾©',d:'æ¯ç§’å›å¾© +2'},
    {key:'xp_gain',t:'å­¸ç¿’åŠ é€Ÿ',d:'ç²å¾— XP +10%'},
    {key:'bullet_size',t:'å½ˆé«”å¢å¼·',d:'å­å½ˆæ›´å¤§'},
  ];
  function canPickUpgrade(key){
    if(key==='pierce_perm') return player.pierce_perm < PIERCE_CAP;
    if(key==='spread_perm') return player.spread_perm < player.spreadCap;
    if(key==='bullet_size') return player.bulletR < BULLET_R_UPG_CAP;
    return true;
  }

  function openLevelUp(){
    mode='levelup';
    paused=true;

    $panel.classList.remove('isStats');
    overlay.classList.add('show');
    $panelTitle.textContent='å‡ç´šï¼šé¸ä¸€å€‹';
    $panelSub.style.display='none';
    $panelRow.style.display='none';
    $panelRow.innerHTML='';
    opts.innerHTML='';

    const filtered=UPGRADES.filter(u=>canPickUpgrade(u.key));
    const pool=[...filtered];
    const picks=[];
    const guardFillers=['regen','xp_gain','bullet_size','dmg','firerate'];

    while(picks.length<3 && pool.length){
      const i=Math.floor(Math.random()*pool.length);
      picks.push(pool.splice(i,1)[0]);
    }
    while(picks.length<3){
      const k=guardFillers[picks.length % guardFillers.length];
      const u=UPGRADES.find(x=>x.key===k);
      if(u && !picks.some(p=>p.key===u.key) && canPickUpgrade(u.key)) picks.push(u);
      else break;
    }

    if(AI.enabled){
      const best = AI.pickUpgrade(picks);
      applyUpgrade(best.key);
      overlay.classList.remove('show');
      mode='play';
      paused=false;
      $toast.classList.remove('show');
      lastT=performance.now();
      return;
    }

    for(const u of picks){
      const el=document.createElement('div');
      el.className='opt';
      el.innerHTML=`<div class="t">${u.t}</div><div class="d">${u.d}</div>`;
      el.addEventListener('click',()=>{
        applyUpgrade(u.key);
        overlay.classList.remove('show');
        mode='play';
        paused=false;
        $toast.classList.remove('show');
        lastT=performance.now();
      });
      opts.appendChild(el);
    }
  }

  function applyUpgrade(key){
    if(key==='dmg') player.dmg*=1.10;
    else if(key==='firerate') player.fireRate*=1.18;
    else if(key==='hp'){player.hpMax+=20;player.hp=player.hpMax}
    else if(key==='pierce_perm') player.pierce_perm=Math.min(PIERCE_CAP, player.pierce_perm+1);
    else if(key==='spread_perm') player.spread_perm=Math.min(player.spreadCap, player.spread_perm+1);
    else if(key==='shield_cap'){player.shieldMax+=20;player.shield=player.shieldMax}
    else if(key==='regen') player.regen+=2;
    else if(key==='xp_gain') player.xpGainMul*=1.10;
    else if(key==='bullet_size') player.bulletR = clamp(player.bulletR+1, BULLET_R_MIN, BULLET_R_CAP);
  }

  function xpStageMul(stage){
    if(stage <= 10) return 1 + (stage-1)*0.05;
    if(stage <= 20) return 1.45 + (stage-10)*0.06;
    return 2.05 + (stage-20)*0.04;
  }
  function addXp(xp){
    xp*=player.xpGainMul;
    state.xp+=xp;
    while(state.xp>=state.nextXp){
      state.xp-=state.nextXp;
      state.level+=1;
      state.nextXp=Math.floor(state.nextXp*1.15+14);
      openLevelUp();
    }
  }

  // ---------- Combat ----------
  function enemyBulletCap(){
    const boss = enemies.find(e=>e.type==='boss');
    if(!boss) return 140;
    if(boss.kind === 'sniper')   return 420;
    if(boss.kind === 'defender') return 30;
    return 260;
  }

  let fireAcc=0;
  function pierceTotal(){ return player.pierce_perm; }

  function spreadDmgMul(n){
    if(n<=1) return 1;
    return clamp(1 / (1 + 0.25*(n-1)), 0.22, 1.0);
  }

  // center-out spread
  function shotVXPattern(n){
    if(n<=1) return [0];

    const baseMax = 240;
    const extra = Math.max(0, n-5) * 26;
    const maxV = clamp(baseMax + extra, 240, 520);

    const arr=[];
    const hasCenter = (n % 2 === 1);
    const pairs = Math.floor(n/2);
    const gamma = 1.55;

    if(hasCenter) arr.push(0);
    for(let k=1;k<=pairs;k++){
      const t = k / pairs;
      const mag = Math.pow(t, gamma) * maxV;
      arr.push(-mag, +mag);
    }
    return arr;
  }

  function shoot(dt){
    fireAcc+=dt*player.fireRate;
    while(fireAcc>=1){ fireAcc-=1; spawnPlayerShot(); }
  }

  function spawnPlayerShot(){
    const s=spreadTotal();
    const n=Math.max(1, 1 + Math.floor(s));
    const r = clamp(player.bulletR, BULLET_R_MIN, BULLET_R_CAP);

    const burstMul = (buffs.burstT>0)?2.0:1.0;
    const dmg = player.dmg * spreadDmgMul(n) * bulletSizeDmgMul(r) * burstMul;

    const vxArr=shotVXPattern(n);
    const pr=pierceTotal();
    const baseY=player.y-player.r-6;

    const clashLeftBase = ((r>=6)?2:1) + Math.min(5, pr);

    for(const vx of vxArr){
      pBullets.push({x:player.x,y:baseY,r,vx,vy:-player.bulletSpeed,dmg,pierce:pr,alive:true, clashLeft:clashLeftBase});
    }
  }

  function enemyShoot(e,ang,sMul=1,dMul=1,meta={}){
    if(eBullets.length>=enemyBulletCap())return;
    const spd=(e.bulletSpeed??300)*sMul*ENEMY_BULLET_SPEED_MUL;

    const isBeam = !!meta.beam;
    const r = clamp(meta.r ?? (isBeam?5:4), 3, 10);
    const pierce = meta.pierce ?? 0;

    const baseHp = enemyBulletHpByStage(state.stage);
    const hp = isBeam ? 1 : (meta.hp ?? baseHp);

    const len = isBeam ? (meta.len ?? (state.stage>=26?34:28)) : 0;

    eBullets.push({x:e.x,y:e.y+e.r+4,r,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,dmg:(e.bulletDmg??8)*dMul,alive:true,pierce,hp,beam:isBeam,len});
  }

  // (spawn / boss / mobShoot / draw code: keep your existing full version)
  // é€™è£¡æˆ‘åªå±•ç¤ºã€ŒAI=å¼·åŠ›ç£éµã€æ”¹å‹•é»ï¼Œå…¶ä»–é‚è¼¯ä½ åŸæœ¬é‚£ä»½å¯åŸå°ä¸å‹•ä¿ç•™ã€‚

  // ---------- Update loop (drops magnet attraction) ----------
  function update(dt){
    // timers
    for(const k of ['magnet','spreadBonusT','invulnT','burstT']){
      if(buffs[k]>0) buffs[k]=Math.max(0,buffs[k]-dt);
    }
    for(const k in skills){
      if(skills[k].cd>0) skills[k].cd=Math.max(0, skills[k].cd-dt);
    }
    if(hitIFrameT > 0) hitIFrameT = Math.max(0, hitIFrameT - dt);

    // âœ… regen
    if(player.regen>0 && player.hp>0) player.hp=clamp(player.hp+player.regen*dt,0,player.hpMax);

    player.y=H-42;

    // âœ… AI tick
    AI.tick(dt);

    player.x=clamp(player.x,player.r+8,W-player.r-8);
    shoot(dt);

    // drops (coin included)
    for(const d of drops){
      d.y+=d.vy*dt; d.life-=dt;

      // âœ… magnet rule: AI enabled => always attract (strong magnet)
      if(strongMagnetActive() || buffs.magnet>0){
        const dx=player.x-d.x,dy=player.y-d.y,l=Math.hypot(dx,dy)||1;
        const spd = strongMagnetActive() ? 820 : 260;
        d.x+=(dx/l)*spd*dt; d.y+=(dy/l)*spd*dt;
      }

      if(d.y>H+60||d.life<=0) d.dead=true;
      if(dist2(d.x,d.y,player.x,player.y)<(d.r+player.r+8)**2){
        d.dead=true;
        applyDrop(d.type, d);
      }
    }

    // ...ï¼ˆå…¶é¤˜ update å…§å®¹ç…§ä½ åŸæœ¬å®Œæ•´ç¢¼ï¼‰
  }

  // ---------- HUD / Frame (keep your existing draw & syncHud) ----------
  let toastT=0, lastToastText='';
  function toastMsg(text,sec=.75){
    if(text===lastToastText && toastT>0.25) return;
    lastToastText = text;
    $toast.textContent=text;
    $toast.classList.add('show');
    toastT=sec;
  }

  // init
  setPadX(.5);
  // spawnWave(); syncOrientationLock(); requestAnimationFrame(frame);
  // ä½ æŠŠä½ åŸæœ¬çš„ init / frame / draw / spawnWave æ¥å›å»å³å¯ã€‚
})();
</script>
</body>
</html>