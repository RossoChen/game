<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover"/>
<title>Blaster v2 (100 stages)</title>
<meta name="theme-color" content="#0b1220"/>
<style>
:root{
  color-scheme:dark;
  --gap:8px;
  --ui-fg:#e7eefc;
  --glass-bd: rgba(255,255,255,.14);
  --glass-bd2: rgba(255,255,255,.12);
  --glass-bg: rgba(255,255,255,.06);
  --glass-bg2: rgba(255,255,255,.05);
  --glass-shadow: 0 18px 70px rgba(0,0,0,.55);
  --tap: transparent;
}
html,body{
  height:100%;margin:0;background:#0b1220;color:var(--ui-fg);
  font-family:system-ui,"Noto Sans TC",sans-serif;
  -webkit-user-select:none;user-select:none;
  touch-action:manipulation;overflow:hidden
}
body{position:fixed;inset:0}
.app{
  height:100svh;
  padding:18px 10px 16px 10px;
  display:flex;flex-direction:column;gap:var(--gap);box-sizing:border-box;
}
.pill, button.pill, .sbtn, .opt{
  color:var(--ui-fg);
  border:1px solid var(--glass-bd);
  background:var(--glass-bg);
  -webkit-tap-highlight-color:var(--tap);
  white-space:nowrap;
}
.pill:active, button.pill:active, .sbtn:active, .opt:active{ transform:scale(.99); }
button.pill:disabled, .sbtn[disabled]{ opacity:.45; cursor:default; }

.hud{display:flex;flex-direction:column;gap:var(--gap);min-height:0}
.hudRow{display:flex;align-items:center;gap:var(--gap);overflow-x:auto;-webkit-overflow-scrolling:touch;scrollbar-width:none}
.hudRow::-webkit-scrollbar{display:none}
.hudRow2{justify-content:space-between}
.pill,button.pill{border-radius:999px;padding:8px 10px;font-size:13px;line-height:1}
#hudStage{min-width:86px;text-align:center}
#hudChapter{min-width:96px;text-align:center}

.hpbar{
  flex:1 1 auto; min-width:0;
  display:flex;align-items:center;gap:8px;
  padding:8px 10px;border-radius:16px;
  border:1px solid var(--glass-bd2);
  background:var(--glass-bg2);
}
.hpbar .label{opacity:.85;font-weight:800;letter-spacing:.2px}
.hpbar .track{flex:1 1 auto; min-width:90px; max-width:240px;height:12px;border-radius:999px;background:rgba(255,255,255,.10);overflow:hidden;border:1px solid rgba(255,255,255,.10)}
.hpbar .fill{height:100%;width:50%;background:rgba(120,255,200,.95)}
.hpbar .num{opacity:.85;font-variant-numeric:tabular-nums;min-width:86px;text-align:right}
.rightRow{display:flex;align-items:center;gap:var(--gap);flex:0 0 auto}

.main{flex:1;min-height:0;display:flex;flex-direction:column;gap:var(--gap)}
.boardWrap{
  flex:1;min-height:0;border-radius:18px;
  border:1px solid var(--glass-bd2);
  background:
    radial-gradient(1200px 800px at 50% 0%, rgba(90,120,255,.10), transparent 60%),
    rgba(255,255,255,.03);
  overflow:hidden;position:relative
}
canvas{width:100%;height:100%;display:block}
.toast{
  position:absolute;left:50%;top:14px;transform:translateX(-50%);
  padding:10px 12px;border-radius:999px;border:1px solid var(--glass-bd);
  background:rgba(0,0,0,.35);font-size:13px;opacity:.9;display:none;pointer-events:none
}
.toast.show{display:block}

.touchpad{
  flex:0 0 auto;height:max(42px,5.5svh);
  border-radius:16px;background:rgba(255,255,255,.04);
  border:1px solid var(--glass-bd2);
  position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent
}
.touchpad .bar{position:absolute;left:10px;right:10px;top:16px;bottom:16px;border-radius:14px;border:1px dashed rgba(255,255,255,.18);opacity:.7}
.touchpad .thumb{position:absolute;top:50%;width:46px;height:46px;transform:translate(-50%,-50%);border-radius:999px;border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.08);box-shadow:0 8px 30px rgba(0,0,0,.35);pointer-events:none}
.touchpad .hint{position:absolute;inset:auto 0 10px 0;text-align:center;font-size:14px;opacity:.75;pointer-events:none}

.skills{flex:0 0 auto;display:flex;gap:8px;align-items:center;overflow-x:auto;-webkit-overflow-scrolling:touch;scrollbar-width:none;padding-bottom:6px}
.skills::-webkit-scrollbar{display:none}
.sbtn{flex:0 0 auto;display:flex;align-items:center;gap:8px;padding:10px 12px;border-radius:14px}
.sbtn .ico{font-size:16px;line-height:1}
.sbtn .name{font-weight:900;letter-spacing:.2px}
.sbtn .cd{margin-left:6px;opacity:.9;font-variant-numeric:tabular-nums}

.overlay{position:fixed;inset:0;background:rgba(0,0,0,.58);display:none;align-items:center;justify-content:center;padding:16px;z-index:50}
.overlay.show{display:flex}
.panel{
  width:min(720px,92vw);
  border-radius:18px;border:1px solid var(--glass-bd);
  background:rgba(15,22,40,.92);
  padding:16px;box-shadow:var(--glass-shadow);
  max-height:calc(100svh - 32px);overflow:auto
}
.panel h2{margin:0 0 10px;font-size:18px;letter-spacing:.2px}
.sub{opacity:.82;font-size:13px;line-height:1.35;margin:8px 0 14px;white-space:normal;overflow-wrap:anywhere;word-break:break-word}
.opts{display:grid;grid-template-columns:1fr;gap:10px}
@media (min-width:720px){.opts{grid-template-columns:1fr 1fr 1fr}}
.opt{border-radius:16px;padding:14px;cursor:pointer}
.opt .t{font-weight:900;margin-bottom:6px}
.opt .d{opacity:.78;font-size:13px;line-height:1.4}
.row{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
</style>
</head>
<body>
<div class="app">
  <div class="hud">
    <div class="hudRow">
      <span class="pill" id="hudChapter">CH 1-1</span>
      <span class="pill" id="hudStage">é—œå¡ 1</span>
      <span class="pill" id="hudWave">æ³¢æ¬¡ 1/5</span>
      <span class="pill" id="hudCoins">ğŸª™ 0</span>
      <span class="pill" id="hudShield">ğŸ›¡ +0</span>
    </div>
    <div class="hudRow hudRow2">
      <div class="hpbar">
        <span class="label">HP</span>
        <div class="track"><div class="fill" id="hpFill"></div></div>
        <span class="num" id="hpNum">300/300</span>
      </div>
      <div class="rightRow">
        <button class="pill" id="btnShop">å•†åº—</button>
        <button class="pill" id="btnPause">Pause</button>
      </div>
    </div>
  </div>

  <div class="main">
    <div class="boardWrap" id="boardWrap">
      <canvas id="c"></canvas>
      <div class="toast" id="toast">Paused</div>
    </div>

    <div class="touchpad" id="touchpad">
      <div class="bar"></div>
      <div class="thumb" id="thumb" style="left:50%"></div>
      <div class="hint">å·¦å³æ‹–æ›³ç§»å‹•</div>
    </div>

    <div class="skills">
      <button class="sbtn" id="btnBurst"><span class="ico">ğŸ”¥</span><span class="name">çˆ†ç™¼</span><span class="cd" id="cdBurst">Ready</span></button>
      <button class="sbtn" id="btnInvuln"><span class="ico">âœ¨</span><span class="name">ç„¡æ•µ</span><span class="cd" id="cdInvuln">Ready</span></button>
      <button class="sbtn" id="btnAI" aria-pressed="false" title="è‡ªå‹•éŠç©ï¼ˆæ¸¬è©¦ç”¨ï¼‰"><span class="ico">ğŸ¤–</span><span class="name">AI</span><span class="cd" id="aiState">OFF</span></button>
    </div>
  </div>
</div>

<div class="overlay" id="overlay">
  <div class="panel" id="panel">
    <h2 id="panelTitle">å•†åº—</h2>
    <div class="sub" id="panelSub"></div>
    <div class="opts" id="opts"></div>
    <div class="row" id="panelRow"></div>
  </div>
</div>

<script>
(()=>{ // Blaster v2 â€” run-based campaign 1..100
  const wrap=document.getElementById('boardWrap'), canvas=document.getElementById('c');
  const ctx=canvas.getContext('2d',{alpha:true});
  let W=0,H=0;
  function resize(){
    const r=wrap.getBoundingClientRect();
    const dpr=Math.min(2,window.devicePixelRatio||1);
    canvas.width=Math.floor(r.width*dpr);
    canvas.height=Math.floor(r.height*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    W=r.width; H=r.height;
  }

  const $hudChapter=document.getElementById('hudChapter');
  const $hudStage=document.getElementById('hudStage');
  const $hudWave=document.getElementById('hudWave');
  const $hudCoins=document.getElementById('hudCoins');
  const $hudShield=document.getElementById('hudShield');
  const $hpFill=document.getElementById('hpFill');
  const $hpNum=document.getElementById('hpNum');
  const $toast=document.getElementById('toast');

  const overlay=document.getElementById('overlay');
  const opts=document.getElementById('opts');
  const $panelTitle=document.getElementById('panelTitle');
  const $panelSub=document.getElementById('panelSub');
  const $panelRow=document.getElementById('panelRow');
  const $panel=document.getElementById('panel');

  const $btnShop=document.getElementById('btnShop');
  const $btnPause=document.getElementById('btnPause');

  const $btnBurst=document.getElementById('btnBurst');
  const $btnInvuln=document.getElementById('btnInvuln');
  const $cdBurst=document.getElementById('cdBurst');
  const $cdInvuln=document.getElementById('cdInvuln');

  const $btnAI=document.getElementById('btnAI');
  const $aiState=document.getElementById('aiState');

  const rand=(a,b)=>a+Math.random()*(b-a);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const dist2=(ax,ay,bx,by)=>{const dx=ax-bx,dy=ay-by;return dx*dx+dy*dy};

  // Touchpad
  const pad=document.getElementById('touchpad'), thumb=document.getElementById('thumb');
  let padActive=false, padX=.5;
  function setPadX(nx){
    padX=clamp(nx,0,1);
    thumb.style.left=`${padX*100}%`;
    player.x=lerp(player.x,padX*W,1);
  }
  function pointerToPadX(e){const r=pad.getBoundingClientRect();return (e.clientX-r.left)/r.width}
  pad.addEventListener('pointerdown',e=>{e.preventDefault();pad.setPointerCapture(e.pointerId);padActive=true;setPadX(pointerToPadX(e))});
  pad.addEventListener('pointermove',e=>{if(!padActive)return;e.preventDefault();setPadX(pointerToPadX(e))});
  pad.addEventListener('pointerup',e=>{padActive=false;try{pad.releasePointerCapture(e.pointerId)}catch(_){}});pad.addEventListener('pointercancel',()=>padActive=false);

  // ===== Core tuning (bounded growth) =====
  const BASE_HP=300;

  // player caps (prevents "573 stage god mode")
  const CAP = {
    dmg: 2500,
    fireRate: 14.0,
    bulletSpeed: 1200,
    spreadCap: 12,
    pierce: 6,
    shieldMax: 240,
    regen: 10
  };

  const state = {
    stage: 1, // 1..100
    wave: 1,  // 1..5
    wavesPerStage: 5,
    coins: 0,
    score: 0,
    // per-stage shop purchase throttles
    shopBuysThisStage: 0,
    shopBuysCap: 3, // <= this, avoids infinite compounding
  };

  const player={
    x:0,y:0,r:14,
    hp:BASE_HP,hpMax:BASE_HP,
    dmg:30, fireRate:6.2, bulletSpeed:820,
    spread_perm:0, spreadCap:5,
    pierce_perm:2,
    shield:0, shieldMax:0,
    regen:0,
  };

  const buffs={ invulnT:0, burstT:0 };
  const skills={ burst:{cd:0}, invuln:{cd:0} };
  let hitIFrameT = 0;

  // entities
  let pBullets=[], eBullets=[], enemies=[], particles=[], drops=[];
  let fireAcc=0;

  // boss/elite templates
  function chapterOf(stage){ return Math.ceil(stage/10); }
  function subOf(stage){ return ((stage-1)%10)+1; }

  // Chapter modifiers (keeps variety without "new game" rewrite)
  function chapterMod(ch){
    // ch 1..10
    // Return: bulletSpeedMul, enemyHpMul, coinBonus, affix flags
    const mods = [
      {name:'é–‹å±€æš–èº«',  hp:0.90, bs:0.95, coin:1.00, jam:0, split:0},
      {name:'æ•£å°„å£“åŠ›',  hp:1.00, bs:1.00, coin:1.00, jam:0, split:0},
      {name:'ç‹™æ“Šå£“åŠ›',  hp:1.05, bs:1.05, coin:1.05, jam:0, split:0},
      {name:'ç²¾è‹±æ½®',    hp:1.08, bs:1.08, coin:1.10, jam:0, split:0},
      {name:'å¹²æ“¾ç« ',    hp:1.10, bs:1.10, coin:1.10, jam:1, split:0},
      {name:'ç¢è£‚ç« ',    hp:1.12, bs:1.12, coin:1.12, jam:0, split:1},
      {name:'æ··åˆå£“åŠ›',  hp:1.15, bs:1.15, coin:1.15, jam:1, split:1},
      {name:'é«˜é¢¨éšªé«˜å ±é…¬',hp:1.18, bs:1.18, coin:1.25, jam:1, split:0},
      {name:'æœ€çµ‚å‰å“¨',  hp:1.22, bs:1.22, coin:1.20, jam:0, split:1},
      {name:'Final',     hp:1.28, bs:1.28, coin:1.30, jam:1, split:1},
    ];
    return mods[clamp(ch,1,10)-1];
  }

  function stageDifficultyMul(stage){
    // bounded: 1..100, smooth but not runaway
    const t = clamp((stage-1)/99, 0, 1);
    // 1.0 -> ~2.2
    return 1 + 1.2*t + 0.25*t*t;
  }

  // ===== Shooting & collisions =====
  function spreadTotal(){ return player.spread_perm; }
  function shotsFromSpread(s){ return Math.max(1, 1 + Math.floor(s)); }

  function spreadDmgMul(n){
    if(n<=1) return 1;
    return clamp(1 / (1 + 0.22*(n-1)), 0.30, 1.0);
  }
  function shotVXPattern(n){
    if(n<=1) return [0];
    const pairs = Math.floor(n/2);
    const hasCenter = (n%2===1);
    const maxV = 260;
    const gamma = 1.6;
    const arr=[];
    if(hasCenter) arr.push(0);
    for(let k=1;k<=pairs;k++){
      const t=k/pairs;
      const mag=Math.pow(t,gamma)*maxV;
      arr.push(-mag,+mag);
    }
    return arr;
  }

  function shoot(dt){
    fireAcc += dt * player.fireRate;
    while(fireAcc >= 1){
      fireAcc -= 1;
      spawnPlayerShot();
    }
  }
  function spawnPlayerShot(){
    const n = shotsFromSpread(spreadTotal());
    const burstMul = (buffs.burstT>0)? 2.0 : 1.0;
    const dmg = player.dmg * spreadDmgMul(n) * burstMul;

    const vxArr = shotVXPattern(n);
    const baseY = player.y - player.r - 6;
    for(const vx of vxArr){
      pBullets.push({x:player.x,y:baseY,r:4,vx,vy:-player.bulletSpeed,dmg,pierce:player.pierce_perm,alive:true});
    }
  }

  function enemyShoot(e, ang, meta={}){
    const spd = (e.bulletSpeed||300) * (meta.spdMul||1);
    const r = meta.r ?? 4;
    eBullets.push({x:e.x,y:e.y+e.r+4,r,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,dmg:(e.bulletDmg||8)*(meta.dmgMul||1),alive:true, beam:!!meta.beam, len:meta.len||0});
  }

  // ===== Spawns =====
  function enemyHoldY(){return clamp(H*.18,110,190)}
  function waveConfig(stage,wave){
    const ch = chapterOf(stage);
    const mod = chapterMod(ch);
    const mul = stageDifficultyMul(stage) * mod.hp;

    const baseCount = 7 + Math.floor((stage-1)*0.25) + Math.floor((wave-1)*1.0);
    const count = clamp(baseCount, 8, 22);

    const hp = (26 + stage*5 + wave*6) * mul;
    const fire = clamp(0.55 + stage*0.020 + wave*0.070, 0.65, 1.35);
    const bulletSpeed = (120 + stage*3.2 + wave*4.0) * (1 + 0.25*mod.bs);
    const dmg = (5.8 + stage*0.22 + wave*0.42);

    // elite chance peaks midgame but bounded
    const eliteChance = clamp(0.10 + (stage/100)*0.55 + (wave>=4?0.10:0), 0.10, 0.75);

    return {count,hp,fire,bulletSpeed,dmg,eliteChance, mod};
  }

  function spawnMob(x,y,targetY,cfg,meta={}){
    const elite = !!meta.elite;
    const r  = elite ? 18 : 15;
    const hp = cfg.hp * (elite? 2.2 : 1.0);
    const isStrafe = Math.random() < (elite?0.55:0.38);

    return {
      type: elite?'elite':'mob',
      x,y,targetY,r,
      hp,hpMax:hp,
      fireCd:rand(.35,1.15),
      fireRate: elite ? Math.min(cfg.fire*1.05, 1.45) : cfg.fire,
      bulletSpeed: cfg.bulletSpeed * (elite?1.08:1.00),
      bulletDmg: cfg.dmg * (elite?1.25:1.00),
      strafeAmp: isStrafe ? rand(55, elite?150:115) : 0,
      strafeSpd: isStrafe ? rand(.90, elite?2.40:1.90) : 0,
      strafePhase: rand(0,Math.PI*2),
      hitFlash:0
    };
  }

  function spawnMiniBoss(cfg){
    const holdY = enemyHoldY() - 6;
    const hp = cfg.hp * 7.0;
    return {
      type:'miniboss',
      x: W*0.5, y: -120, targetY: holdY, r: 26,
      hp, hpMax: hp,
      bulletSpeed: cfg.bulletSpeed * 1.25,
      bulletDmg: cfg.dmg * 2.0,
      fireRate: cfg.fire * 1.15,
      phase:1,
      hitFlash:0
    };
  }

  function spawnBoss(){
    // every stage 10: boss stage
    const stage = state.stage;
    const ch = chapterOf(stage);
    const mod = chapterMod(ch);
    const holdY = enemyHoldY() - 12;

    // rotate boss kind by chapter: 1..10
    const kind = (ch % 3 === 1) ? 'bullethell' : (ch % 3 === 2 ? 'sniper' : 'defender');

    const baseHp = (900 + stage*140) * stageDifficultyMul(stage) * mod.hp;
    const baseSpd= (190 + stage*2.7) * mod.bs;
    const baseDmg= (12 + stage*0.35) * (mod.bs*0.90 + 0.15);

    enemies.push({
      type:'boss', kind,
      x: W*0.5, y: -140, targetY: holdY, r: 32,
      hp: baseHp, hpMax: baseHp,
      bulletSpeed: baseSpd,
      bulletDmg: baseDmg,
      phase:1, hitFlash:0,
      // affix from chapter
      jam: !!mod.jam,
      split: !!mod.split,
      // timers
      t0: 0,
      ringCd: 0.9,
      spiralCd: 0.38,
      burstCd: 0.70,
      ballCd: 1.1,
      snipeT: 0.25
    });

    toastMsg(`ç« ç¯€ç‹ï¼š${kind.toUpperCase()}ï½œ${mod.name}`, 1.0);
  }

  function spawnWave(){
    enemies.length=0;
    eBullets.length=0;
    drops.length=0;

    const cfg = waveConfig(state.stage, state.wave);
    const holdY = enemyHoldY();
    const lanes = cfg.count;

    for(let i=0;i<lanes;i++){
      const x = (i+1)*(W/(lanes+1));
      const isElite = Math.random() < cfg.eliteChance;

      enemies.push(spawnMob(
        x, -40 - i*16,
        holdY + rand(-18,18),
        cfg,
        {elite:isElite}
      ));
    }

    // wave 5 = miniboss unless it's boss stage (sub 10)
    if(state.wave === state.wavesPerStage && subOf(state.stage) !== 10){
      enemies.push(spawnMiniBoss(cfg));
      toastMsg('Mini Boss å…¥å ´', 0.9);
    }

    // boss stage: sub 10, wave 5 spawns boss
    if(subOf(state.stage) === 10 && state.wave === state.wavesPerStage){
      spawnBoss();
    }
  }

  // ===== Drops & economy =====
  function coinRewardBase(stage, isBoss=false){
    const ch = chapterOf(stage);
    const mod = chapterMod(ch);
    const base = isBoss ? 220 : 18;
    const sMul = 1 + (stage/100)*1.2;
    return Math.floor(base * sMul * mod.coin);
  }

  function dropCoin(x,y,amt){
    drops.push({x,y,r:10,vy:rand(60,120),type:'coin',life:10,amt});
  }

  function maybeDrop(x,y,what){
    // run-based, bounded: drops are mild; shop is main progression
    if(Math.random() > 0.25) return;
    const pool = ['heal','shield','coin'];
    const t = pool[Math.floor(Math.random()*pool.length)];
    if(t==='coin') dropCoin(x,y,3);
    else drops.push({x,y,r:10,vy:rand(70,140),type:t,life:10});
  }

  function applyDrop(d){
    if(d.type==='heal'){
      player.hp = clamp(player.hp + 55, 0, player.hpMax);
    }else if(d.type==='shield'){
      player.shieldMax = Math.max(player.shieldMax, 60);
      player.shield = clamp(player.shield + 40, 0, player.shieldMax);
    }else if(d.type==='coin'){
      state.coins += Math.max(1, d.amt||1);
    }
  }

  // ===== Skills =====
  let BURST_DURATION = 12;
  let BURST_CD = 38;
  let INVULN_DURATION = 10;
  let INVULN_CD = 55;

  const SKILL_EPS=1e-6;
  function skillCdLeft(k){ return Math.max(0, (skills[k]?.cd || 0)); }
  function canUseSkill(k){
    if(mode!=='play' || paused) return false;
    if(k==='burst')  return (buffs.burstT <= SKILL_EPS)  && (skillCdLeft('burst') <= SKILL_EPS);
    if(k==='invuln') return (buffs.invulnT <= SKILL_EPS) && (skillCdLeft('invuln') <= SKILL_EPS);
    return (skillCdLeft(k) <= SKILL_EPS);
  }
  function useBurst(){
    if(!canUseSkill('burst')) return;
    skills.burst.cd = BURST_CD;
    buffs.burstT = Math.max(buffs.burstT, BURST_DURATION);
    toastMsg(`ğŸ”¥ çˆ†ç™¼ ${BURST_DURATION}s`,0.7);
  }
  function useInvuln(){
    if(!canUseSkill('invuln')) return;
    skills.invuln.cd = INVULN_CD;
    buffs.invulnT = Math.max(buffs.invulnT, INVULN_DURATION);
    toastMsg(`âœ¨ ç„¡æ•µ ${INVULN_DURATION}s`,0.7);
  }
  $btnBurst.addEventListener('click',useBurst);
  $btnInvuln.addEventListener('click',useInvuln);

  // ===== Shop (post-stage only) =====
  const shopState={
    spreadCapUp:0,
    dmgUp:0,
    fireRateUp:0,
    pierceUp:0,
    shieldCapUp:0,
    regenUp:0,
    burstTuned:0,
    invulnTuned:0,
    wingman:0,
    wingmanRate:0,
  };

  // wingman bounded
  let allyRockets=[], wingAcc=0;
  function wingmanActive(){ return shopState.wingman===1 || (AI.enabled===true); }
  function wingInterval(){
    const lvl = clamp(shopState.wingmanRate,0,5);
    return Math.max(0.55, 2.0 - lvl*0.25);
  }
  function pickRocketTarget(){
    if(!enemies.length) return null;
    let best=null, bestS=-1e18;
    for(const e of enemies){
      if(!e||e.hp<=0) continue;
      const s=(e.type==='boss'?1e6:0)+e.y*2 - Math.abs(e.x-player.x)*0.18;
      if(s>bestS){bestS=s;best=e}
    }
    return best;
  }
  function spawnRocket(fromX, fromY){
    const t=pickRocketTarget(); if(!t) return;
    const burstMul=(buffs.burstT>0)?2.0:1.0;
    allyRockets.push({x:fromX,y:fromY,vx:0,vy:-240,speed:520,turn:14,r:6,dmg:player.dmg*0.85*burstMul,target:t,life:5.0});
  }
  function wingmanTick(dt){
    if(!wingmanActive()) return;
    const itv=wingInterval();
    wingAcc+=dt;
    while(wingAcc>=itv){
      wingAcc-=itv;
      const offX=34, baseY=player.y-18;
      spawnRocket(clamp(player.x-offX,10,W-10),baseY);
      spawnRocket(clamp(player.x+offX,10,W-10),baseY);
    }
  }
  function updateRockets(dt){
    for(const r of allyRockets){
      r.life-=dt; if(r.life<=0){r.dead=true;continue;}
      if(!r.target || r.target.hp<=0) r.target=pickRocketTarget();
      if(!r.target){r.dead=true;continue;}
      const tx=r.target.x, ty=r.target.y;
      const dx=tx-r.x, dy=ty-r.y;
      const d=Math.hypot(dx,dy)||1;
      const ux=dx/d, uy=dy/d;
      const vlen=Math.hypot(r.vx,r.vy)||1;
      let vx=r.vx/vlen, vy=r.vy/vlen;
      const t=clamp(r.turn*dt,0,1);
      vx=(1-t)*vx+t*ux; vy=(1-t)*vy+t*uy;
      const nv=Math.hypot(vx,vy)||1; vx/=nv; vy/=nv;
      r.vx=vx*r.speed; r.vy=vy*r.speed;
      r.x+=r.vx*dt; r.y+=r.vy*dt;

      const hitRad=(r.r+(r.target.r||15)+4);
      if(dist2(r.x,r.y,tx,ty)<=hitRad*hitRad){
        r.dead=true;
        r.target.hp-=r.dmg;
        r.target.hitFlash=0.12;
        addBurst(r.x,r.y,10);
        if(r.target.hp<=0) killEnemy(r.target);
      }
      if(r.x<-80||r.x>W+80||r.y<-120||r.y>H+120) r.dead=true;
    }
    allyRockets=allyRockets.filter(x=>!x.dead);
  }

  function price(base, lvl, growth=1.45){ return Math.floor(base * Math.pow(growth, lvl)); }

  function shopItems(){
    const items=[];
    const stage = state.stage;
    const ch = chapterOf(stage);

    // stage budget: encourages "buy some, not all"
    // and avoids AI compounding forever
    const budgetCap = 2500 + ch*900 + Math.floor(stage*18);

    function canBuyCore(){
      if(mode!=='shop') return false;
      if(state.shopBuysThisStage >= state.shopBuysCap) return false;
      if(state.coins <= 0) return false;
      if(state.coins > budgetCap*3) return true; // don't hard lock, just guidance
      return true;
    }

    items.push({
      id:'dmgUp', name:'ç«åŠ› +15%', cost:price(180, shopState.dmgUp),
      desc:`æå‡å‚·å®³ï¼ˆç›®å‰ ${Math.floor(player.dmg)}ï¼‰`,
      canBuy:()=> canBuyCore() && shopState.dmgUp < 10 && player.dmg < CAP.dmg,
      buy:()=>{ shopState.dmgUp++; player.dmg = Math.min(CAP.dmg, player.dmg*1.15); }
    });

    items.push({
      id:'fireRateUp', name:'å°„é€Ÿ +12%', cost:price(180, shopState.fireRateUp),
      desc:`æå‡å°„é€Ÿï¼ˆç›®å‰ ${player.fireRate.toFixed(2)}/sï¼‰`,
      canBuy:()=> canBuyCore() && shopState.fireRateUp < 10 && player.fireRate < CAP.fireRate,
      buy:()=>{ shopState.fireRateUp++; player.fireRate = Math.min(CAP.fireRate, player.fireRate*1.12); }
    });

    items.push({
      id:'pierceUp', name:'ç©¿é€ +1', cost:price(220, shopState.pierceUp),
      desc:`æå‡ç©¿é€ï¼ˆç›®å‰ ${player.pierce_perm}ï¼‰`,
      canBuy:()=> canBuyCore() && shopState.pierceUp < 4 && player.pierce_perm < CAP.pierce,
      buy:()=>{ shopState.pierceUp++; player.pierce_perm = Math.min(CAP.pierce, player.pierce_perm+1); }
    });

    items.push({
      id:'spreadCapUp', name:'æ•£å°„ä¸Šé™ +1', cost:price(240, shopState.spreadCapUp),
      desc:`æå‡æ•£å°„ä¸Šé™ï¼ˆç›®å‰ ${player.spreadCap}ï¼‰`,
      canBuy:()=> canBuyCore() && shopState.spreadCapUp < 7 && player.spreadCap < CAP.spreadCap,
      buy:()=>{ shopState.spreadCapUp++; player.spreadCap = Math.min(CAP.spreadCap, player.spreadCap+1); }
    });

    items.push({
      id:'shieldCapUp', name:'è­·ç›¾ä¸Šé™ +30', cost:price(160, shopState.shieldCapUp),
      desc:`æå‡è­·ç›¾ä¸Šé™ä¸¦å›æ»¿ï¼ˆç›®å‰ ${Math.floor(player.shieldMax)}ï¼‰`,
      canBuy:()=> canBuyCore() && shopState.shieldCapUp < 6 && player.shieldMax < CAP.shieldMax,
      buy:()=>{
        shopState.shieldCapUp++;
        player.shieldMax = Math.min(CAP.shieldMax, player.shieldMax + 30);
        player.shield = player.shieldMax;
      }
    });

    items.push({
      id:'regenUp', name:'å›å¾© +2/s', cost:price(200, shopState.regenUp),
      desc:`æå‡è‡ªå‹•å›å¾©ï¼ˆç›®å‰ ${player.regen}/sï¼‰`,
      canBuy:()=> canBuyCore() && shopState.regenUp < 5 && player.regen < CAP.regen,
      buy:()=>{ shopState.regenUp++; player.regen = Math.min(CAP.regen, player.regen+2); }
    });

    // Skill tuning with diminishing returns (prevents invuln/burst perma uptime)
    items.push({
      id:'burstTuned', name:'çˆ†ç™¼èª¿æ ¡', cost:price(260, shopState.burstTuned),
      desc:`é™ä½çˆ†ç™¼ç©ºçª—ï¼ˆCD/æŒçºŒ ç›®å‰ ${BURST_CD}s / ${BURST_DURATION}sï¼‰`,
      canBuy:()=> canBuyCore() && shopState.burstTuned < 6,
      buy:()=>{
        shopState.burstTuned++;
        // diminishing: early strong, later weak
        const k = shopState.burstTuned;
        BURST_CD = Math.max(24, BURST_CD - (k<=3?2:1));
        BURST_DURATION = Math.min(16, BURST_DURATION + (k<=3?1:0.5));
        if(skills.burst.cd > BURST_CD) skills.burst.cd = BURST_CD;
      }
    });

    items.push({
      id:'invulnTuned', name:'ç„¡æ•µèª¿æ ¡', cost:price(320, shopState.invulnTuned),
      desc:`é™ä½ç„¡æ•µç©ºçª—ï¼ˆCD/æŒçºŒ ç›®å‰ ${INVULN_CD}s / ${INVULN_DURATION}sï¼‰`,
      canBuy:()=> canBuyCore() && shopState.invulnTuned < 6,
      buy:()=>{
        shopState.invulnTuned++;
        const k = shopState.invulnTuned;
        INVULN_CD = Math.max(34, INVULN_CD - (k<=3?3:1));
        INVULN_DURATION = Math.min(13, INVULN_DURATION + (k<=3?1:0.5));
        if(skills.invuln.cd > INVULN_CD) skills.invuln.cd = INVULN_CD;
      }
    });

    items.push({
      id:'wingman', name:'åƒšæ©Ÿç·¨éšŠ', cost:1500,
      desc:`å·¦å³å„ä¸€åƒšæ©Ÿï¼ˆè¿½è¹¤ç«ç®­ï¼‰`,
      canBuy:()=> canBuyCore() && shopState.wingman===0 && !(AI.enabled===true),
      buy:()=>{ shopState.wingman=1; toastMsg('ğŸ›°ï¸ åƒšæ©Ÿå°±ä½',0.7); }
    });

    if(shopState.wingman===1 || AI.enabled===true){
      items.push({
        id:'wingmanRate', name:'åƒšæ©ŸåŠ é€Ÿ -0.25s', cost:price(260, shopState.wingmanRate),
        desc:`åƒšæ©Ÿé–“éš”ç›®å‰ ${wingInterval().toFixed(2)}sï¼ˆæœ€å¤š 5 æ¬¡ï¼‰`,
        canBuy:()=> canBuyCore() && shopState.wingmanRate < 5,
        buy:()=>{ shopState.wingmanRate++; toastMsg(`ğŸ›°ï¸ åƒšæ©ŸåŠ é€Ÿï¼š${wingInterval().toFixed(2)}s`,0.6); }
      });
    }

    return items;
  }

  function renderShop(){
    overlay.classList.add('show');
    opts.innerHTML='';
    $panelRow.innerHTML='';
    $panelTitle.textContent='å•†åº—ï¼ˆæœ¬é—œçµç®—ï¼‰';

    const ch = chapterOf(state.stage), sub = subOf(state.stage);
    const mod = chapterMod(ch);
    $panelSub.innerHTML =
      `CH ${ch}-${sub}ï½œ${mod.name}<br>` +
      `é‡‘å¹£ï¼š<b>${state.coins}</b>ã€€ï¼ˆæœ¬é—œè³¼è²·ï¼š${state.shopBuysThisStage}/${state.shopBuysCap}ï¼‰<br>` +
      `æç¤ºï¼šä½ ä¸éœ€è¦è²·æ»¿ï¼Œè²·å°å°±è¡Œï¼ˆæˆ‘å€‘ä¸æ˜¯åœ¨è·‘ç„¡é™è¤‡åˆ©ï¼‰`;

    const items=shopItems();
    for(const it of items){
      const affordable = state.coins >= it.cost;
      const allowed = it.canBuy ? it.canBuy() : true;
      const canBuy = affordable && allowed;

      const el=document.createElement('div');
      el.className='opt';
      el.innerHTML =
        `<div class="t">${it.name} <span style="opacity:.8">ï¼ˆğŸª™${it.cost}ï¼‰</span></div>`+
        `<div class="d">${it.desc}${allowed?'':'<br><span style="opacity:.7">ï¼ˆå·²é”ä¸Šé™ï¼æœ¬é—œè³¼è²·é”ä¸Šé™ï¼AIå·²è‡ªå¸¶ï¼‰</span>'}</div>`;

      if(!canBuy){
        el.style.opacity='0.55';
        el.style.cursor='default';
      }else{
        el.addEventListener('click',()=>{
          if(mode!=='shop' || !paused) return;
          if(state.coins < it.cost) return;
          if(it.canBuy && !it.canBuy()) return;
          state.coins -= it.cost;
          state.shopBuysThisStage++;
          try{ it.buy && it.buy(); }catch(_){}
          renderShop();
        });
      }
      opts.appendChild(el);
    }

    const btnClose=document.createElement('button');
    btnClose.className='pill';
    btnClose.textContent='ç¹¼çºŒ';
    btnClose.addEventListener('click',closeShop);
    $panelRow.appendChild(btnClose);
  }

  function openShop(force=false){
    if(!force){
      // only allow after stage clear
      if(mode!=='post') return;
    }
    mode='shop';
    paused=true;
    $toast.classList.remove('show');
    renderShop();
  }
  function closeShop(){
    overlay.classList.remove('show');
    mode='play';
    paused=false;
    lastT=performance.now();
  }

  $btnShop.addEventListener('click',()=>{
    if(mode==='shop') closeShop();
    else if(mode==='post') openShop(true);
    else toastMsg('å•†åº—åªåœ¨éé—œå¾Œé–‹æ”¾', 0.7);
  });

  // ===== Damage, kill, scoring =====
  function addBurst(x,y,n=10){
    for(let i=0;i<n;i++) particles.push({x,y,vx:rand(-220,220),vy:rand(-220,220),life:rand(.25,.55)});
  }

  function damagePlayer(dmg){
    if(buffs.invulnT>0) return;
    if(hitIFrameT > 0) return;

    if(player.shield>0){
      const use=Math.min(player.shield,dmg);
      player.shield-=use; dmg-=use;
    }
    if(dmg>0) player.hp=Math.max(0,player.hp-dmg);

    hitIFrameT = 0.32;
    if(player.hp<=0) gameOver();
  }

  function enemyCoinValue(e){
    if(e.type==='boss') return coinRewardBase(state.stage,true);
    if(e.type==='miniboss') return Math.floor(coinRewardBase(state.stage,false)*3.0);
    if(e.type==='elite') return Math.floor(coinRewardBase(state.stage,false)*1.6);
    return coinRewardBase(state.stage,false);
  }

  function killEnemy(e){
    // coins & score
    const c = enemyCoinValue(e);
    dropCoin(e.x,e.y, Math.max(1, Math.floor(c/22)));
    state.coins += Math.floor(c/10); // immediate wallet growth is bounded

    if(e.type==='boss') state.score += 800;
    else if(e.type==='miniboss') state.score += 220;
    else if(e.type==='elite') state.score += 65;
    else state.score += 20;

    maybeDrop(e.x,e.y,e.type);
    addBurst(e.x,e.y, e.type==='boss'?26:12);
    e.hp = 0;
  }

  // ===== Boss behaviors (varied by kind + chapter affix) =====
  function bossTick(b,dt){
    b.t0 += dt;

    // phase based on HP
    const rr=b.hp/b.hpMax;
    const newPhase=(rr<=.40)?3:(rr<=.70?2:1);
    if(newPhase!==b.phase){
      b.phase=newPhase;
      toastMsg(`Boss Phase ${b.phase}`,0.6);
    }

    // Chapter affix: JAM = slows skill cooldown recovery a bit (anti-perma)
    // We'll implement JAM in update() by scaling skill cd tick; here we just use b.jam flag.
    // Chapter affix: SPLIT = bullets split on clear (implemented in bullet collision for eBullets).

    if(b.kind==='defender'){
      b.x = W*0.5;
      b.ballCd -= dt;
      const period = (b.phase===1?1.2:(b.phase===2?1.0:0.85));
      if(b.ballCd<=0){
        const aim=Math.atan2(player.y-b.y,player.x-b.x);
        const ang=aim+rand(-0.45,0.45);
        const spd= 210 + state.stage*1.8;
        eBullets.push({ball:true, alive:true, x:b.x, y:b.y+b.r+10, r:18, vx:Math.cos(ang)*spd, vy:Math.sin(ang)*spd, dmg:18+state.stage*0.18, hitCd:0});
        b.ballCd=period;
      }
      return;
    }

    if(b.kind==='sniper'){
      b.x = W*0.5;
      const base = (b.phase===1?0.070:(b.phase===2?0.055:0.045));
      b.snipeT -= dt;
      while(b.snipeT<=0){
        const ang=Math.atan2(player.y-b.y,player.x-b.x);
        enemyShoot(b, ang, {beam:true, len:(b.phase===3?48:42), r:(b.phase===3?7:6), spdMul:2.0, dmgMul:1.10});
        b.snipeT += base;
        break;
      }
      return;
    }

    // bullethell
    b.burstCd -= dt;
    if(b.burstCd<=0){
      const ang=Math.atan2(player.y-b.y,player.x-b.x);
      const lanes = (b.phase===1?5:(b.phase===2?6:7));
      const spread = (b.phase===1?0.22:(b.phase===2?0.26:0.30));
      for(let i=0;i<lanes;i++){
        const t=(i-(lanes-1)/2)/(((lanes-1)/2)||1);
        enemyShoot(b, ang+t*spread, {spdMul:1.05, dmgMul:0.95});
      }
      b.burstCd = (b.phase===1?0.85:(b.phase===2?0.65:0.52));
    }

    b.ringCd -= dt;
    if(b.ringCd<=0){
      const n=(b.phase===1?14:(b.phase===2?18:24));
      const base=Math.random()*Math.PI*2;
      for(let i=0;i<n;i++){
        const a=base+(i/n)*Math.PI*2;
        enemyShoot(b,a,{spdMul:0.95,dmgMul:0.80});
      }
      b.ringCd=(b.phase===1?1.15:(b.phase===2?0.90:0.70));
    }
  }

  // ===== AI (simple, bounded; not "never die") =====
  const AI = {
    enabled:false,
    toggle(on){
      this.enabled = (on==null) ? !this.enabled : !!on;
      $aiState.textContent = this.enabled ? 'ON' : 'OFF';
      $btnAI.setAttribute('aria-pressed', this.enabled ? 'true' : 'false');
    },
    tick(dt){
      if(!this.enabled) return;
      if(mode!=='play' || paused) return;

      // basic: pick safest x by sampling + avoid imminent bullets
      const samples=19;
      let bestX=player.x, bestS=-1e18;
      const py=player.y;

      for(let i=0;i<samples;i++){
        const x = (i/(samples-1))*W;
        const safeL=player.r+8, safeR=W-player.r-8;
        const xx=clamp(x,safeL,safeR);

        let score=0;
        // keep near mid to reduce corner cheese
        score -= Math.abs(xx - W*0.5)*0.08;

        // bullet avoidance
        for(const b of eBullets){
          if(!b.alive) continue;
          if(b.beam) continue;
          if(b.ball){
            const d=dist2(xx,py,b.x,b.y);
            if(d < (player.r+b.r+12)**2) score -= 5e6;
            continue;
          }
          const vy=b.vy||0;
          if(vy<=1) continue;
          const tHit=(py-b.y)/vy;
          if(tHit<0 || tHit>0.9) continue;
          const xHit=b.x + (b.vx||0)*tHit;
          const rad=(b.r||4)+player.r+8;
          const d=Math.abs(xHit-xx);
          score -= (d<rad)? (3e6*(1/(0.1+tHit))) : (4000/(d+6));
        }

        // aim alignment (mild)
        let target=null;
        for(const e of enemies){ if(!target || e.y > target.y) target=e; }
        if(target) score -= Math.abs(xx - target.x)*0.20;

        if(score>bestS){bestS=score;bestX=xx;}
      }

      const maxStep = 520*dt;
      const dx=clamp(bestX-player.x, -maxStep, maxStep);
      setPadX((player.x+dx)/W);

      // defensive skill usage (not perfect, so it can still die)
      const danger = bestS < -1.2e6;
      if(danger && canUseSkill('invuln')) useInvuln();
      if(enemies.some(e=>e.type==='boss') && canUseSkill('burst') && bestS>-9e5) useBurst();
    }
  };
  $btnAI.addEventListener('click',()=>AI.toggle());

  // ===== Game modes & flow =====
  let mode='play'; // play | post | shop | gameover | win
  let paused=false;
  let lastT=performance.now();

  function toastMsg(text,sec=.75){
    $toast.textContent=text;
    $toast.classList.add('show');
    toastT=sec;
  }
  let toastT=0;

  function stageClear(){
    // stage clear checkpoint
    mode='post';
    paused=true;
    state.shopBuysThisStage = 0;

    // chapter clear bonus
    const ch=chapterOf(state.stage), sub=subOf(state.stage);
    if(sub===10){
      const bonus = 900 + ch*500;
      state.coins += bonus;
      toastMsg(`ç« ç¯€å®Œæˆ +ğŸª™${bonus}`, 1.0);
    }else{
      const bonus = 160 + ch*70;
      state.coins += bonus;
      toastMsg(`éé—œçå‹µ +ğŸª™${bonus}`, 0.85);
    }

    // auto-open shop (you can disable if you want)
    openShop(true);
  }

  function nextStage(){
    if(state.stage >= 100){
      winGame();
      return;
    }
    state.stage++;
    state.wave=1;
    state.shopBuysThisStage=0;
    enemies.length=0; eBullets.length=0; pBullets.length=0; drops.length=0; particles.length=0;
    spawnWave();
    mode='play';
    paused=false;
    lastT=performance.now();
  }

  function nextWave(){
    state.wave++;
    enemies.length=0; eBullets.length=0; pBullets.length=0; drops.length=0; particles.length=0;
    spawnWave();
  }

  function gameOver(){
    mode='gameover';
    paused=true;
    overlay.classList.add('show');
    opts.innerHTML=''; $panelRow.innerHTML='';
    $panelTitle.textContent='Game Over';
    $panelSub.innerHTML=`åˆ†æ•¸ï¼š<b>${state.score}</b><br>é—œå¡ï¼š<b>${state.stage}</b>ã€€æ³¢æ¬¡ï¼š<b>${state.wave}</b><br>é‡‘å¹£ï¼š<b>${state.coins}</b><br><span style="opacity:.8">ä½ æ›äº†ï¼Œä»£è¡¨å¹³è¡¡é–‹å§‹è®Šå¾—åƒç”¢å“è€Œä¸æ˜¯æ°¸å‹•æ©Ÿï¼ˆè®šï¼‰ã€‚</span>`;
    const btn=document.createElement('button');
    btn.className='pill'; btn.textContent='é‡æ–°é–‹å§‹';
    btn.addEventListener('click',()=>{ overlay.classList.remove('show'); resetRun(); });
    $panelRow.appendChild(btn);
  }

  function winGame(){
    mode='win';
    paused=true;
    overlay.classList.add('show');
    opts.innerHTML=''; $panelRow.innerHTML='';
    $panelTitle.textContent='Victory ğŸ‰';
    $panelSub.innerHTML=`ç ´é—œå®Œæˆï¼š<b>100 é—œ</b><br>åˆ†æ•¸ï¼š<b>${state.score}</b><br>é‡‘å¹£ï¼š<b>${state.coins}</b><br><span style="opacity:.8">æ­å–œï¼Œä½ çš„éŠæˆ²çµ‚æ–¼æœ‰çµ‚é»ï¼Œä¸å†æ˜¯ AI çš„å£“åŠ›æ¸¬è©¦å¹³å°ã€‚</span>`;
    const btn=document.createElement('button');
    btn.className='pill'; btn.textContent='é‡æ–°é–‹å§‹';
    btn.addEventListener('click',()=>{ overlay.classList.remove('show'); resetRun(); });
    $panelRow.appendChild(btn);
  }

  function resetRun(){
    state.stage=1; state.wave=1; state.coins=0; state.score=0;
    state.shopBuysThisStage=0;

    player.hpMax=BASE_HP; player.hp=BASE_HP;
    player.dmg=30; player.fireRate=6.2; player.bulletSpeed=820;
    player.spread_perm=0; player.spreadCap=5;
    player.pierce_perm=2;
    player.shield=0; player.shieldMax=0;
    player.regen=0;

    for(const k in shopState) shopState[k]=0;
    BURST_DURATION=12; BURST_CD=38;
    INVULN_DURATION=10; INVULN_CD=55;
    buffs.invulnT=0; buffs.burstT=0;
    skills.burst.cd=0; skills.invuln.cd=0;
    hitIFrameT=0;

    allyRockets=[]; wingAcc=0;
    pBullets=[]; eBullets=[]; enemies=[]; drops=[]; particles=[];
    mode='play'; paused=false;
    spawnWave();
    lastT=performance.now();
  }

  // Pause & post-stage
  $btnPause.addEventListener('click',()=>{
    if(mode!=='play'){ toastMsg('ç›®å‰ä¸æ˜¯æˆ°é¬¥ä¸­',0.7); return; }
    paused=!paused;
    $toast.textContent = paused ? 'Paused' : '';
    if(paused) $toast.classList.add('show'); else $toast.classList.remove('show');
    lastT=performance.now();
  });

  // ===== Update loop =====
  function update(dt){
    // regen and timers
    if(player.regen>0 && player.hp>0) player.hp=clamp(player.hp+player.regen*dt,0,player.hpMax);
    if(hitIFrameT>0) hitIFrameT=Math.max(0, hitIFrameT-dt);

    // Chapter JAM affix: if boss has jam, slow down skill cooldown recovery
    let cdMul = 1.0;
    const boss = enemies.find(e=>e.type==='boss');
    if(boss && boss.jam) cdMul = 0.80;

    for(const k of ['invulnT','burstT']){
      if(buffs[k]>0) buffs[k]=Math.max(0,buffs[k]-dt);
    }
    for(const k in skills){
      if(skills[k].cd>0) skills[k].cd=Math.max(0, skills[k].cd - dt*cdMul);
    }

    player.y=H-42;
    AI.tick(dt);

    player.x=clamp(player.x,player.r+8,W-player.r-8);

    // wingman
    wingmanTick(dt);
    updateRockets(dt);

    // shooting
    shoot(dt);

    // move enemies + shoot
    for(const e of enemies){
      e.y=lerp(e.y,e.targetY,clamp(dt*2.6,0,1));
      if(e.strafeAmp>0){
        e.strafePhase+=dt*e.strafeSpd;
        const ox=Math.sin(e.strafePhase)*e.strafeAmp;
        if(e.type==='boss' || e.type==='miniboss') e.x=W*0.5+ox;
        else { if(e.baseX==null)e.baseX=e.x; e.x=e.baseX+ox; }
      }
      e.x=clamp(e.x,e.r+10,W-e.r-10);

      if(e.type==='boss') bossTick(e,dt);
      else if(e.type==='miniboss'){
        e.fireCd = (e.fireCd||0) - dt;
        if(e.fireCd<=0){
          const ang=Math.atan2(player.y-e.y,player.x-e.x);
          const lanes = 3;
          const spread = 0.18;
          for(let i=0;i<lanes;i++){
            const t=(i-(lanes-1)/2)/(((lanes-1)/2)||1);
            enemyShoot(e, ang+t*spread, {spdMul:1.05, dmgMul:0.95, r:5});
          }
          e.fireCd = 1/Math.max(0.9, e.fireRate||1.0);
        }
      }else{
        e.fireCd-=dt;
        if(e.fireCd<=0){
          const ang=Math.atan2(player.y-e.y,player.x-e.x);
          const isElite=(e.type==='elite');
          if(isElite && Math.random()<0.35){
            for(const da of [-0.12,0.12]) enemyShoot(e, ang+da, {spdMul:1.05, dmgMul:0.95});
          }else{
            enemyShoot(e, ang, {spdMul:1.0, dmgMul:1.0});
          }
          e.fireCd=1/Math.max(0.7, e.fireRate);
        }
      }
      if(e.hitFlash>0) e.hitFlash=Math.max(0, e.hitFlash-dt);
    }

    // move bullets
    for(const b of pBullets){
      b.x+=b.vx*dt; b.y+=b.vy*dt;
      if(b.y<-30||b.x<-40||b.x>W+40) b.alive=false;
    }
    for(const b of eBullets){
      b.x+=b.vx*dt; b.y+=b.vy*dt;
      if(b.ball){
        if(b.hitCd>0) b.hitCd=Math.max(0,b.hitCd-dt);
        // bounce
        const L=b.r+6, R=W-b.r-6, T=b.r+6, B=H-b.r-6;
        if(b.x<L){b.x=L; b.vx=Math.abs(b.vx)*0.95; b.vy*=0.95;}
        if(b.x>R){b.x=R; b.vx=-Math.abs(b.vx)*0.95; b.vy*=0.95;}
        if(b.y<T){b.y=T; b.vy=Math.abs(b.vy)*0.95; b.vx*=0.95;}
        if(b.y>B){b.y=B; b.vy=-Math.abs(b.vy)*0.95; b.vx*=0.95;}
        continue;
      }
      if(b.y>H+50||b.x<-60||b.x>W+60) b.alive=false;
    }

    // drops
    for(const d of drops){
      d.y+=d.vy*dt; d.life-=dt;
      if(d.y>H+60||d.life<=0) d.dead=true;
      if(dist2(d.x,d.y,player.x,player.y)<(d.r+player.r+8)**2){
        d.dead=true;
        applyDrop(d);
      }
    }

    // particles
    for(const p of particles){
      p.x+=p.vx*dt; p.y+=p.vy*dt;
      p.vx*=(1-dt*2.8); p.vy*=(1-dt*2.8);
      p.life-=dt; if(p.life<=0) p.dead=true;
    }

    // collisions: player bullets vs enemies
    for(const b of pBullets){
      if(!b.alive) continue;
      for(const e of enemies){
        if(e.hp<=0) continue;
        if(dist2(b.x,b.y,e.x,e.y)<(b.r+e.r)**2){
          e.hp-=b.dmg; e.hitFlash=.12;
          addBurst(b.x,b.y,4);
          if(b.pierce<=0) b.alive=false; else b.pierce-=1;
          if(e.hp<=0) killEnemy(e);
          break;
        }
      }
    }

    // collisions: enemy bullets vs player (beams simplified)
    for(const eb of eBullets){
      if(!eb.alive) continue;

      if(eb.beam){
        // simple hit: treat beam as fat bullet (cheap but ok)
        if(dist2(eb.x,eb.y,player.x,player.y) < (player.r + (eb.r||6) + 6)**2){
          eb.alive=false;
          damagePlayer(eb.dmg);
          addBurst(player.x,player.y,10);
        }
        continue;
      }

      if(eb.ball){
        if(dist2(eb.x,eb.y,player.x,player.y)<(eb.r+player.r)**2){
          if((eb.hitCd||0)<=0){
            damagePlayer(eb.dmg);
            eb.hitCd=0.25;
            addBurst(player.x,player.y,10);
          }
        }
        continue;
      }

      if(dist2(eb.x,eb.y,player.x,player.y)<(eb.r+player.r)**2){
        eb.alive=false;
        damagePlayer(eb.dmg);
        addBurst(player.x,player.y,10);
      }
    }

    // SPLIT affix: when boss has split, clearing a bullet emits 2 tiny fragments
    // We'll implement a cheap variant: random fragments spawn over time when boss exists
    if(boss && boss.split && Math.random()<dt*0.65){
      // spawn 2 fragments near boss aimed roughly downwards
      const a=Math.atan2(player.y-boss.y, player.x-boss.x);
      for(const da of [-0.25,0.25]){
        const spd= (boss.bulletSpeed||240)*1.1;
        eBullets.push({x:boss.x,y:boss.y+boss.r+6,r:3,vx:Math.cos(a+da)*spd,vy:Math.sin(a+da)*spd,dmg:(boss.bulletDmg||12)*0.55,alive:true});
      }
    }

    // cleanup
    pBullets=pBullets.filter(b=>b.alive);
    eBullets=eBullets.filter(b=>b.alive);
    enemies=enemies.filter(e=>e.hp>0);
    drops=drops.filter(d=>!d.dead);
    particles=particles.filter(p=>!p.dead);

    // win/flow: wave clear
    if(enemies.length===0){
      if(state.wave < state.wavesPerStage){
        nextWave();
      }else{
        // stage completed
        stageClear();
      }
    }
  }

  // ===== Draw =====
  function draw(){
    ctx.clearRect(0,0,W,H);

    // subtle grid
    ctx.save();ctx.globalAlpha=.10;ctx.strokeStyle='#e7eefc';
    const step=48;
    for(let x=0;x<=W;x+=step){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,H);ctx.stroke()}
    for(let y=0;y<=H;y+=step){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(W,y);ctx.stroke()}
    ctx.restore();

    // particles
    ctx.save();ctx.fillStyle='rgba(120,255,200,.7)';
    for(const p of particles){ctx.globalAlpha=clamp(p.life*2.0,0,1);ctx.beginPath();ctx.arc(p.x,p.y,2.2,0,Math.PI*2);ctx.fill()}
    ctx.restore();

    // drops
    for(const d of drops){
      ctx.save();
      ctx.fillStyle='rgba(255,255,255,.08)';ctx.strokeStyle='rgba(255,255,255,.18)';ctx.lineWidth=1;
      ctx.beginPath();ctx.arc(d.x,d.y,d.r,0,Math.PI*2);ctx.fill();ctx.stroke();
      ctx.globalAlpha=.9;ctx.fillStyle='rgba(120,255,200,.95)';ctx.font='12px system-ui,"Noto Sans TC"';
      ctx.textAlign='center';ctx.textBaseline='middle';
      const icon = d.type==='heal'?'âœš':(d.type==='shield'?'ğŸ›¡':'ğŸª™');
      ctx.fillText(icon,d.x,d.y+.5);
      ctx.restore();
    }

    // rockets
    ctx.save();ctx.fillStyle='rgba(255,220,140,.95)';
    for(const r of allyRockets){
      ctx.beginPath();ctx.arc(r.x,r.y,r.r,0,Math.PI*2);ctx.fill();
      ctx.globalAlpha=.45;
      ctx.beginPath();ctx.arc(r.x - (r.vx*0.012), r.y - (r.vy*0.012), r.r*0.65, 0, Math.PI*2);ctx.fill();
      ctx.globalAlpha=1;
    }
    ctx.restore();

    // enemies
    for(const e of enemies){
      ctx.save();
      const isBoss=(e.type==='boss');
      const isMini=(e.type==='miniboss');
      const isElite=(e.type==='elite');
      const flash=e.hitFlash>0;
      ctx.fillStyle = flash ? 'rgba(255,255,255,.18)'
        : isBoss ? 'rgba(255,120,120,.14)'
        : isMini ? 'rgba(220,180,255,.14)'
        : isElite? 'rgba(220,180,255,.12)'
        : 'rgba(255,255,255,.10)';
      ctx.strokeStyle = isBoss?'rgba(255,120,120,.35)'
        : isMini?'rgba(220,180,255,.45)'
        : isElite?'rgba(220,180,255,.35)'
        : 'rgba(255,255,255,.20)';
      ctx.lineWidth = isBoss?2:(isMini?1.8:1);
      ctx.beginPath();ctx.arc(e.x,e.y,e.r,0,Math.PI*2);ctx.fill();ctx.stroke();

      // HP bar
      const w=isBoss?110:(isMini?92:(isElite?70:52)),h=6,x=e.x-w/2,y=e.y-e.r-14;
      ctx.globalAlpha=.9;ctx.fillStyle='rgba(255,255,255,.10)';ctx.fillRect(x,y,w,h);
      const hpPct=clamp(e.hp/e.hpMax,0,1);
      ctx.fillStyle=isBoss?'rgba(255,120,120,.9)':(isMini?'rgba(220,180,255,.9)':'rgba(120,255,200,.9)');
      ctx.fillRect(x,y,w*hpPct,h);

      if(isBoss){
        ctx.globalAlpha=.85;ctx.fillStyle='rgba(255,255,255,.70)';
        ctx.font='11px system-ui,"Noto Sans TC"';ctx.textAlign='center';ctx.textBaseline='bottom';
        ctx.fillText(`${e.kind.toUpperCase()} P${e.phase||1}${e.jam?' Â·JAM':''}${e.split?' Â·SPLIT':''}`,e.x,y-2);
      }
      ctx.restore();
    }

    // bullets
    ctx.save();ctx.fillStyle='rgba(120,255,200,.95)';
    for(const b of pBullets){ctx.beginPath();ctx.arc(b.x,b.y,4,0,Math.PI*2);ctx.fill()}
    ctx.restore();

    ctx.save();ctx.fillStyle='rgba(255,160,160,.92)';
    for(const b of eBullets){
      if(b.ball){
        ctx.beginPath();ctx.arc(b.x,b.y,b.r,0,Math.PI*2);ctx.fill();
      }else{
        ctx.beginPath();ctx.arc(b.x,b.y,b.r||4,0,Math.PI*2);ctx.fill();
      }
    }
    ctx.restore();

    // player
    ctx.save();
    ctx.translate(player.x,player.y);
    if(hitIFrameT>0) ctx.globalAlpha = 0.55 + 0.35*Math.sin(performance.now()/70);

    if(buffs.burstT>0){
      ctx.save();
      const a = 0.25 + 0.15*Math.sin(performance.now()/90);
      ctx.globalAlpha = a;
      ctx.strokeStyle = 'rgba(255,140,140,.85)';
      ctx.lineWidth = 3;
      ctx.beginPath();ctx.arc(0,0,player.r+18,0,Math.PI*2);ctx.stroke();
      ctx.restore();
    }

    ctx.fillStyle='rgba(255,255,255,.10)';ctx.strokeStyle='rgba(255,255,255,.22)';ctx.lineWidth=1.5;
    ctx.beginPath();
    ctx.moveTo(0,-player.r-2);ctx.lineTo(player.r+2,player.r+4);ctx.lineTo(-player.r-2,player.r+4);
    ctx.closePath();ctx.fill();ctx.stroke();

    if(player.shield>0){
      ctx.globalAlpha*=.85;ctx.strokeStyle='rgba(120,255,200,.45)';ctx.lineWidth=2;
      ctx.beginPath();ctx.arc(0,0,player.r+10,0,Math.PI*2);ctx.stroke();
      ctx.globalAlpha=1;
    }
    if(buffs.invulnT>0){
      ctx.globalAlpha=.55;ctx.strokeStyle='rgba(255,255,255,.65)';ctx.lineWidth=2;
      ctx.beginPath();ctx.arc(0,0,player.r+15,0,Math.PI*2);ctx.stroke();
    }
    ctx.restore();
  }

  function syncHud(){
    const ch=chapterOf(state.stage), sub=subOf(state.stage);
    const mod=chapterMod(ch);
    $hudChapter.textContent=`CH ${ch}-${sub} Â· ${mod.name}`;
    $hudStage.textContent=`é—œå¡ ${state.stage}`;
    $hudWave.textContent=`æ³¢æ¬¡ ${state.wave}/${state.wavesPerStage}`;

    const hpPct=clamp(player.hp/player.hpMax,0,1);
    $hpFill.style.width=`${hpPct*100}%`;
    $hpNum.textContent=`${Math.floor(player.hp)}/${Math.floor(player.hpMax)}`;

    $hudShield.textContent=`ğŸ›¡ +${Math.floor(player.shield)}`;
    $hudCoins.textContent = `ğŸª™ ${state.coins}`;

    // cd displays
    const burstLeft  = skillCdLeft('burst');
    const invulnLeft = skillCdLeft('invuln');

    if(buffs.burstT > SKILL_EPS) $cdBurst.textContent = `${Math.ceil(buffs.burstT)}s`;
    else if(burstLeft > SKILL_EPS) $cdBurst.textContent = `CD ${Math.ceil(burstLeft)}s`;
    else $cdBurst.textContent = 'Ready';

    if(buffs.invulnT > SKILL_EPS) $cdInvuln.textContent = `${Math.ceil(buffs.invulnT)}s`;
    else if(invulnLeft > SKILL_EPS) $cdInvuln.textContent = `CD ${Math.ceil(invulnLeft)}s`;
    else $cdInvuln.textContent = 'Ready';

    $btnBurst.disabled  = !(mode==='play' && !paused && buffs.burstT<=SKILL_EPS  && burstLeft<=SKILL_EPS);
    $btnInvuln.disabled = !(mode==='play' && !paused && buffs.invulnT<=SKILL_EPS && invulnLeft<=SKILL_EPS);

    // shop button enabled only post/shop
    $btnShop.disabled = !(mode==='post' || mode==='shop');
  }

  function frame(t){
    const dt=Math.min(.033,(t-lastT)/1000); lastT=t;
    if(mode==='play' && !paused) update(dt);
    draw();
    syncHud();

    if(toastT>0){
      toastT=Math.max(0,toastT-dt);
      if(toastT===0 && !paused) $toast.classList.remove('show');
      else $toast.classList.add('show');
    }
    requestAnimationFrame(frame);
  }

  // bootstrap
  function syncLayout(){ resize(); }
  syncLayout();
  window.addEventListener('resize',syncLayout,{passive:true});

  setPadX(.5);
  player.x=W*0.5; player.y=H-42;
  spawnWave();
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>