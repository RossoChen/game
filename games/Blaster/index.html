<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover"/>
<title>Blaster</title>
<meta name="theme-color" content="#0b1220"/>
<link rel="manifest" href="/games/manifest.webmanifest">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<style>
:root{
  color-scheme:dark;
  --appSafeTop:24px; --appSafeR:0px; --appSafeB:0px; --appSafeL:0px;
  --appExtraTop:10px; --appExtraBottom:10px;
  --gap:8px;
}
html,body{
  height:100%;margin:0;background:#0b1220;color:#e7eefc;
  font-family:system-ui,"Noto Sans TC",sans-serif;
  -webkit-user-select:none;user-select:none;
  touch-action:manipulation;overflow:hidden
}
body{position:fixed;inset:0}
.app{
  height:100svh;
  padding:
    calc(var(--appSafeTop) + var(--appExtraTop))
    calc(var(--appSafeR) + 10px)
    calc(var(--appSafeB) + var(--appExtraBottom))
    calc(var(--appSafeL) + 10px);
  display:flex;flex-direction:column;gap:var(--gap);box-sizing:border-box;
}

.hud{display:flex;flex-direction:column;gap:var(--gap);min-height:0}
.hudRow{
  display:flex;align-items:center;gap:var(--gap);
  overflow-x:auto;-webkit-overflow-scrolling:touch;scrollbar-width:none;
}
.hudRow::-webkit-scrollbar{display:none}
.hudRow2{justify-content:space-between}

.pill,button.pill{
  border-radius:999px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(255,255,255,.06);
  color:#e7eefc;
  padding:8px 10px;
  font-size:13px;
  line-height:1;
  white-space:nowrap;
  -webkit-tap-highlight-color:transparent
}
button.pill{cursor:pointer}
button.pill:active{transform:scale(.99)}
button.pill:disabled{opacity:.45;cursor:default}

#hudStage{min-width:56px;padding:8px 8px;text-align:center}

/* ===== LV area: force single-line, never grow HUD height ===== */
.lvxTop{flex:1 1 auto;min-width:0;max-width:none;}
.lvx{
  flex:1 1 auto; min-width:0;
  display:flex;align-items:center;gap:10px;
  padding:8px 10px;border-radius:16px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.05);
  flex-wrap:nowrap;
  white-space:nowrap;
  overflow:hidden;
}
.lvx .label{
  opacity:.85;font-weight:900;letter-spacing:.2px;
  min-width:0;
  white-space:nowrap;
}
.lvx .num{
  opacity:.85;font-variant-numeric:tabular-nums;
  min-width:0;
  text-align:right;
  white-space:nowrap;
}

.hpRowRight{display:flex;align-items:center;gap:var(--gap);flex:0 0 auto}

.hpbar{
  flex:1 1 auto; min-width:0;
  display:flex;align-items:center;gap:8px;
  padding:8px 10px;border-radius:16px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.05);
}
.hpbar .label{opacity:.85;font-weight:800;letter-spacing:.2px}
.hpbar .track{
  flex:1 1 auto; min-width:90px; max-width:240px;
  height:12px;border-radius:999px;
  background:rgba(255,255,255,.10);
  overflow:hidden;border:1px solid rgba(255,255,255,.10)
}
.hpbar .fill{height:100%;width:50%;background:rgba(120,255,200,.95)}
.hpbar .num{opacity:.85;font-variant-numeric:tabular-nums;min-width:86px;text-align:right}

.main{flex:1;min-height:0;display:flex;flex-direction:column;gap:var(--gap)}
.boardWrap{
  flex:1;min-height:0;
  border-radius:18px;border:1px solid rgba(255,255,255,.12);
  background:radial-gradient(1200px 800px at 50% 0%, rgba(90,120,255,.10), transparent 60%),rgba(255,255,255,.03);
  overflow:hidden;position:relative
}
canvas{width:100%;height:100%;display:block}

.touchpad{
  flex:0 0 auto;
  height:max(42px,5.5svh);
  border-radius:16px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.04);
  position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent
}
.touchpad .hint{position:absolute;inset:auto 0 10px 0;text-align:center;font-size:14px;opacity:.75;pointer-events:none}
.touchpad .bar{position:absolute;left:10px;right:10px;top:16px;bottom:16px;border-radius:14px;border:1px dashed rgba(255,255,255,.18);opacity:.7}
.touchpad .thumb{position:absolute;top:50%;width:46px;height:46px;transform:translate(-50%,-50%);border-radius:999px;border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.08);box-shadow:0 8px 30px rgba(0,0,0,.35);pointer-events:none}

.skills{
  flex:0 0 auto;
  display:flex;
  gap:8px;
  align-items:center;
  overflow-x:auto;
  -webkit-overflow-scrolling:touch;
  scrollbar-width:none;
  padding-bottom:max(env(safe-area-inset-bottom), 6px);
}
.skills::-webkit-scrollbar{display:none}
.sbtn{
  flex:0 0 auto;
  display:flex;
  align-items:center;
  gap:8px;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(255,255,255,.06);
  color:#e7eefc;
  -webkit-tap-highlight-color:transparent;
  white-space:nowrap;
}
.sbtn:active{transform:scale(.99)}
.sbtn[disabled]{opacity:.45;cursor:default}
.sbtn .ico{font-size:16px;line-height:1}
.sbtn .name{font-weight:900;letter-spacing:.2px}
.sbtn .cd{margin-left:6px;opacity:.9;font-variant-numeric:tabular-nums}

.overlay{position:fixed;inset:0;background:rgba(0,0,0,.58);display:none;align-items:center;justify-content:center;padding:16px;z-index:50}
.overlay.show{display:flex}
.panel{width:min(720px,92vw);border-radius:18px;border:1px solid rgba(255,255,255,.14);background:rgba(15,22,40,.92);padding:16px;box-shadow:0 18px 70px rgba(0,0,0,.55)}
.panel h2{margin:0 0 10px;font-size:18px;letter-spacing:.2px}
.opts{display:grid;grid-template-columns:1fr;gap:10px}
@media (min-width:720px){.opts{grid-template-columns:1fr 1fr 1fr}}
.opt{border-radius:16px;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06);padding:14px;cursor:pointer;-webkit-tap-highlight-color:transparent}
.opt:active{transform:scale(.99)}
.opt .t{font-weight:900;margin-bottom:6px}.opt .d{opacity:.78;font-size:13px;line-height:1.4}
.panel .sub{opacity:.82;font-size:13px;line-height:1.35;margin:8px 0 14px}
.panel .row{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
.panel .row .pill{padding:10px 12px}

.toast{position:absolute;left:50%;top:14px;transform:translateX(-50%);padding:10px 12px;border-radius:999px;border:1px solid rgba(255,255,255,.14);background:rgba(0,0,0,.35);font-size:13px;opacity:.9;display:none;pointer-events:none}
.toast.show{display:block}

.rotateLock{
  position:fixed;inset:0;z-index:200;
  display:none;align-items:center;justify-content:center;
  background:rgba(0,0,0,.78);
  padding:18px;text-align:center;
}
.rotateLock .card{
  width:min(520px,92vw);
  border-radius:18px;border:1px solid rgba(255,255,255,.14);
  background:rgba(15,22,40,.92);
  padding:16px;box-shadow:0 18px 70px rgba(0,0,0,.55)
}
.rotateLock .title{font-weight:900;font-size:18px;margin-bottom:8px}
.rotateLock .desc{opacity:.85;line-height:1.45}
</style>
</head>

<body>
<div class="app">
  <div class="hud">
    <div class="hudRow">
      <button class="pill" id="btnBack">â† Back</button>
      <span class="pill" id="hudStage">é—œå¡ 1</span>
      <span class="pill" id="hudCoins">ğŸª™ 0</span>

      <div class="lvx lvxTop">
        <span class="label" id="hudLv">LV 1</span>
        <span class="num" id="xpPct">0%</span>
      </div>
    </div>

    <div class="hudRow hudRow2">
      <div class="hpbar">
        <span class="label">HP</span>
        <div class="track"><div class="fill" id="hpFill"></div></div>
        <span class="num" id="hpNum">300/300</span>
      </div>

      <div class="hpRowRight">
        <!-- Shield always visible -->
        <span class="pill" id="hudShield">ğŸ›¡ +0</span>
        <button class="pill" id="btnShop">å•†åº—</button>
      </div>
    </div>
  </div>

  <div class="main">
    <div class="boardWrap" id="boardWrap">
      <canvas id="c"></canvas>
      <div class="toast" id="toast">Paused</div>
    </div>

    <div class="touchpad" id="touchpad" aria-label="touchpad">
      <div class="bar"></div>
      <div class="thumb" id="thumb" style="left:50%"></div>
      <div class="hint">å·¦å³æ‹–æ›³ï¼ç§»å‹•ï¼ˆè‡ªå‹•å°„æ“Šï¼‰</div>
    </div>

    <div class="skills" id="skills">
      <button class="sbtn" id="btnBurst"><span class="ico">ğŸ”¥</span><span class="name">çˆ†ç™¼</span><span class="cd" id="cdBurst">Ready</span></button>
      <!-- Invuln icon changed to âœ¨ -->
      <button class="sbtn" id="btnInvuln"><span class="ico">âœ¨</span><span class="name">ç„¡æ•µ</span><span class="cd" id="cdInvuln">Ready</span></button>
    </div>
  </div>
</div>

<div class="overlay" id="overlay">
  <div class="panel">
    <h2 id="panelTitle">å‡ç´šï¼šé¸ä¸€å€‹</h2>
    <div class="sub" id="panelSub" style="display:none"></div>
    <div class="opts" id="opts"></div>
    <div class="row" id="panelRow" style="display:none"></div>
  </div>
</div>

<div class="rotateLock" id="rotateLock">
  <div class="card">
    <div class="title">è«‹åˆ‡å›ç›´å‘</div>
    <div class="desc">é€™å€‹éŠæˆ²åªæ”¯æ´ç›´å‘ã€‚<br>è½‰å›ç›´å‘å¾Œæœƒè‡ªå‹•æ¢å¾©ã€‚</div>
  </div>
</div>

<script>
(()=>{ // setup
  // ---------- Safe-area / Dynamic Island ----------
  function isIOS(){
    return /iP(hone|ad|od)/.test(navigator.platform) || (navigator.userAgent.includes('Mac') && 'ontouchend' in document);
  }
  function readEnvInsetPx(side){
    const d=document.createElement('div');
    const isLR = (side === 'left' || side === 'right');
    d.style.cssText =
      `position:fixed;left:0;top:0;visibility:hidden;pointer-events:none;` +
      (isLR
        ? `width:env(safe-area-inset-${side});height:0;`
        : `height:env(safe-area-inset-${side});width:0;`);
    document.body.appendChild(d);
    const r = d.getBoundingClientRect();
    d.remove();
    const px = isLR ? r.width : r.height;
    return px || 0;
  }
  function isDynamicIslandSize(){
    const w=Math.min(screen.width, screen.height);
    const h=Math.max(screen.width, screen.height);
    const key=`${w}x${h}`;
    return new Set(['393x852','430x932','402x874','440x956']).has(key);
  }
  function applySafeArea(){
    const root=document.documentElement;
    let top=readEnvInsetPx('top');
    let right=readEnvInsetPx('right');
    let bottom=readEnvInsetPx('bottom');
    let left=readEnvInsetPx('left');

    const standalone =
      (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) ||
      (navigator.standalone === true);

    if(isIOS() && top < 10) top = isDynamicIslandSize() ? 54 : 44;
    else top = Math.max(top, 24);

    const extraTop = standalone ? 14 : 10;
    const extraBottom = standalone ? 4 : 8;

    root.style.setProperty('--appSafeTop', `${top}px`);
    root.style.setProperty('--appSafeR', `${right}px`);
    root.style.setProperty('--appSafeB', `${bottom}px`);
    root.style.setProperty('--appSafeL', `${left}px`);
    root.style.setProperty('--appExtraTop', `${extraTop}px`);
    root.style.setProperty('--appExtraBottom', `${extraBottom}px`);
  }
  applySafeArea();
  window.addEventListener('resize', applySafeArea, {passive:true});
  window.addEventListener('orientationchange', applySafeArea, {passive:true});
  document.addEventListener('visibilitychange', ()=>{ if(!document.hidden) applySafeArea(); }, {passive:true});

  // ---------- Canvas ----------
  const wrap=document.getElementById('boardWrap'),canvas=document.getElementById('c'),ctx=canvas.getContext('2d',{alpha:true});
  let W=0,H=0;
  function resize(){
    const r=wrap.getBoundingClientRect(),dpr=Math.min(2,window.devicePixelRatio||1);
    canvas.width=Math.floor(r.width*dpr);canvas.height=Math.floor(r.height*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);W=r.width;H=r.height;
  }
  window.addEventListener('resize',resize);

  if(window.visualViewport){
    const vvSync = ()=>{ applySafeArea(); resize(); };
    visualViewport.addEventListener('resize', vvSync, {passive:true});
    visualViewport.addEventListener('scroll', vvSync, {passive:true});
  }

  resize();

  // ---------- HUD refs ----------
  const $stage=document.getElementById('hudStage');
  const $lv=document.getElementById('hudLv');
  const $xpPct=document.getElementById('xpPct');
  const $hudCoins=document.getElementById('hudCoins');
  const $hudShield=document.getElementById('hudShield');

  const $hpFill=document.getElementById('hpFill'),$hpNum=document.getElementById('hpNum'),
        $toast=document.getElementById('toast'),$btnBack=document.getElementById('btnBack'),
        $btnShop=document.getElementById('btnShop');

  // overlay refs
  const overlay=document.getElementById('overlay');
  const opts=document.getElementById('opts');
  const $panelTitle=document.getElementById('panelTitle');
  const $panelSub=document.getElementById('panelSub');
  const $panelRow=document.getElementById('panelRow');

  // skills refs
  const $btnBurst=document.getElementById('btnBurst');
  const $btnInvuln=document.getElementById('btnInvuln');
  const $cdBurst=document.getElementById('cdBurst');
  const $cdInvuln=document.getElementById('cdInvuln');

  $btnBack.addEventListener('click',()=>{
    if(document.referrer){
      try{const ref=new URL(document.referrer);if(ref.origin===location.origin){history.back();return}}catch(_){}
    }
    location.href='./games/';
  });

  // ---------- Orientation guard ----------
  const $rotateLock=document.getElementById('rotateLock');
  let lockedLandscape=false;

  function isLandscape(){
    const w = (window.visualViewport?.width ?? window.innerWidth);
    const h = (window.visualViewport?.height ?? window.innerHeight);
    return w > h;
  }
  function syncOrientationLock(){
    lockedLandscape = isLandscape();
    $rotateLock.style.display = lockedLandscape ? 'flex' : 'none';
    if(lockedLandscape){
      paused = true;
      $toast.classList.remove('show');
    }else{
      if(mode === 'play') paused = false;
      lastT = performance.now();
    }
  }
  window.addEventListener('resize', syncOrientationLock, {passive:true});
  window.addEventListener('orientationchange', syncOrientationLock, {passive:true});
  if(window.visualViewport){
    visualViewport.addEventListener('resize', syncOrientationLock, {passive:true});
  }

  // ---------- Utils ----------
  const rand=(a,b)=>a+Math.random()*(b-a);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const dist2=(ax,ay,bx,by)=>{const dx=ax-bx,dy=ay-by;return dx*dx+dy*dy};

  // ---------- Touchpad ----------
  const pad=document.getElementById('touchpad'),thumb=document.getElementById('thumb');
  let padActive=false,padX=.5;

  // ---------- Constants ----------
  const BASE_HP=300;
  const SPREAD_CAP_BASE=5;
  const PIERCE_CAP=5;

  const BULLET_R_MIN=3;
  const BULLET_R_BASE=4;
  const BULLET_R_CAP=8;
  const BULLET_R_UPG_CAP=7;

  const ENEMY_BULLET_SPEED_MUL = 0.30;

  // Spread Angle Tuning
  const SPREAD_2 = 0.12;
  const SPREAD_3 = 0.16;
  const SPREAD_EVOL_3 = 0.15;
  const SPREAD_EVOL_4 = 0.18;
  const BOSS_SPREAD_P1 = 0.24;
  const BOSS_SPREAD_P2 = 0.26;
  const BOSS_SPREAD_P3 = 0.30;

  // skills (shop adjustable)
  let BURST_DURATION = 20;
  let BURST_CD = 50;
  let INVULN_DURATION = 20;
  let INVULN_CD = 80;

  // healer
  const HEALER_CHANCE_BY_STAGE = (stage)=>{
    if(stage <= 4)  return 0.00;
    if(stage <= 7)  return 0.10;
    if(stage <= 12) return 0.20;
    if(stage <= 19) return 0.30;
    if(stage <= 30) return 0.50;
    if(stage <= 40) return 0.70;
    if(stage <= 50) return 0.85;
    return 1.00;
  };
  function healerCountByChain(){
    let n = 1;
    if(Math.random() < 0.50) n++;
    if(n>=2 && Math.random() < 0.30) n++;
    if(n>=3 && Math.random() < 0.10) n++;
    if(n>=4 && Math.random() < 0.05) n++;
    return n;
  }
  const HEALER_HEAL_PCT = 0.05;
  const HEALER_PERIOD = 10.0;
  const HEALER_BOSS_MUL = 4.0;

  function bulletSizeDmgMul(r){
    const dr = Math.max(0, r - BULLET_R_BASE);
    return clamp(1 - dr*0.06, 0.70, 1.00);
  }
  function bulletClearMul(r){
    const dr = Math.max(0, r - BULLET_R_BASE);
    return clamp(1 + dr*0.05, 1.00, 1.25);
  }
  function enemyBulletHpByStage(stage){
    if(stage < 6)  return 8;
    if(stage < 14) return 10;
    if(stage < 20) return 14;
    if(stage < 26) return 18;
    return 22;
  }
  function beamChanceByStage(stage){ return 0.50; }

  // ---------- State ----------
  const state={
    stage:1,wave:1,score:0,coins:0,xp:0,level:1,nextXp:60,
    waveClearCooldown:0,waveInProgress:false,bossEveryWaves:5
  };

  const player={
    x:W*.5,y:0,r:14,
    hp:BASE_HP,hpMax:BASE_HP,
    moveSpeed:520,fireRate:6.2,dmg:26,bulletSpeed:820,
    spread_perm:0, spreadCap:SPREAD_CAP_BASE,
    pierce_perm:2,
    shield:0,shieldMax:0,
    regen:0, xpGainMul:1.0, bulletR:BULLET_R_BASE
  };

  const buffs={
    magnet:0, spreadBonusT:0,
    invulnT:0, burstT:0
  };

  let hitIFrameT = 0;
  const skills={ burst:{cd:0}, invuln:{cd:0} };

  let pBullets=[],eBullets=[],enemies=[],drops=[],particles=[];

  function setPadX(nx){
    padX=Math.max(0,Math.min(1,nx));
    thumb.style.left=`${padX*100}%`;
    player.x=lerp(player.x,padX*W,1);
  }
  function pointerToPadX(e){const r=pad.getBoundingClientRect();return (e.clientX-r.left)/r.width}
  pad.addEventListener('pointerdown',e=>{e.preventDefault();pad.setPointerCapture(e.pointerId);padActive=true;setPadX(pointerToPadX(e))});
  pad.addEventListener('pointermove',e=>{if(!padActive)return;e.preventDefault();setPadX(pointerToPadX(e))});
  pad.addEventListener('pointerup',e=>{padActive=false;try{pad.releasePointerCapture(e.pointerId)}catch(_){}});pad.addEventListener('pointercancel',()=>padActive=false);

  function enemyHoldY(){return clamp(H*.18,110,190)}

  // ---------- Balance ----------
  function stageDifficultyMul(stage){
    const early = 1 + Math.max(0, stage-1) * 0.035;
    const mid   = (stage>=12) ? (1 + (stage-12) * 0.025) : 1;
    const late  = (stage>=20) ? (1 + (stage-20) * 0.030) : 1;
    return Math.min(2.6, early * mid * late);
  }
  function waveConfig(stage,wave){
    const mul = stageDifficultyMul(stage);
    const baseCount = 5 + Math.floor((stage-1)*0.95) + Math.floor((wave-1)*0.75);
    const count = clamp(baseCount, 6, 30);

    const hp = (24 + stage*7 + wave*5) * mul;
    const fire = (0.52 + stage*0.055 + wave*0.055) * clamp(1 + (stage>=14?0.06:0), 1, 1.18);
    const bullet = (245 + stage*15 + wave*14) * clamp(1 + (stage>=16?0.05:0), 1, 1.25);

    const dmgBase = (5.5 + stage*0.62 + wave*0.50);
    const dmg = dmgBase * clamp(1 + (stage>=12?0.08:0), 1, 1.35);

    const mobSpreadChance = clamp((stage-10)*0.025 + (wave-4)*0.030, 0, 0.35);
    const mobPierceChance = clamp((stage-12)*0.020 + (wave-5)*0.025, 0, 0.30);

    let eliteChance;
    if(stage < 8) eliteChance = 0.05;
    else if(stage < 12) eliteChance = 0.18;
    else if(stage < 16) eliteChance = 0.35;
    else if(stage < 20) eliteChance = 0.55;
    else if(stage < 24) eliteChance = 0.70;
    else eliteChance = 0.80;

    return {count,hp,fire,bullet,dmg,mobSpreadChance,mobPierceChance,eliteChance};
  }

  // ---------- Spawning ----------
  function spawnMob(x,y,targetY,cfg,meta={}){
    const isStrafe=Math.random()<(0.38+state.stage*0.03);
    const elite = !!meta.elite;
    const hp = cfg.hp * (elite? 2.3 : 1.0);
    const r  = elite ? 18 : 15;
    return {
      type: elite?'elite':'mob',
      x,y,targetY,r,
      hp,hpMax:hp,
      fireCd:rand(.35,1.15),
      fireRate: elite ? Math.min(cfg.fire*1.08, 1.0) : cfg.fire,
      bulletSpeed: cfg.bullet * (elite?1.08:1.00),
      bulletDmg: cfg.dmg * (elite?1.20:1.00),
      evoSpread: meta.evoSpread||false,
      evoPierce: meta.evoPierce||false,
      strafeAmp:isStrafe?rand(45, elite?150:120):0,
      strafeSpd:isStrafe?rand(.85, elite?2.35:1.85):0,
      strafePhase:rand(0,Math.PI*2),
      hitFlash:0
    };
  }

  function spawnHealer(x,y,targetY){
    const hp = 140 + state.stage*10;
    return {
      type:'healer',
      x,y,targetY,r:15,
      hp,hpMax:hp,
      healCd: rand(1.0, 2.2),
      healPeriod: HEALER_PERIOD,
      healPct: HEALER_HEAL_PCT,
      strafeAmp: rand(40,90),
      strafeSpd: rand(1.0,2.0),
      strafePhase: rand(0,Math.PI*2),
      hitFlash:0
    };
  }

  function spawnWave(){
    enemies.length=0;
    eBullets.length=0;
    state.waveInProgress=true;

    const cfg = waveConfig(state.stage, state.wave);
    const holdY = enemyHoldY();
    const lanes = cfg.count;

    const hasHealer = Math.random() < HEALER_CHANCE_BY_STAGE(state.stage);

    let healerLanes = new Set();
    if(hasHealer){
      const want = healerCountByChain();
      const maxN = Math.min(want, Math.max(1, lanes-1));
      while(healerLanes.size < maxN){
        healerLanes.add(Math.floor(Math.random()*lanes));
        if(healerLanes.size >= lanes-1) break;
      }
    }
    for(let i=0;i<lanes;i++){
      const x = (i+1)*(W/(lanes+1));

      if(healerLanes.has(i)){
        enemies.push(spawnHealer(x, -44 - i*18, holdY + rand(-18,18)));
        continue;
      }

      const evoSpread = Math.random() < cfg.mobSpreadChance;
      const evoPierce = Math.random() < cfg.mobPierceChance;
      const isElite = Math.random() < cfg.eliteChance;

      if(isElite){
        enemies.push(spawnMob(
          x, -40 - i*18, holdY + rand(-18,18),
          cfg,
          {elite:true, evoSpread:true, evoPierce:true}
        ));
      }else{
        enemies.push(spawnMob(
          x, -40 - i*18, holdY + rand(-18,18),
          cfg,
          {elite:false, evoSpread, evoPierce}
        ));
      }
    }
  }

  function spawnAdds(count=4,power=.90){
    const cfg=waveConfig(state.stage,state.wave),holdY=enemyHoldY()+rand(8,22);
    const addHealer = (state.stage>=10) && Math.random()<0.65;
    for(let i=0;i<count;i++){
      if(addHealer && i===0){
        const x=rand(40,W-40);
        enemies.push(spawnHealer(x,-60-i*24,holdY+rand(-14,14)));
        continue;
      }
      const x=rand(40,W-40);
      const evoSpread = Math.random() < cfg.mobSpreadChance*0.85;
      const evoPierce = Math.random() < cfg.mobPierceChance*0.85;
      const m = spawnMob(x,-60-i*24,holdY+rand(-14,14),cfg,{elite:false,evoSpread,evoPierce});
      m.hp*=power; m.hpMax=m.hp;
      m.fireRate*= (1.05+rand(-.05,.12));
      m.bulletSpeed*=(.95+rand(-.03,.08));
      m.bulletDmg*=(.95+rand(-.05,.10));
      m.r=14;
      enemies.push(m);
    }
  }

  function spawnBoss(){
    const holdY=enemyHoldY()-12,
          hp=(650+state.stage*170)*stageDifficultyMul(state.stage),
          baseSpd=240+state.stage*12;

    const boss={
      type:'boss',x:W*.5,y:-100,targetY:holdY,r:30,hp,hpMax:hp,
      bulletSpeed:baseSpd,bulletDmg:12+state.stage*2.0,
      strafeAmp:240,strafeSpd:1.05+state.stage*0.06,strafePhase:0,
      phase:1,ringCd:1.0,spiralCd:0.35,summonCd:999,
      burstCd:0.55,burstLeft:0,burstGap:0.10,burstGapCd:0,
      spin:0,hitFlash:0,
      medCd: (state.stage>=20)? (6.8+Math.random()*3.5) : 999
    };
    enemies.push(boss);
    toastMsg('Boss å…¥å ´',0.9);
  }

  function nextWave(){state.wave+=1;state.waveClearCooldown=.55;state.waveInProgress=false}
  function nextStage(){state.stage+=1;state.wave=1;state.waveClearCooldown=.85;state.waveInProgress=false}

  // ---------- Drops / Buffs ----------
  const DROP_TYPES=[
    {key:'heal',w:22},
    {key:'shield',w:18},
    {key:'spread',w:14},
    {key:'magnet',w:10},
  ];

  function spreadAtCap(){ return player.spread_perm >= player.spreadCap; }

  function pickDrop(){
    const pool = spreadAtCap()
      ? DROP_TYPES.filter(x=>x.key!=='spread')
      : DROP_TYPES;

    const total=pool.reduce((s,a)=>s+a.w,0) || 1;
    let r=Math.random()*total;
    for(const it of pool){r-=it.w;if(r<=0)return it.key}
    return pool[0]?.key || 'heal';
  }

  function maybeDrop(x,y,isBoss=false){
    const p = isBoss ? .92 : .22;
    if(Math.random() > p) return;
    const t = pickDrop();
    if(shopState.magnetRun && t === 'magnet'){
      dropCoin(x, y, 3);
      return;
    }
  
    drops.push({x,y,r:10,vy:rand(70,140),type:t,life:12});
  }

  function dropCoin(x,y,amt){
    drops.push({x,y,r:10,vy:rand(70,130),type:'coin',life:12,amt});
  }

  function applyDrop(type, d){
    if(type==='heal'){
      player.hp=clamp(player.hp+35,0,player.hpMax);
    }else if(type==='shield'){
      player.shieldMax=Math.max(player.shieldMax,30);
      player.shield=clamp(player.shield+30,0,player.shieldMax);
    }else if(type==='spread'){
      buffs.spreadBonusT=Math.max(buffs.spreadBonusT,7.5);
    }else if(type==='magnet'){
      buffs.magnet=Math.max(buffs.magnet,9.0);
    }else if(type==='coin'){
      const amt = Math.max(1, d?.amt ?? 1);
      state.coins += amt;
      // no toast for coin (avoid spam)
    }
  }

  // ---------- Shop ----------
  const shopState={spreadCapUp:0,burstCdDown:0,invulnCdDown:0,burstDurUp:0,invulnDurUp:0,magnetRun:0};

  function price(base, lvl, growth=1.5){
    return Math.floor(base * Math.pow(growth, lvl));
  }

  function shopItems(){
    return [
      {
        id:'spreadCapUp',
        name:'æ•£å°„ä¸Šé™ +1',
        desc:`æå‡æ•£å°„ä¸Šé™ï¼ˆç›®å‰ ${player.spreadCap}ï¼‰`,
        cost:price(300, shopState.spreadCapUp, 1.5),
        canBuy:()=>true,
        buy:()=>{
          shopState.spreadCapUp++;
          player.spreadCap++;
        }
      },
      {
        id:'burstCdDown',
        name:'çˆ†ç™¼ CD -1s',
        desc:`é™ä½çˆ†ç™¼å†·å»ï¼ˆç›®å‰ ${BURST_CD.toFixed(0)}sï¼‰`,
        cost:price(320, shopState.burstCdDown, 1.5),
        canBuy:()=>BURST_CD > 15,
        buy:()=>{
          shopState.burstCdDown++;
          BURST_CD = Math.max(15, BURST_CD - 1);
          if(skills.burst.cd > BURST_CD) skills.burst.cd = BURST_CD;
        }
      },
      {
        id:'invulnCdDown',
        name:'ç„¡æ•µ CD -1s',
        desc:`é™ä½ç„¡æ•µå†·å»ï¼ˆç›®å‰ ${INVULN_CD.toFixed(0)}sï¼‰`,
        cost:price(320, shopState.invulnCdDown, 1.5),
        canBuy:()=>INVULN_CD > 20,
        buy:()=>{
          shopState.invulnCdDown++;
          INVULN_CD = Math.max(20, INVULN_CD - 1);
          if(skills.invuln.cd > INVULN_CD) skills.invuln.cd = INVULN_CD;
        }
      },
      {
        id:'burstDurUp',
        name:'çˆ†ç™¼æŒçºŒ +1s',
        desc:`å»¶é•·çˆ†ç™¼æ™‚é–“ï¼ˆç›®å‰ ${BURST_DURATION.toFixed(0)}sï¼‰`,
        cost:price(300, shopState.burstDurUp, 1.5),
        canBuy:()=>BURST_DURATION < 60,
        buy:()=>{
          shopState.burstDurUp++;
          BURST_DURATION = Math.min(60, BURST_DURATION + 1);
        }
      },
      {
        id:'invulnDurUp',
        name:'ç„¡æ•µæŒçºŒ +1s',
        desc:`å»¶é•·ç„¡æ•µæ™‚é–“ï¼ˆç›®å‰ ${INVULN_DURATION.toFixed(0)}sï¼‰`,
        cost:price(300, shopState.invulnDurUp, 1.5),
        canBuy:()=>INVULN_DURATION < 40,
        buy:()=>{
          shopState.invulnDurUp++;
          INVULN_DURATION = Math.min(40, INVULN_DURATION + 1);
        }
      },
      {
        id:'magnetRun',
        name:'æœ¬å±€ç£éµï¼ˆæ°¸ä¹…å¸é™„ï¼‰',
        desc:'æœ¬å±€ç²å¾—ç£éµæ•ˆæœï¼šæ•µæ–¹æ‰è½ç‰©æœƒè‡ªå‹•é£›åˆ°ä½ èº«ä¸Šï¼ˆç›´åˆ° Game Overï¼‰',
        cost:2000,
        canBuy:()=>shopState.magnetRun===0,
        buy:()=>{
          shopState.magnetRun = 1;
          // è®“ç£éµæ•ˆæœã€Œå¹¾ä¹ç­‰åŒæ°¸ä¹…ã€ï¼šä¸éœ€è¦é¡å¤–æ”¹ timer é‚è¼¯
          buffs.magnet = Math.max(buffs.magnet, 1e9);
        }
      },
    ];
  }

  function renderShop(){
    overlay.classList.add('show');
    opts.innerHTML='';
    $panelRow.innerHTML='';

    $panelTitle.textContent='å•†åº—';
    $panelSub.style.display='block';
    $panelSub.innerHTML=`é‡‘å¹£ï¼š<b>${state.coins}</b>`;

    const items=shopItems();
    for(const it of items){
      const affordable = state.coins >= it.cost;
      const allowed = it.canBuy ? it.canBuy() : true;
      const canBuy = affordable && allowed;

      const el=document.createElement('div');
      el.className='opt';
      el.innerHTML=
        `<div class="t">${it.name} <span style="opacity:.8">ï¼ˆğŸª™${it.cost}ï¼‰</span></div>`+
        `<div class="d">${it.desc}${allowed?'':'<br><span style="opacity:.7">ï¼ˆå·²é”ä¸Šé™ï¼‰</span>'}</div>`;

      if(!canBuy){
        el.style.opacity='0.55';
        el.style.cursor='default';
      }else{
        el.addEventListener('click',()=>{
          if(mode!=='shop' || !paused) return;
          if(state.coins < it.cost) return;
          if(it.canBuy && !it.canBuy()) return;

          state.coins -= it.cost;
          try{ it.buy && it.buy(); }catch(_){}
          renderShop();
        });
      }
      opts.appendChild(el);
    }

    $panelRow.style.display='flex';
    const btnClose=document.createElement('button');
    btnClose.className='pill';
    btnClose.textContent='é—œé–‰å•†åº—';
    btnClose.addEventListener('click',closeShop);
    $panelRow.appendChild(btnClose);
  }

  let paused=false;
  let mode='play'; // play | levelup | shop | gameover

  function openShop(){
    if(mode!=='play') return;
    if(lockedLandscape) return;
    mode='shop';
    paused=true;
    $toast.classList.remove('show');
    renderShop();
  }
  function closeShop(){
    overlay.classList.remove('show');
    mode='play';
    paused=false;
    lastT=performance.now();
  }

  $btnShop.addEventListener('click',()=>{
    if(mode==='play') openShop();
    else if(mode==='shop') closeShop();
  });

  // ---------- Skills ----------
  function canUseSkill(k){return mode==='play' && !paused && skills[k].cd<=0}
  function useBurst(){
    if(!canUseSkill('burst')) return;
    skills.burst.cd = BURST_CD;
    buffs.burstT = Math.max(buffs.burstT, BURST_DURATION);
    toastMsg(`ğŸ”¥ çˆ†ç™¼ï¼šå‚·å®³Ã—2ï¼ˆ${BURST_DURATION.toFixed(0)}sï¼‰`,0.7);
  }
  function useInvuln(){
    if(!canUseSkill('invuln')) return;
    skills.invuln.cd = INVULN_CD;
    buffs.invulnT = Math.max(buffs.invulnT, INVULN_DURATION);
    toastMsg(`âœ¨ ç„¡æ•µï¼ˆ${INVULN_DURATION.toFixed(0)}sï¼‰`,0.7);
  }
  $btnBurst.addEventListener('click',useBurst);
  $btnInvuln.addEventListener('click',useInvuln);

  // ---------- Level-up ----------
  const UPGRADES=[
    {key:'dmg',t:'ç«åŠ›æå‡',d:'å‚·å®³ +10%'},
    {key:'firerate',t:'å°„é€Ÿæå‡',d:'å°„é€Ÿ +18%'},
    {key:'hp',t:'æ“´å……è£ç”²',d:'HP ä¸Šé™ +20ï¼Œä¸¦å›æ»¿'},
    {key:'pierce_perm',t:'æ°¸ä¹…ç©¿é€',d:'ç©¿é€ +1'},
    {key:'spread_perm',t:'æ°¸ä¹…æ•£å°„',d:'æ•£å°„ +1'},
    {key:'shield_cap',t:'è­·ç›¾æ“´å®¹',d:'è­·ç›¾ä¸Šé™ +20ï¼Œä¸¦å›æ»¿'},
    {key:'regen',t:'è‡ªå‹•ä¿®å¾©',d:'æ¯ç§’å›å¾© +1'},
    {key:'xp_gain',t:'å­¸ç¿’åŠ é€Ÿ',d:'ç²å¾— XP +10%'},
    {key:'bullet_size',t:'å½ˆé«”å¢å¼·',d:'å­å½ˆæ›´å¤§'},
  ];
  function canPickUpgrade(key){
    if(key==='pierce_perm') return player.pierce_perm < PIERCE_CAP;
    if(key==='spread_perm') return player.spread_perm < player.spreadCap;
    if(key==='bullet_size') return player.bulletR < BULLET_R_UPG_CAP;
    return true;
  }

  function openLevelUp(){
    mode='levelup';
    paused=true;

    overlay.classList.add('show');
    $panelTitle.textContent='å‡ç´šï¼šé¸ä¸€å€‹';
    $panelSub.style.display='none';
    $panelRow.style.display='none';
    $panelRow.innerHTML='';
    opts.innerHTML='';

    const filtered=UPGRADES.filter(u=>canPickUpgrade(u.key));
    const pool=[...filtered];
    const picks=[];
    const guardFillers=['regen','xp_gain','bullet_size','dmg','firerate'];

    while(picks.length<3 && pool.length){
      const i=Math.floor(Math.random()*pool.length);
      picks.push(pool.splice(i,1)[0]);
    }
    while(picks.length<3){
      const k=guardFillers[picks.length % guardFillers.length];
      const u=UPGRADES.find(x=>x.key===k);
      if(u && !picks.some(p=>p.key===u.key) && canPickUpgrade(u.key)) picks.push(u);
      else break;
    }

    for(const u of picks){
      const el=document.createElement('div');
      el.className='opt';
      el.innerHTML=`<div class="t">${u.t}</div><div class="d">${u.d}</div>`;
      el.addEventListener('click',()=>{
        applyUpgrade(u.key);
        overlay.classList.remove('show');
        mode='play';
        paused=false;
        $toast.classList.remove('show');
        lastT=performance.now();
      });
      opts.appendChild(el);
    }
  }

  function applyUpgrade(key){
    if(key==='dmg') player.dmg*=1.10;
    else if(key==='firerate') player.fireRate*=1.18;
    else if(key==='hp'){player.hpMax+=20;player.hp=player.hpMax}
    else if(key==='pierce_perm') player.pierce_perm=Math.min(PIERCE_CAP, player.pierce_perm+1);
    else if(key==='spread_perm') player.spread_perm=Math.min(player.spreadCap, player.spread_perm+1);
    else if(key==='shield_cap'){player.shieldMax+=20;player.shield=player.shieldMax}
    else if(key==='regen') player.regen+=1;
    else if(key==='xp_gain') player.xpGainMul*=1.10;
    else if(key==='bullet_size') player.bulletR = clamp(player.bulletR+1, BULLET_R_MIN, BULLET_R_CAP);
  }

  function xpStageMul(stage){
    if(stage <= 10) return 1 + (stage-1)*0.05;
    if(stage <= 20) return 1.45 + (stage-10)*0.06;
    return 2.05 + (stage-20)*0.04;
  }
  function addXp(xp){
    xp*=player.xpGainMul;
    state.xp+=xp;
    while(state.xp>=state.nextXp){
      state.xp-=state.nextXp;
      state.level+=1;
      state.nextXp=Math.floor(state.nextXp*1.15+14);
      openLevelUp();
    }
  }

  // ---------- Combat ----------
  function enemyBulletCap(){return enemies.some(e=>e.type==='boss')?260:140}

  let fireAcc=0;
  function spreadTotal(){ return player.spread_perm + (buffs.spreadBonusT>0?1:0); }
  function pierceTotal(){ return player.pierce_perm; }

  function shotsFromSpread(s){ return Math.max(1, 1 + Math.floor(s)); }

  function spreadDmgMul(n){
    if(n<=1) return 1;
    return clamp(1 / (1 + 0.25*(n-1)), 0.22, 1.0);
  }

  function shotVXPattern(n){
    if(n<=1) return [0];
    const baseMax = 240;
    const extra = Math.max(0, n-5) * 26;
    const maxV = clamp(baseMax + extra, 240, 520);

    const arr=[];
    const step = (2*maxV)/(n-1);
    for(let i=0;i<n;i++) arr.push(-maxV + step*i);
    return arr;
  }

  function shoot(dt){
    const rate=player.fireRate;
    fireAcc+=dt*rate;
    while(fireAcc>=1){fireAcc-=1;spawnPlayerShot()}
  }

  function spawnPlayerShot(){
    const s=spreadTotal();
    const n=shotsFromSpread(s);

    const r = clamp(player.bulletR, BULLET_R_MIN, BULLET_R_CAP);

    const burstMul = (buffs.burstT>0)?2.0:1.0;
    const dmg = player.dmg * spreadDmgMul(n) * bulletSizeDmgMul(r) * burstMul;

    const vxArr=shotVXPattern(n);
    const pr=pierceTotal();
    const baseY=player.y-player.r-6;

    const clashLeftBase = ((r>=6)?2:1) + Math.min(5, pr);

    for(const vx of vxArr){
      pBullets.push({x:player.x,y:baseY,r,vx,vy:-player.bulletSpeed,dmg,pierce:pr,alive:true, clashLeft:clashLeftBase});
    }
  }

  function enemyShoot(e,ang,sMul=1,dMul=1,meta={}){
    if(eBullets.length>=enemyBulletCap())return;
    let spd=(e.bulletSpeed??300)*sMul*ENEMY_BULLET_SPEED_MUL;

    const isBeam = !!meta.beam;
    const r = clamp(meta.r ?? (isBeam?5:4), 3, 10);
    const pierce = meta.pierce ?? 0;

    const baseHp = enemyBulletHpByStage(state.stage);
    const hp = isBeam ? 1 : (meta.hp ?? baseHp);

    const len = isBeam ? (meta.len ?? (state.stage>=26?34:28)) : 0;

    eBullets.push({x:e.x,y:e.y+e.r+4,r,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,dmg:(e.bulletDmg??8)*dMul,alive:true,pierce,hp,beam:isBeam,len});
  }

  function mobShoot(e){
    if(e.type==='healer') return;

    const ang=Math.atan2(player.y-e.y,player.x-e.x);
    const evoS = e.evoSpread;
    const evoP = e.evoPierce;

    const en2=(state.stage>=3||state.wave>=4);
    const en3=(state.stage>=5||state.wave>=6);
    const enLate=(state.stage>=12);
    const enBrutal=(state.stage>=20);

    const isElite = (e.type==='elite');

    if(isElite){
      const spread = 0.10;
      const lanes = (Math.random() < 0.55) ? 2 : 1;
      const useBeam2 = (Math.random() < 0.50);

      if(lanes === 1){
        enemyShoot(e, ang, 1.0, 0.98, { r:(enBrutal?5:4), pierce: evoP?1:0, beam: useBeam2, len: useBeam2 ? (enBrutal?34:28) : 0 });
      }else{
        for(const da of [-spread, spread]){
          enemyShoot(e, ang + da, 1.0, 0.98, { r:(enBrutal?5:4), pierce: evoP?1:0, beam: useBeam2, len: useBeam2 ? (enBrutal?34:28) : 0 });
        }
      }
      return;
    }

    if(evoS && (enLate || Math.random()<0.55)){
      const lanes = enBrutal?4:3;
      const spread = enBrutal?SPREAD_EVOL_4:SPREAD_EVOL_3;
      for(let i=0;i<lanes;i++){
        const t=(i-(lanes-1)/2)/(((lanes-1)/2)||1);
        enemyShoot(e,ang+t*spread,1.0,0.95,{r: enBrutal?5:4, pierce: evoP?1:0, beam:false});
      }
      return;
    }

    if(en3&&Math.random()<.22){
      for(const da of [-SPREAD_3,0,SPREAD_3]) enemyShoot(e,ang+da,1.0,.92,{pierce:evoP?1:0, beam:false});
    }else if(en2&&Math.random()<.35){
      for(const da of [-SPREAD_2,SPREAD_2]) enemyShoot(e,ang+da,1.0,.95,{pierce:evoP?1:0, beam:false});
    }else{
      enemyShoot(e,ang,1.0,1.0,{pierce:evoP?1:0, beam:false});
    }
  }

  function bossTick(e,dt){
    const r=e.hp/e.hpMax;
    const newPhase=(r<=.40)?3:(r<=.70?2:1);
    if(newPhase!==e.phase){
      e.phase=newPhase;
      if(e.phase===2){toastMsg('Bossï¼šPhase 2',.7);e.ringCd=.90;e.spiralCd=.40}
      else if(e.phase===3){toastMsg('Bossï¼šPhase 3',.7);e.summonCd=1.3+Math.random()*1.0;e.ringCd=.70;e.spiralCd=.28;e.burstCd=.55}
    }
    const spdMul=(e.phase===1?0.96:(e.phase===2?1.00:1.05));
    const dmgMul=(e.phase===1?1.00:(e.phase===2?1.02:1.05));

    const brutal = state.stage>=20;
    const bossEasy = state.stage < 10;
    const densMul = bossEasy ? 0.72 : 1.0;
    const cdMul   = bossEasy ? 1.18 : 1.0;

    const bossBulletHp = enemyBulletHpByStage(state.stage) * 0.60;

    e.burstCd-=dt;
    if(e.burstCd<=0 && eBullets.length<enemyBulletCap()){
      e.burstLeft=(e.phase===1?2:(e.phase===2?3:4));
      e.burstGapCd=0;
      e.burstCd=(e.phase===1?0.85:(e.phase===2?0.70:0.55)) * cdMul;
    }
    if(e.burstLeft>0){
      e.burstGapCd-=dt;
      if(e.burstGapCd<=0){
        const ang=Math.atan2(player.y-e.y,player.x-e.x);
        const lanesBase=(e.phase===1?5:(e.phase===2?5:6));
        const lanes = Math.max(3, Math.round(lanesBase * densMul));
        const spread=(e.phase===1?BOSS_SPREAD_P1:(e.phase===2?BOSS_SPREAD_P2:BOSS_SPREAD_P3));
        for(let i=0;i<lanes;i++){
          const t=(i-(lanes-1)/2)/(((lanes-1)/2)||1);
          enemyShoot(e,ang+t*spread,spdMul,dmgMul,{r: brutal?5:4, pierce: brutal?1:0, hp: bossBulletHp});
        }
        e.burstLeft-=1;
        e.burstGapCd=(e.phase===1?0.12:(e.phase===2?0.11:0.10)) * cdMul;
      }
    }

    e.ringCd-=dt;
    if(e.ringCd<=0 && eBullets.length<enemyBulletCap()){
      const nBase=(e.phase===1?12:(e.phase===2?18:28)) + (brutal?6:0);
      const n=Math.max(10, Math.round(nBase * densMul));
      const base=Math.random()*Math.PI*2;
      for(let i=0;i<n;i++){
        const a=base+(i/n)*Math.PI*2;
        enemyShoot(e,a,spdMul*0.98,dmgMul*0.75,{r: brutal?5:4, hp: bossBulletHp});
      }
      e.ringCd=(e.phase===1?1.10:(e.phase===2?0.80:0.60)) * (brutal?0.92:1.0) * cdMul;
    }

    e.spiralCd-=dt;
    e.spin=(e.spin??0)+dt*(e.phase===1?1.4:(e.phase===2?2.0:2.6))*(brutal?1.08:1.0);
    if(e.spiralCd<=0 && eBullets.length<enemyBulletCap()){
      const nBase=(e.phase===1?5:(e.phase===2?8:10)) + (brutal?2:0);
      const n=Math.max(4, Math.round(nBase * densMul));
      const base=e.spin;
      for(let i=0;i<n;i++){
        const a=base+(i/n)*Math.PI*2;
        enemyShoot(e,a,spdMul*1.00,dmgMul*0.65,{r: brutal?5:4, hp: bossBulletHp});
      }
      e.spiralCd=(e.phase===1?0.55:(e.phase===2?0.34:0.24))*(brutal?0.92:1.0) * cdMul;
    }

    if(e.phase===3){
      e.summonCd-=dt;
      if(e.summonCd<=0){
        spawnAdds(4+(Math.random()<0.5?1:0),.92);
        e.summonCd=5.2+(Math.random()*1.8-.7);
      }
    }
  }

  // ---------- damage / gameover ----------
  function damagePlayer(dmg){
    if(buffs.invulnT>0) return;
    if(hitIFrameT > 0) return;

    if(player.shield>0){
      const use=Math.min(player.shield,dmg);
      player.shield-=use; dmg-=use;
    }
    if(dmg>0) player.hp=Math.max(0,player.hp-dmg);
    const hitXp = clamp(Math.ceil(dmg*0.35), 1, 6);
    addXp(hitXp);

    hitIFrameT = 0.35;
    if(player.hp<=0) gameOver();
  }

  function gameOver(){
    mode='gameover';
    paused=true;
    $toast.classList.remove('show');

    const bestKey='blaster_best_score_v4';
    const best=Math.max(Number(localStorage.getItem(bestKey)||0), state.score);
    localStorage.setItem(bestKey,String(best));

    overlay.classList.add('show');
    opts.innerHTML='';
    $panelRow.innerHTML='';

    $panelTitle.textContent='Game Over';
    $panelSub.style.display='block';
    $panelSub.innerHTML=
      `æœ¬å±€åˆ†æ•¸ï¼š<b>${state.score}</b><br>`+
      `æœ¬å±€é‡‘å¹£ï¼š<b>${state.coins}</b><br>`+
      `æœ€é«˜åˆ†ï¼š<b>${best}</b><br>`+
      `é—œå¡ ${state.stage} / æ³¢æ¬¡ ${state.wave} / ç­‰ç´š ${state.level}`;
    $panelRow.style.display='flex';

    const btn=document.createElement('button');
    btn.className='pill';
    btn.textContent='é‡æ–°é–‹å§‹';
    btn.addEventListener('click',()=>{
      overlay.classList.remove('show');
      resetRun();
      mode='play';
      paused=false;
      lastT=performance.now();
    });
    $panelRow.appendChild(btn);

    const btnStay=document.createElement('button');
    btnStay.className='pill';
    btnStay.textContent='ç•™åœ¨é€™è£¡';
    btnStay.addEventListener('click',()=>{});
    $panelRow.appendChild(btnStay);
  }

  function resetRun(){
    state.stage=1;state.wave=1;state.score=0;state.coins=0;state.xp=0;state.level=1;state.nextXp=60;state.waveClearCooldown=0;state.waveInProgress=false;

    player.hpMax=BASE_HP; player.hp=BASE_HP;
    player.moveSpeed=520;player.fireRate=6.2;player.dmg=26;player.bulletSpeed=820;
    player.spread_perm=0;player.spreadCap=SPREAD_CAP_BASE;
    player.pierce_perm=2;
    player.shield=0;player.shieldMax=0;
    player.regen=0; player.xpGainMul=1.0;
    player.bulletR=BULLET_R_BASE;

    for(const k in shopState) shopState[k]=0;
    BURST_DURATION=20; BURST_CD=50;
    INVULN_DURATION=20; INVULN_CD=80;

    for(const k in buffs) buffs[k]=0;
    hitIFrameT = 0;

    skills.burst.cd=0;
    skills.invuln.cd=0;

    pBullets=[];eBullets=[];enemies=[];drops=[];particles=[];
    spawnWave();
  }

  function addBurst(x,y,n=10){
    for(let i=0;i<n;i++) particles.push({x,y,vx:rand(-220,220),vy:rand(-220,220),life:rand(.25,.55)});
  }
  let toastT=0, lastToastText='';
  function toastMsg(text,sec=.75){
    if(text===lastToastText && toastT>0.25) return;
    lastToastText = text;
    $toast.textContent=text;
    $toast.classList.add('show');
    toastT=sec;
  }

  // ---------- healer logic ----------
  function healerTick(h,dt){
    h.healCd -= dt;
    if(h.healCd>0) return;
    h.healCd = h.healPeriod;

    const targets = enemies.filter(e=>e.hp>0 && e.type!=='healer');
    if(!targets.length) return;

    let totalAdd = 0;
    for(const t of targets){
      const add = t.hpMax * h.healPct * (t.type==='boss' ? HEALER_BOSS_MUL : 1);
      const before = t.hp;
      t.hp = Math.min(t.hpMax, t.hp + add);
      totalAdd += Math.max(0, t.hp - before);
      addBurst(t.x, t.y, 6);
    }
    // keep healer toast short
    toastMsg(`ğŸ’™ +${Math.floor(totalAdd)}`, 0.35);
  }

  // ---------- Update ----------
  function update(dt){
    for(const k of ['magnet','spreadBonusT','invulnT','burstT']){
      if(buffs[k]>0) buffs[k]=Math.max(0,buffs[k]-dt);
    }
    for(const k in skills){
      if(skills[k].cd>0) skills[k].cd=Math.max(0, skills[k].cd-dt);
    }

    if(hitIFrameT > 0) hitIFrameT = Math.max(0, hitIFrameT - dt);
    if(player.regen>0 && player.hp>0) player.hp=clamp(player.hp+player.regen*dt,0,player.hpMax);

    player.y=H-42;
    player.x=clamp(player.x,player.r+8,W-player.r-8);
    shoot(dt);

    for(const e of enemies){
      e.y=lerp(e.y,e.targetY,clamp(dt*2.6,0,1));
      if(e.strafeAmp>0){
        e.strafePhase+=dt*e.strafeSpd;
        const ox=Math.sin(e.strafePhase)*e.strafeAmp;
        if(e.type==='boss') e.x=W*.5+ox;
        else {if(e.baseX==null)e.baseX=e.x; e.x=e.baseX+ox}
      }
      e.x=clamp(e.x,e.r+10,W-e.r-10);

      if(e.type==='boss') bossTick(e,dt);
      else if(e.type==='healer') healerTick(e,dt);
      else {
        e.fireCd-=dt;
        if(e.fireCd<=0){mobShoot(e); e.fireCd=1/e.fireRate}
      }

      if(e.hitFlash>0) e.hitFlash=Math.max(0,e.hitFlash-dt);
    }

    for(const b of pBullets){
      b.x+=b.vx*dt; b.y+=b.vy*dt;
      if(b.y<-30||b.x<-40||b.x>W+40) b.alive=false;
    }
    for(const b of eBullets){
      b.x+=b.vx*dt; b.y+=b.vy*dt;
      if(b.y>H+40||b.x<-50||b.x>W+50) b.alive=false;
    }

    // drops (coin included)
    for(const d of drops){
      d.y+=d.vy*dt; d.life-=dt;
      if(buffs.magnet>0){
        const dx=player.x-d.x,dy=player.y-d.y,l=Math.hypot(dx,dy)||1;
        const spd = shopState.magnetRun ? 820 : 260;
        d.x+=(dx/l)*spd*dt; d.y+=(dy/l)*spd*dt;
      }
      if(d.y>H+60||d.life<=0) d.dead=true;
      if(dist2(d.x,d.y,player.x,player.y)<(d.r+player.r+8)**2){
        d.dead=true;
        applyDrop(d.type, d);
      }
    }

    for(const p of particles){
      p.x+=p.vx*dt; p.y+=p.vy*dt;
      p.vx*=(1-dt*2.8); p.vy*=(1-dt*2.8);
      p.life-=dt; if(p.life<=0) p.dead=true;
    }

    // bullets clash (beams cannot be cancelled)
    for(const b of pBullets){
      if(!b.alive) continue;
      if((b.clashLeft??0)<=0) continue;

      for(const eb of eBullets){
        if(!eb.alive) continue;
        if(eb.beam) continue;

        if(dist2(b.x,b.y,eb.x,eb.y)<(b.r+eb.r+2)**2){
          if((eb.pierce||0)>0){
            eb.pierce -= 1;
            b.clashLeft = Math.max(0,(b.clashLeft||0)-1);
            if(b.clashLeft<=0) b.alive=false;
            addBurst(eb.x,eb.y,3);
            state.score+=1;
            break;
          }

          const clearDmg = b.dmg * bulletClearMul(b.r);
          eb.hp = (eb.hp ?? enemyBulletHpByStage(state.stage)) - clearDmg;

          addBurst(eb.x,eb.y,4);
          state.score+=1;

          b.clashLeft = Math.max(0,(b.clashLeft||0)-1);
          if(eb.hp<=0) eb.alive=false;
          if(b.clashLeft<=0) b.alive=false;
          break;
        }
      }
    }

    // player bullets vs enemies
    for(const b of pBullets){
      if(!b.alive) continue;
      for(const e of enemies){
        if(e.hp<=0) continue;
        if(dist2(b.x,b.y,e.x,e.y)<(b.r+e.r)**2){
          e.hp-=b.dmg; e.hitFlash=.12;
          addBurst(b.x,b.y,4);
          if(b.pierce<=0) b.alive=false; else b.pierce-=1;

          if(e.hp<=0){
            let coinAmt = 1;
            if(e.type === 'boss')  coinAmt = 30;
            if(e.type === 'elite') coinAmt = 3;
            if(e.type === 'healer') coinAmt = 10;
            dropCoin(e.x, e.y, coinAmt);

            if(e.type==='boss'){
              state.score+=320; addXp(300* xpStageMul(state.stage)); maybeDrop(e.x,e.y,true);
              addBurst(e.x,e.y,26);
            }else if(e.type==='elite'){
              state.score+=38; addXp(20* xpStageMul(state.stage)); maybeDrop(e.x,e.y,false);
              addBurst(e.x,e.y,12);
            }else if(e.type==='healer'){
              state.score+=30; addXp(15* xpStageMul(state.stage)); maybeDrop(e.x,e.y,false);
              addBurst(e.x,e.y,14);
            }else{
              state.score+=18; addXp(10* xpStageMul(state.stage)); maybeDrop(e.x,e.y,false);
              addBurst(e.x,e.y,10);
            }
          }
          break;
        }
      }
    }

    // enemy bullets vs player (beam capsule + normal)
    for(const eb of eBullets){
      if(!eb.alive) continue;

      if(eb.beam){
        const ang=Math.atan2(eb.vy,eb.vx);
        const L=eb.len||28, R=eb.r||5;
        const dx=Math.cos(ang)*(L/2), dy=Math.sin(ang)*(L/2);
        const ax=eb.x-dx, ay=eb.y-dy;
        const bx=eb.x+dx, by=eb.y+dy;

        const px=player.x, py=player.y;
        const vx=bx-ax, vy=by-ay;
        const wx=px-ax, wy=py-ay;
        const c1=wx*vx+wy*vy;
        const c2=vx*vx+vy*vy || 1;
        let t=c1/c2; t=clamp(t,0,1);
        const cx=ax+t*vx, cy=ay+t*vy;

        if(dist2(px,py,cx,cy) < (player.r + R + 1)**2){
          eb.alive=false;
          damagePlayer(eb.dmg);
          addBurst(player.x,player.y,10);
        }
        continue;
      }

      if(dist2(eb.x,eb.y,player.x,player.y)<(eb.r+player.r)**2){
        eb.alive=false;
        damagePlayer(eb.dmg);
        addBurst(player.x,player.y,10);
      }
    }

    // cleanup
    pBullets=pBullets.filter(b=>b.alive);
    eBullets=eBullets.filter(b=>b.alive);
    enemies=enemies.filter(e=>e.hp>0);
    drops=drops.filter(d=>!d.dead);
    particles=particles.filter(p=>!p.dead);

    // wave progression
    if(!state.waveInProgress){
      state.waveClearCooldown-=dt;
      if(state.waveClearCooldown<=0){
        if(state.wave===state.bossEveryWaves){spawnBoss();state.waveInProgress=true}
        else spawnWave();
      }
    }else{
      if(enemies.length===0){
        if(state.wave===state.bossEveryWaves) { nextStage(); }
        else { nextWave(); }
      }
    }

    if(toastT>0){
      toastT=Math.max(0,toastT-dt);
      if(toastT===0 && !paused) $toast.classList.remove('show');
    }
  }

  // ---------- Draw ----------
  function draw(){
    ctx.clearRect(0,0,W,H);

    ctx.save();ctx.globalAlpha=.10;ctx.strokeStyle='#e7eefc';
    const step=48;
    for(let x=0;x<=W;x+=step){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,H);ctx.stroke()}
    for(let y=0;y<=H;y+=step){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(W,y);ctx.stroke()}
    ctx.restore();

    ctx.save();ctx.fillStyle='rgba(120,255,200,.7)';
    for(const p of particles){ctx.globalAlpha=clamp(p.life*2.0,0,1);ctx.beginPath();ctx.arc(p.x,p.y,2.2,0,Math.PI*2);ctx.fill()}
    ctx.restore();

    // drops (coin icon by value)
    for(const d of drops){
      ctx.save();
      ctx.fillStyle='rgba(255,255,255,.08)';ctx.strokeStyle='rgba(255,255,255,.18)';ctx.lineWidth=1;
      ctx.beginPath();ctx.arc(d.x,d.y,d.r,0,Math.PI*2);ctx.fill();ctx.stroke();
      ctx.globalAlpha=.9;ctx.fillStyle='rgba(120,255,200,.95)';ctx.font='12px system-ui,"Noto Sans TC"';
      ctx.textAlign='center';ctx.textBaseline='middle';

      let icon =
        d.type==='heal'?'âœš':
        d.type==='shield'?'â›¨':
        d.type==='spread'?'âœ¦':
        d.type==='magnet'?'ğŸ§²':'';

      if(d.type==='coin'){
        const a = Math.max(1, d.amt ?? 1);
        icon =
          (a>=30) ? 'ğŸ' :
          (a>=10) ? 'ğŸ’' :
          (a>=3)  ? 'ğŸ’°' : 'ğŸª™';
      }

      ctx.fillText(icon,d.x,d.y+.5);
      ctx.restore();
    }

    // enemies
    for(const e of enemies){
      ctx.save();
      const isBoss=e.type==='boss', flash=e.hitFlash>0;
      const isElite=e.type==='elite';
      const isHealer=e.type==='healer';

      ctx.fillStyle = flash ? 'rgba(255,255,255,.18)'
        : isBoss ? 'rgba(255,120,120,.14)'
        : isElite ? 'rgba(220,180,255,.14)'
        : isHealer ? 'rgba(140,190,255,.14)'
        : 'rgba(255,255,255,.10)';

      ctx.strokeStyle = isBoss ? 'rgba(255,120,120,.35)'
        : isElite ? 'rgba(220,180,255,.45)'
        : isHealer ? 'rgba(140,190,255,.40)'
        : 'rgba(255,255,255,.20)';

      ctx.lineWidth = isBoss?2:(isElite?1.8:1);

      ctx.beginPath();ctx.arc(e.x,e.y,e.r,0,Math.PI*2);ctx.fill();ctx.stroke();

      const w=isBoss?96:(isElite?70:(isHealer?62:52)),h=6,x=e.x-w/2,y=e.y-e.r-14;
      ctx.globalAlpha=.9;ctx.fillStyle='rgba(255,255,255,.10)';ctx.fillRect(x,y,w,h);

      const hpPct=clamp(e.hp/e.hpMax,0,1);
      ctx.fillStyle=isBoss?'rgba(255,120,120,.9)'
        :(isElite?'rgba(220,180,255,.9)'
        :(isHealer?'rgba(140,190,255,.92)':'rgba(120,255,200,.9)'));
      ctx.fillRect(x,y,w*hpPct,h);

      if(isBoss){
        ctx.globalAlpha=.85;ctx.fillStyle='rgba(255,255,255,.65)';
        ctx.font='11px system-ui,"Noto Sans TC"';ctx.textAlign='center';ctx.textBaseline='bottom';
        ctx.fillText(`P${e.phase||1}`,e.x,y-2);
      }
      if(isHealer){
        ctx.globalAlpha=.85;ctx.fillStyle='rgba(255,255,255,.75)';
        ctx.font='11px system-ui,"Noto Sans TC"';ctx.textAlign='center';ctx.textBaseline='top';
        ctx.fillText(`ğŸ’™ ${Math.ceil(e.healCd)}s`,e.x,e.y+e.r+6);
      }
      ctx.restore();
    }

    // player bullets
    ctx.save();ctx.fillStyle='rgba(120,255,200,.95)';
    for(const b of pBullets){ctx.beginPath();ctx.arc(b.x,b.y,b.r,0,Math.PI*2);ctx.fill()}
    ctx.restore();

    // enemy bullets
    ctx.save();ctx.fillStyle='rgba(255,160,160,.92)';
    for(const b of eBullets){
      if(!b.beam){
        ctx.beginPath();ctx.arc(b.x,b.y,b.r,0,Math.PI*2);ctx.fill();
      }else{
        const ang=Math.atan2(b.vy,b.vx);
        const L=b.len||28, R=b.r||5;
        ctx.save();
        ctx.translate(b.x,b.y);
        ctx.rotate(ang);
        if(ctx.roundRect){
          ctx.beginPath();
          ctx.roundRect(-L/2, -R, L, R*2, R);
          ctx.fill();
        }else{
          ctx.beginPath();ctx.rect(-L/2, -R, L, R*2);ctx.fill();
          ctx.beginPath();ctx.arc(-L/2,0,R,0,Math.PI*2);ctx.fill();
          ctx.beginPath();ctx.arc(L/2,0,R,0,Math.PI*2);ctx.fill();
        }
        ctx.restore();
      }
    }
    ctx.restore();

    // player
    ctx.save();
    ctx.translate(player.x,player.y);

    if(hitIFrameT > 0){
      ctx.globalAlpha = 0.55 + 0.35*Math.sin(performance.now()/70);
    }

    if(buffs.burstT>0){
      ctx.save();
      const a = 0.25 + 0.15*Math.sin(performance.now()/90);
      ctx.globalAlpha = a;
      ctx.strokeStyle = 'rgba(255,140,140,.85)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(0,0,player.r+18,0,Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    ctx.fillStyle='rgba(255,255,255,.10)';ctx.strokeStyle='rgba(255,255,255,.22)';ctx.lineWidth=1.5;
    ctx.beginPath();ctx.moveTo(0,-player.r-2);ctx.lineTo(player.r+2,player.r+4);ctx.lineTo(-player.r-2,player.r+4);ctx.closePath();ctx.fill();ctx.stroke();

    if(player.shield>0){
      ctx.globalAlpha*=.85;ctx.strokeStyle='rgba(120,255,200,.45)';ctx.lineWidth=2;
      ctx.beginPath();ctx.arc(0,0,player.r+10,0,Math.PI*2);ctx.stroke();
      ctx.globalAlpha=1;
    }

    if(buffs.invulnT>0){
      ctx.globalAlpha=.55;ctx.strokeStyle='rgba(255,255,255,.65)';ctx.lineWidth=2;
      ctx.beginPath();ctx.arc(0,0,player.r+15,0,Math.PI*2);ctx.stroke();
    }
    ctx.restore();
  }

  // ---------- HUD sync ----------
  function syncHud(){
    $stage.textContent=`é—œå¡ ${state.stage}`;

    const hpPct=clamp(player.hp/player.hpMax,0,1);
    $hpFill.style.width=`${hpPct*100}%`;
    $hpNum.textContent=`${Math.floor(player.hp)}/${Math.floor(player.hpMax)}`;

    // shield always visible
    $hudShield.textContent=`ğŸ›¡ +${Math.floor(player.shield)}`;

    $hudCoins.textContent = `ğŸª™ ${state.coins}`;

    $lv.textContent=`LV ${state.level}`;
    const xpPct=clamp(state.xp/state.nextXp,0,1);
    $xpPct.textContent=`${Math.floor(xpPct*100)}%`;

    if(buffs.burstT>0) $cdBurst.textContent = `${Math.ceil(buffs.burstT)}s`;
    else if(skills.burst.cd>0) $cdBurst.textContent = `CD ${Math.ceil(skills.burst.cd)}s`;
    else $cdBurst.textContent = 'Ready';

    if(buffs.invulnT>0) $cdInvuln.textContent = `${Math.ceil(buffs.invulnT)}s`;
    else if(skills.invuln.cd>0) $cdInvuln.textContent = `CD ${Math.ceil(skills.invuln.cd)}s`;
    else $cdInvuln.textContent = 'Ready';

    $btnBurst.disabled  = !(canUseSkill('burst') && buffs.burstT<=0);
    $btnInvuln.disabled = !(canUseSkill('invuln') && buffs.invulnT<=0);

    $btnShop.disabled = lockedLandscape || !(mode==='play' || mode==='shop');
  }

  // ---------- Frame ----------
  let lastT=performance.now();
  function frame(t){
    const dt=Math.min(.033,(t-lastT)/1000);lastT=t;
    if(mode==='play' && !paused) update(dt);
    draw(); syncHud();
    requestAnimationFrame(frame);
  }

  // init
  setPadX(.5);
  spawnWave();
  syncOrientationLock();
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
