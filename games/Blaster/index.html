<!doctype html><html lang="zh-Hant"><head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover"/>
<title>Blaster</title>
<meta name="theme-color" content="#0b1220"/>
<style>
:root{
  color-scheme:dark;
  --appSafeTop:24px; --appSafeR:0px; --appSafeB:0px; --appSafeL:0px;
  --appExtraTop:10px; --appExtraBottom:10px;
  --gap:8px;
}
html,body{
  height:100%;margin:0;background:#0b1220;color:#e7eefc;
  font-family:system-ui,"Noto Sans TC",sans-serif;
  -webkit-user-select:none;user-select:none;
  touch-action:manipulation;overflow:hidden
}
body{position:fixed;inset:0}
.app{
  height:100svh;
  padding:
    calc(var(--appSafeTop) + var(--appExtraTop))
    calc(var(--appSafeR) + 10px)
    calc(var(--appSafeB) + var(--appExtraBottom))
    calc(var(--appSafeL) + 10px);
  display:flex;flex-direction:column;gap:var(--gap);box-sizing:border-box;
}
.hud{display:flex;flex-direction:column;gap:var(--gap);min-height:0}
.hudRow{
  display:flex;align-items:center;gap:var(--gap);
  overflow-x:auto;-webkit-overflow-scrolling:touch;scrollbar-width:none;
}
.hudRow::-webkit-scrollbar{display:none}
.hudRow2{justify-content:space-between}
.pill,button.pill{
  border-radius:999px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(255,255,255,.06);
  color:#e7eefc;
  padding:8px 10px;
  font-size:13px;
  line-height:1;
  white-space:nowrap;
  -webkit-tap-highlight-color:transparent
}
button.pill{cursor:pointer}
button.pill:active{transform:scale(.99)}
button.pill:disabled{opacity:.45;cursor:default}
#hudStage,#hudWave,#hudLv{min-width:66px;text-align:center}
#hudScore{min-width:82px;text-align:center}
.hpbar{
  flex:1 1 auto; min-width:0;
  display:flex;align-items:center;gap:8px;
  padding:8px 10px;border-radius:16px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.05);
}
.hpbar .label{opacity:.85;font-weight:800;letter-spacing:.2px}
.hpbar .track{
  flex:1 1 auto; min-width:90px; max-width:240px;
  height:12px;border-radius:999px;
  background:rgba(255,255,255,.10);
  overflow:hidden;border:1px solid rgba(255,255,255,.10)
}
.hpbar .fill{height:100%;width:50%;background:rgba(120,255,200,.95)}
.hpbar .num{opacity:.85;font-variant-numeric:tabular-nums;min-width:86px;text-align:right}
.main{flex:1;min-height:0;display:flex;flex-direction:column;gap:var(--gap)}
.boardWrap{
  flex:1;min-height:0;
  border-radius:18px;border:1px solid rgba(255,255,255,.12);
  background:radial-gradient(1200px 800px at 50% 0%, rgba(90,120,255,.10), transparent 60%),rgba(255,255,255,.03);
  overflow:hidden;position:relative
}
canvas{width:100%;height:100%;display:block}
.touchpad{
  flex:0 0 auto;height:max(82px,12.5svh);
  border-radius:18px;border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.04);
  position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent
}
.touchpad .hint{position:absolute;inset:auto 0 10px 0;text-align:center;font-size:14px;opacity:.75;pointer-events:none}
.touchpad .bar{position:absolute;left:10px;right:10px;top:16px;bottom:16px;border-radius:14px;border:1px dashed rgba(255,255,255,.18);opacity:.7}
.touchpad .thumb{position:absolute;top:50%;width:46px;height:46px;transform:translate(-50%,-50%);border-radius:999px;border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.08);box-shadow:0 8px 30px rgba(0,0,0,.35);pointer-events:none}
.specials{
  flex:0 0 auto;
  display:flex;
  gap:8px;
  align-items:center;
  overflow-x:auto;
  -webkit-overflow-scrolling:touch;
  scrollbar-width:none;
  padding-bottom:max(env(safe-area-inset-bottom), 6px);
}
.specials::-webkit-scrollbar{display:none}
.sbtn{
  flex:0 0 auto;
  display:flex;
  align-items:center;
  gap:8px;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(255,255,255,.06);
  color:#e7eefc;
  -webkit-tap-highlight-color:transparent;
  white-space:nowrap;
}
.sbtn:active{transform:scale(.99)}
.sbtn[disabled]{opacity:.45;cursor:default}
.sbtn .ico{font-size:16px;line-height:1}
.sbtn .name{font-weight:900;letter-spacing:.2px}
.sbtn .cnt{margin-left:6px;opacity:.9;font-variant-numeric:tabular-nums}
.overlay{position:fixed;inset:0;background:rgba(0,0,0,.58);display:none;align-items:center;justify-content:center;padding:16px;z-index:50}
.overlay.show{display:flex}
.panel{width:min(720px,92vw);border-radius:18px;border:1px solid rgba(255,255,255,.14);background:rgba(15,22,40,.92);padding:16px;box-shadow:0 18px 70px rgba(0,0,0,.55)}
.panel h2{margin:0 0 10px;font-size:18px;letter-spacing:.2px}
.opts{display:grid;grid-template-columns:1fr;gap:10px}
@media (min-width:720px){.opts{grid-template-columns:1fr 1fr 1fr}}
.opt{border-radius:16px;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06);padding:14px;cursor:pointer;-webkit-tap-highlight-color:transparent}
.opt:active{transform:scale(.99)}
.opt .t{font-weight:900;margin-bottom:6px}.opt .d{opacity:.78;font-size:13px;line-height:1.4}
.panel .sub{opacity:.82;font-size:13px;line-height:1.35;margin:8px 0 14px}
.panel .row{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
.panel .row .pill{padding:10px 12px}
.toast{position:absolute;left:50%;top:14px;transform:translateX(-50%);padding:10px 12px;border-radius:999px;border:1px solid rgba(255,255,255,.14);background:rgba(0,0,0,.35);font-size:13px;opacity:.9;display:none;pointer-events:none}
.toast.show{display:block}
</style></head>

<body>
<div class="app">
  <div class="hud">
    <div class="hudRow">
      <button class="pill" id="btnBack">‚Üê Back</button>
      <span class="pill" id="hudStage">ÈóúÂç° 1</span>
      <span class="pill" id="hudWave">Ê≥¢Ê¨° 1</span>
      <span class="pill" id="hudLv">Á≠âÁ¥ö 1</span>
      <span class="pill" id="hudScore">ÂàÜÊï∏ 0</span>
    </div>

    <div class="hudRow hudRow2">
      <div class="hpbar">
        <span class="label">HP</span>
        <div class="track"><div class="fill" id="hpFill"></div></div>
        <span class="num" id="hpNum">300/300</span>
      </div>
      <button class="pill" id="btnPause">Êö´ÂÅú</button>
    </div>
  </div>

  <div class="main">
    <div class="boardWrap" id="boardWrap">
      <canvas id="c"></canvas>
      <div class="toast" id="toast">Paused</div>
    </div>

    <div class="touchpad" id="touchpad" aria-label="touchpad">
      <div class="bar"></div>
      <div class="thumb" id="thumb" style="left:50%"></div>
      <div class="hint">Â∑¶Âè≥ÊãñÊõ≥ÔºùÁßªÂãïÔºàËá™ÂãïÂ∞ÑÊìäÔºâ</div>
    </div>

    <div class="specials" id="specials">
      <button class="sbtn" id="btnBomb"><span class="ico">üí£</span><span class="name">Bomb</span><span class="cnt" id="cntBomb">x3</span></button>
      <button class="sbtn" id="btnInvuln"><span class="ico">üõ°</span><span class="name">ÁÑ°Êïµ</span><span class="cnt" id="cntInvuln">x3</span></button>
      <button class="sbtn" id="btnEMP"><span class="ico">‚ö°</span><span class="name">EMP</span><span class="cnt" id="cntEMP">x2</span></button>
      <button class="sbtn" id="btnArmor"><span class="ico">üéØ</span><span class="name">Á©øÁî≤</span><span class="cnt" id="cntArmor">x2</span></button>
      <button class="sbtn" id="btnHeal"><span class="ico">‚úö</span><span class="name">Ê≤ªÁôÇ</span><span class="cnt" id="cntHeal">x2</span></button>
    </div>
  </div>
</div>

<div class="overlay" id="overlay">
  <div class="panel">
    <h2 id="panelTitle">ÂçáÁ¥öÔºöÈÅ∏‰∏ÄÂÄã</h2>
    <div class="sub" id="panelSub" style="display:none"></div>
    <div class="opts" id="opts"></div>
    <div class="row" id="panelRow" style="display:none"></div>
  </div>
</div>

<script>
(()=>{ // setup
  // ---------- Safe-area / Dynamic Island ----------
  function isIOS(){
    return /iP(hone|ad|od)/.test(navigator.platform) || (navigator.userAgent.includes('Mac') && 'ontouchend' in document);
  }
  function readEnvInsetPx(side){
    const d=document.createElement('div');
    d.style.cssText=`position:fixed;left:0;top:0;visibility:hidden;pointer-events:none;height:env(safe-area-inset-${side});width:0;`;
    document.body.appendChild(d);
    const px=d.getBoundingClientRect().height;
    d.remove();
    return px||0;
  }
  function isDynamicIslandSize(){
    const w=Math.min(screen.width, screen.height);
    const h=Math.max(screen.width, screen.height);
    const key=`${w}x${h}`;
    return new Set(['393x852','430x932','402x874','440x956']).has(key);
  }
  function applySafeArea(){
    const root=document.documentElement;
    let top=readEnvInsetPx('top');
    let right=readEnvInsetPx('right');
    let bottom=readEnvInsetPx('bottom');
    let left=readEnvInsetPx('left');

    const standalone =
      (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) ||
      (navigator.standalone === true);

    if(isIOS() && top < 10) top = isDynamicIslandSize() ? 54 : 44;
    else top = Math.max(top, 24);

    const extraTop = standalone ? 14 : 10;
    const extraBottom = standalone ? 4 : 8;

    root.style.setProperty('--appSafeTop', `${top}px`);
    root.style.setProperty('--appSafeR', `${right}px`);
    root.style.setProperty('--appSafeB', `${bottom}px`);
    root.style.setProperty('--appSafeL', `${left}px`);
    root.style.setProperty('--appExtraTop', `${extraTop}px`);
    root.style.setProperty('--appExtraBottom', `${extraBottom}px`);
  }
  applySafeArea();
  window.addEventListener('resize', applySafeArea, {passive:true});
  window.addEventListener('orientationchange', applySafeArea, {passive:true});
  document.addEventListener('visibilitychange', ()=>{ if(!document.hidden) applySafeArea(); }, {passive:true});
  if(window.visualViewport){
    visualViewport.addEventListener('resize', applySafeArea, {passive:true});
    visualViewport.addEventListener('scroll', applySafeArea, {passive:true});
  }

  // ---------- Canvas ----------
  const wrap=document.getElementById('boardWrap'),canvas=document.getElementById('c'),ctx=canvas.getContext('2d',{alpha:true});
  let W=0,H=0;
  function resize(){
    const r=wrap.getBoundingClientRect(),dpr=Math.min(2,window.devicePixelRatio||1);
    canvas.width=Math.floor(r.width*dpr);canvas.height=Math.floor(r.height*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);W=r.width;H=r.height;
  }
  window.addEventListener('resize',resize);resize();

  // ---------- HUD refs ----------
  const $stage=document.getElementById('hudStage'),$wave=document.getElementById('hudWave'),$lv=document.getElementById('hudLv'),
        $score=document.getElementById('hudScore'),$hpFill=document.getElementById('hpFill'),$hpNum=document.getElementById('hpNum'),
        $btnPause=document.getElementById('btnPause'),$toast=document.getElementById('toast'),$btnBack=document.getElementById('btnBack');

  // overlay refs
  const overlay=document.getElementById('overlay');
  const opts=document.getElementById('opts');
  const $panelTitle=document.getElementById('panelTitle');
  const $panelSub=document.getElementById('panelSub');
  const $panelRow=document.getElementById('panelRow');

  // specials refs
  const $btnBomb=document.getElementById('btnBomb');
  const $btnInvuln=document.getElementById('btnInvuln');
  const $btnEMP=document.getElementById('btnEMP');
  const $btnArmor=document.getElementById('btnArmor');
  const $btnHeal=document.getElementById('btnHeal');
  const $cntBomb=document.getElementById('cntBomb');
  const $cntInvuln=document.getElementById('cntInvuln');
  const $cntEMP=document.getElementById('cntEMP');
  const $cntArmor=document.getElementById('cntArmor');
  const $cntHeal=document.getElementById('cntHeal');

  $btnBack.addEventListener('click',()=>{
    if(document.referrer){
      try{const ref=new URL(document.referrer);if(ref.origin===location.origin){history.back();return}}catch(_){}
    }
    location.href='./games/';
  });

  let paused=false;
  let mode='play'; // play | levelup | gameover
  $btnPause.addEventListener('click',()=>{
    if(mode!=='play') return;
    paused=!paused;
    $btnPause.textContent=paused?'ÁπºÁ∫å':'Êö´ÂÅú';
    $toast.textContent=paused?'Paused':'';
    $toast.classList.toggle('show',paused);
    if(!paused) lastT=performance.now();
  });

  // ---------- Utils ----------
  const rand=(a,b)=>a+Math.random()*(b-a);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const dist2=(ax,ay,bx,by)=>{const dx=ax-bx,dy=ay-by;return dx*dx+dy*dy};

  // ---------- Touchpad ----------
  const pad=document.getElementById('touchpad'),thumb=document.getElementById('thumb');
  let padActive=false,padX=.5;

  // ---------- Constants ----------
  const BASE_HP=300;
  const SPREAD_CAP=5;
  const PIERCE_CAP=5;

  const BULLET_R_MIN=3;
  const BULLET_R_BASE=4;
  const BULLET_R_CAP=8;
  const BULLET_R_UPG_CAP=7;

  function bulletSizeDmgMul(r){
    const dr = Math.max(0, r - BULLET_R_BASE);
    return clamp(1 - dr*0.06, 0.70, 1.00);
  }
  // Â§ßÂΩàÈ´îÔºöÊ∏ÖÂΩàÁï•Âº∑Ôºà‰ΩÜ‰∏çË™áÂºµÔºâ
  function bulletClearMul(r){
    const dr = Math.max(0, r - BULLET_R_BASE);
    return clamp(1 + dr*0.05, 1.00, 1.25);
  }

  // ‚úÖ ÈÄôË£°ÊòØÈóúÈçµÔºöÊó©ÊúüË¶Å„ÄåÂ•ΩÊ∏Ö„ÄçÔºåÂæåÊúüÊâç„ÄåÁ°¨„ÄçÔºõÂ∞ÅÈ†ÇÈÅøÂÖçÂ§±Êéß
  function enemyBulletHpByStage(stage){
    if(stage < 6)  return 8;   // ÂâçÊúü‰∏ÄÁôºÂ∞±ËÉΩÊ∏ÖÔºàdmg‚âà12Ôºâ
    if(stage < 14) return 10;
    if(stage < 20) return 14;
    if(stage < 26) return 18;
    return 22;
  }

  function beamChanceByStage(stage, isElite){
    if(stage < 16) return 0;
    const base = stage < 20 ? 0.06 : (stage < 26 ? 0.10 : 0.14);
    return Math.min(0.20, base + (isElite ? 0.06 : 0));
  }

  // ---------- State ----------
  const state={stage:1,wave:1,score:0,xp:0,level:1,nextXp:60,waveClearCooldown:0,waveInProgress:false,bossEveryWaves:5};
  const player={
    x:W*.5,y:0,r:14,
    hp:BASE_HP,hpMax:BASE_HP,
    moveSpeed:520,fireRate:6.2,dmg:26,bulletSpeed:820,
    spread_perm:1, pierce_perm:2,
    shield:0,shieldMax:0,
    regen:0, xpGainMul:1.0, bulletR:BULLET_R_BASE
  };

  const buffs={rapid:0, magnet:0, spreadBonusT:0, pierceBonusT:0, invulnT:0, empT:0, armorT:0};
  let hitIFrameT = 0;
  const special={
    bomb:{count:3, cd:0},
    invuln:{count:3, cd:0},
    emp:{count:2, cd:0},
    armor:{count:2, cd:0},
    heal:{count:2, cd:0},
  };

  let pBullets=[],eBullets=[],enemies=[],drops=[],particles=[];

  function setPadX(nx){
    padX=Math.max(0,Math.min(1,nx));
    thumb.style.left=`${padX*100}%`;
    player.x=lerp(player.x,padX*W,1);
  }
  function pointerToPadX(e){const r=pad.getBoundingClientRect();return (e.clientX-r.left)/r.width}
  pad.addEventListener('pointerdown',e=>{e.preventDefault();pad.setPointerCapture(e.pointerId);padActive=true;setPadX(pointerToPadX(e))});
  pad.addEventListener('pointermove',e=>{if(!padActive)return;e.preventDefault();setPadX(pointerToPadX(e))});
  pad.addEventListener('pointerup',e=>{padActive=false;try{pad.releasePointerCapture(e.pointerId)}catch(_){}});pad.addEventListener('pointercancel',()=>padActive=false);

  function enemyHoldY(){return clamp(H*.18,110,190)}

  // ---------- Balance ----------
  function stageDifficultyMul(stage){
    const early = 1 + Math.max(0, stage-1) * 0.035;
    const mid   = (stage>=12) ? (1 + (stage-12) * 0.025) : 1;
    const late  = (stage>=20) ? (1 + (stage-20) * 0.030) : 1;
    return Math.min(2.6, early * mid * late);
  }

  function waveConfig(stage,wave){
    const mul = stageDifficultyMul(stage);
  
    // 1) Êï∏ÈáèÊàêÈï∑ÊîæÁ∑©Ôºå‰∏¶Èôç‰Ωé‰∏äÈôêÔºàÂâç‰∏≠ÊúüÊõ¥ÂèØÊéßÔºâ
    const baseCount = 5 + Math.floor((stage-1)*0.95) + Math.floor((wave-1)*0.75);
    const count = clamp(baseCount, 5, 14);
  
    // 2) HPÔºöÂèØ‰ª•Èï∑Ôºå‰ΩÜ‰∏çË¶ÅÂêåÊôÇËÆìÂ∞ÑÈÄü+ÂÇ∑ÂÆ≥‰πüÊö¥Ë°ù
    const hp = (24 + stage*7 + wave*5) * mul;
  
    // 3) Â∞ÑÈÄüÔºöÊää stage/wave ÁöÑ‰øÇÊï∏Èôç‰∏ã‰æÜÔºàÂΩàÂπïÂØÜÂ∫¶‰∏ªÂõ†Ôºâ
    const fire = (0.52 + stage*0.055 + wave*0.055) * clamp(1 + (stage>=14?0.06:0), 1, 1.18);
  
    // 4) Â≠êÂΩàÈÄüÂ∫¶ÔºöÁï•ÈôçÔºåÁµ¶Áé©ÂÆ∂ÂèçÊáâÁ©∫Èñì
    const bullet = (245 + stage*15 + wave*14) * clamp(1 + (stage>=16?0.05:0), 1, 1.25);
  
    // 5) ÂÇ∑ÂÆ≥ÔºöÂâç 10 ÈóúÊõ¥Ê∫´ÂíåÔºåÂæåÈù¢ÊâçÊãâ‰∏äÂéª
    const dmgBase = (5.5 + stage*0.62 + wave*0.50);
    const dmg = dmgBase * clamp(1 + (stage>=12?0.08:0), 1, 1.35);
  
    // 6) Êï£Â∞Ñ/Á©øÈÄèÁöÑÊ©üÁéáÔºöÊôö‰∏ÄÈªûÂá∫Áèæ„ÄÅ‰∏äÈôê‰Ωé‰∏ÄÈªû
    const mobSpreadChance = clamp((stage-10)*0.025 + (wave-4)*0.030, 0, 0.35);
    const mobPierceChance = clamp((stage-12)*0.020 + (wave-5)*0.025, 0, 0.30);
  
    // 7) ËèÅËã±ÔºöÊôöÈªûÊèêÈ´òÔºà‰∏çÁÑ∂Á¨¨ 5 ÈóúÂÉèÂú®ÊâìÂ≠£Â†±Ôºâ
    const eliteChance = clamp((stage-12)*0.035 + (stage>=22?0.12:0), 0, 0.45);
  
    return {count,hp,fire,bullet,dmg,mobSpreadChance,mobPierceChance,eliteChance};
  }

  // ---------- Spawning ----------
  function spawnMob(x,y,targetY,cfg,meta={}){
    const isStrafe=Math.random()<(0.38+state.stage*0.03);
    const elite = !!meta.elite;
    const hp = cfg.hp * (elite? 2.3 : 1.0);
    const r  = elite ? 18 : 15;
    return {
      type: elite?'elite':'mob',
      x,y,targetY,r,
      hp,hpMax:hp,
      fireCd:rand(.35,1.15),
      fireRate: cfg.fire * (elite?1.12:1.00),
      bulletSpeed: cfg.bullet * (elite?1.08:1.00),
      bulletDmg: cfg.dmg * (elite?1.20:1.00),
      evoSpread: meta.evoSpread||false,
      evoPierce: meta.evoPierce||false,
      strafeAmp:isStrafe?rand(45, elite?150:120):0,
      strafeSpd:isStrafe?rand(.85, elite?2.35:1.85):0,
      strafePhase:rand(0,Math.PI*2),
      hitFlash:0
    };
  }

  function spawnWave(){
    enemies.length=0;eBullets.length=0;state.waveInProgress=true;
    const cfg=waveConfig(state.stage,state.wave),holdY=enemyHoldY(),lanes=cfg.count;

    const hasElite = Math.random() < cfg.eliteChance;
    const eliteLane = hasElite ? Math.floor(Math.random()*lanes) : -1;

    for(let i=0;i<lanes;i++){
      const x=(i+1)*(W/(lanes+1));
      const evoSpread = Math.random() < cfg.mobSpreadChance;
      const evoPierce = Math.random() < cfg.mobPierceChance;

      if(i===eliteLane){
        enemies.push(spawnMob(x,-40-i*18,holdY+rand(-18,18),cfg,{elite:true,evoSpread:true,evoPierce:true}));
      }else{
        enemies.push(spawnMob(x,-40-i*18,holdY+rand(-18,18),cfg,{elite:false,evoSpread,evoPierce}));
      }
    }
  }

  function spawnAdds(count=4,power=.90){
    const cfg=waveConfig(state.stage,state.wave),holdY=enemyHoldY()+rand(8,22);
    for(let i=0;i<count;i++){
      const x=rand(40,W-40);
      const evoSpread = Math.random() < cfg.mobSpreadChance*0.85;
      const evoPierce = Math.random() < cfg.mobPierceChance*0.85;
      const m = spawnMob(x,-60-i*24,holdY+rand(-14,14),cfg,{elite:false,evoSpread,evoPierce});
      m.hp*=power; m.hpMax=m.hp;
      m.fireRate*= (1.05+rand(-.05,.12));
      m.bulletSpeed*=(.95+rand(-.03,.08));
      m.bulletDmg*=(.95+rand(-.05,.10));
      m.r=14;
      enemies.push(m);
    }
  }

  function spawnRepairDrone(boss){
    const hp = 120 + state.stage*14;
    enemies.push({
      type:'drone',
      x: boss.x + rand(-120,120),
      y: boss.y + boss.r + 18,
      targetY: boss.y + boss.r + 46,
      r: 14,
      hp, hpMax: hp,
      fireCd: 999,
      healT: 3.6,
      healPct: 0.075,
      bossRef: boss,
      hitFlash:0,
      strafeAmp: rand(40,90),
      strafeSpd: rand(1.4,2.4),
      strafePhase: rand(0,Math.PI*2),
    });
    toastMsg('üß∞ Boss Âè¨Âñö‰øÆÂæ© Drone',0.85);
  }

  function spawnBoss(){
    const holdY=enemyHoldY()-12,
          hp=(650+state.stage*170)*stageDifficultyMul(state.stage),
          baseSpd=240+state.stage*12;

    const boss={
      type:'boss',x:W*.5,y:-100,targetY:holdY,r:30,hp,hpMax:hp,
      bulletSpeed:baseSpd,bulletDmg:12+state.stage*2.0,
      strafeAmp:240,strafeSpd:1.05+state.stage*0.06,strafePhase:0,
      phase:1,ringCd:1.0,spiralCd:0.35,summonCd:999,
      burstCd:0.55,burstLeft:0,burstGap:0.10,burstGapCd:0,
      spin:0,hitFlash:0,
      medCd: (state.stage>=20)? (6.8+Math.random()*3.5) : 999
    };
    enemies.push(boss);
    toastMsg('Boss ÂÖ•Â†¥',0.9);
  }

  function nextWave(){state.wave+=1;state.waveClearCooldown=.55;state.waveInProgress=false}
  function nextStage(){state.stage+=1;state.wave=1;state.waveClearCooldown=.85;state.waveInProgress=false}

  // ---------- Drops / Buffs ----------
  const DROP_TYPES=[
    {key:'heal',w:22},
    {key:'shield',w:18},
    {key:'rapid',w:16},
    {key:'spread',w:14},
    {key:'pierce',w:12},
    {key:'magnet',w:10},
  ];
  function pickDrop(){
    const total=DROP_TYPES.reduce((s,a)=>s+a.w,0);
    let r=Math.random()*total;
    for(const it of DROP_TYPES){r-=it.w;if(r<=0)return it.key}
    return 'heal';
  }
  function maybeDrop(x,y,isBoss=false){
    const p=isBoss?.92:.22;
    if(Math.random()>p) return;
    drops.push({x,y,r:10,vy:rand(70,140),type:pickDrop(),life:12});
  }
  function applyDrop(type){
    if(type==='heal'){player.hp=clamp(player.hp+35,0,player.hpMax);toastMsg('HP +35')}
    else if(type==='shield'){player.shieldMax=Math.max(player.shieldMax,30);player.shield=clamp(player.shield+30,0,player.shieldMax);toastMsg('Shield +30')}
    else if(type==='rapid'){buffs.rapid=Math.max(buffs.rapid,7.0);toastMsg('Rapid Fire!')}
    else if(type==='spread'){buffs.spreadBonusT=Math.max(buffs.spreadBonusT,7.5);toastMsg('Spread +1ÔºàÈôêÊôÇÔºâ')}
    else if(type==='pierce'){buffs.pierceBonusT=Math.max(buffs.pierceBonusT,7.5);toastMsg('Pierce +1ÔºàÈôêÊôÇÔºâ')}
    else if(type==='magnet'){buffs.magnet=Math.max(buffs.magnet,9.0);toastMsg('Magnet')}
  }

  // ---------- Specials ----------
  function canUseSpecial(x){return mode==='play' && !paused && special[x].count>0 && special[x].cd<=0}
  function useBomb(){
    if(!canUseSpecial('bomb')) return;
    special.bomb.count--; special.bomb.cd=0.6;

    const cleared=eBullets.length; eBullets.length=0;

    let killed=0; let bossHit=false;
    for(const e of enemies){
      if(e.type==='boss'){
        const dmg=e.hpMax*0.20;
        e.hp=Math.max(0,e.hp-dmg);
        bossHit=true;
        addBurst(e.x,e.y,18);
      }else if(e.type==='drone'){
        e.hp=0; killed++;
        addBurst(e.x,e.y,10);
      }else{
        e.hp=0; killed++;
        maybeDrop(e.x,e.y,false);
        addBurst(e.x,e.y,10);
      }
    }
    toastMsg(`üí£ Bomb! Ê∏ÖÂΩà${cleared} ÊìäÁ†¥${killed}${bossHit?' Boss-20%':''}`,1.0);
  }
  function useInvuln(){
    if(!canUseSpecial('invuln')) return;
    special.invuln.count--; special.invuln.cd=0.6;
    buffs.invulnT=Math.max(buffs.invulnT,10.0);
    toastMsg('üõ° ÁÑ°Êïµ 10 Áßí',0.9);
  }
  function useEMP(){
    if(!canUseSpecial('emp')) return;
    special.emp.count--; special.emp.cd=0.6;
    buffs.empT=Math.max(buffs.empT,3.0);
    toastMsg('‚ö° EMP',0.8);
  }
  function useArmor(){
    if(!canUseSpecial('armor')) return;
    special.armor.count--; special.armor.cd=0.6;
    buffs.armorT=Math.max(buffs.armorT,5.0);
    toastMsg('üéØ Á©øÁî≤ 5 Áßí',0.9);
  }
  function useHeal(){
    if(!canUseSpecial('heal')) return;
    special.heal.count--; special.heal.cd=0.6;
    const add=Math.floor(player.hpMax*0.40);
    player.hp=clamp(player.hp+add,0,player.hpMax);
    toastMsg(`‚úö Ê≤ªÁôÇ +${add}`,0.9);
  }

  $btnBomb.addEventListener('click',useBomb);
  $btnInvuln.addEventListener('click',useInvuln);
  $btnEMP.addEventListener('click',useEMP);
  $btnArmor.addEventListener('click',useArmor);
  $btnHeal.addEventListener('click',useHeal);

  // ---------- Level-up ----------
  const UPGRADES=[
    {key:'dmg',t:'ÁÅ´ÂäõÊèêÂçá',d:'ÂÇ∑ÂÆ≥ +20%'},
    {key:'firerate',t:'Â∞ÑÈÄüÊèêÂçá',d:'Â∞ÑÈÄü +18%'},
    {key:'hp',t:'Êì¥ÂÖÖË£ùÁî≤',d:'HP ‰∏äÈôê +30ÔºåÂõûÊªø'},
    {key:'speed',t:'Ê©üÂãïÊèêÂçá',d:'ÁßªÂãïÈÄüÂ∫¶ +16%'},
    {key:'pierce_perm',t:'Ê∞∏‰πÖÁ©øÈÄè',d:'Á©øÈÄè +1'},
    {key:'spread_perm',t:'Ê∞∏‰πÖÊï£Â∞Ñ',d:'Êï£Â∞Ñ +1'},
    {key:'shield_cap',t:'Ë≠∑ÁõæÊì¥ÂÆπ',d:'Ë≠∑Áõæ‰∏äÈôê +30Ôºå‰∏¶ÂõûÊªø'},
    {key:'regen',t:'Ëá™Âãï‰øÆÂæ©',d:'ÊØèÁßíÂõûÂæ© +0.7'},
    {key:'xp_gain',t:'Â≠∏ÁøíÂä†ÈÄü',d:'Áç≤Âæó XP +15%'},
    {key:'bullet_size',t:'ÂΩàÈ´îÂ¢ûÂº∑',d:'Â≠êÂΩàÊõ¥Â§ß'},
  ];
  function canPickUpgrade(key){
    if(key==='pierce_perm') return player.pierce_perm < PIERCE_CAP;
    if(key==='spread_perm') return player.spread_perm < SPREAD_CAP;
    if(key==='bullet_size') return player.bulletR < BULLET_R_UPG_CAP;
    return true;
  }
  function openLevelUp(){
    mode='levelup';
    paused=true;
    $btnPause.textContent='ÁπºÁ∫å';
    $toast.textContent='Level Up';
    $toast.classList.add('show');

    overlay.classList.add('show');
    $panelTitle.textContent='ÂçáÁ¥öÔºöÈÅ∏‰∏ÄÂÄã';
    $panelSub.style.display='none';
    $panelRow.style.display='none';
    $panelRow.innerHTML='';
    opts.innerHTML='';

    const filtered=UPGRADES.filter(u=>canPickUpgrade(u.key));
    const pool=[...filtered];
    const picks=[];
    const guardFillers=['regen','xp_gain','bullet_size','dmg','firerate','speed'];

    while(picks.length<3 && pool.length){
      const i=Math.floor(Math.random()*pool.length);
      picks.push(pool.splice(i,1)[0]);
    }
    while(picks.length<3){
      const k=guardFillers[picks.length % guardFillers.length];
      const u=UPGRADES.find(x=>x.key===k);
      if(u && !picks.some(p=>p.key===u.key) && canPickUpgrade(u.key)) picks.push(u);
      else break;
    }

    for(const u of picks){
      const el=document.createElement('div');
      el.className='opt';
      el.innerHTML=`<div class="t">${u.t}</div><div class="d">${u.d}</div>`;
      el.addEventListener('click',()=>{
        applyUpgrade(u.key);
        overlay.classList.remove('show');
        mode='play';
        paused=false;
        $btnPause.textContent='Êö´ÂÅú';
        $toast.classList.remove('show');
        lastT=performance.now();
      });
      opts.appendChild(el);
    }
  }
  function applyUpgrade(key){
    if(key==='dmg') player.dmg*=1.20;
    else if(key==='firerate') player.fireRate*=1.18;
    else if(key==='hp'){player.hpMax+=30;player.hp=player.hpMax}
    else if(key==='speed') player.moveSpeed*=1.16;
    else if(key==='pierce_perm') player.pierce_perm=Math.min(PIERCE_CAP, player.pierce_perm+1);
    else if(key==='spread_perm') player.spread_perm=Math.min(SPREAD_CAP, player.spread_perm+1);
    else if(key==='shield_cap'){player.shieldMax+=30;player.shield=player.shieldMax}
    else if(key==='regen') player.regen+=0.7;
    else if(key==='xp_gain') player.xpGainMul*=1.15;
    else if(key==='bullet_size') player.bulletR = clamp(player.bulletR+1, BULLET_R_MIN, BULLET_R_CAP);
  }
  function addXp(xp){
    xp*=player.xpGainMul;
    state.xp+=xp;
    while(state.xp>=state.nextXp){
      state.xp-=state.nextXp;
      state.level+=1;
      state.nextXp=Math.floor(state.nextXp*1.22+12);
      openLevelUp();
    }
  }

  // ---------- Combat ----------
  function enemyBulletCap(){return enemies.some(e=>e.type==='boss')?260:140}

  let fireAcc=0;
  function spreadTotal(){ return player.spread_perm + (buffs.spreadBonusT>0?1:0); }
  function pierceTotal(){ return player.pierce_perm + (buffs.pierceBonusT>0?1:0); }

  function shotsFromSpread(s){ return 1 + clamp(s,0,4); }
  function spreadDmgMul(n){
    if(n<=1) return 1;
    if(n===2) return .80;
    if(n===3) return .68;
    if(n===4) return .58;
    return .50;
  }
  function shotVXPattern(n){
    if(n===1) return [0];
    if(n===2) return [-120,120];
    if(n===3) return [-160,0,160];
    if(n===4) return [-210,-70,70,210];
    return [-240,-120,0,120,240];
  }
  function shoot(dt){
    const rate=player.fireRate*(buffs.rapid>0?1.18:1.0);
    fireAcc+=dt*rate;
    while(fireAcc>=1){fireAcc-=1;spawnPlayerShot()}
  }

  function spawnPlayerShot(){
    const s=spreadTotal();
    const n=shotsFromSpread(s);

    const r = clamp(player.bulletR, BULLET_R_MIN, BULLET_R_CAP);
    const dmg = player.dmg * spreadDmgMul(n) * bulletSizeDmgMul(r);

    const vxArr=shotVXPattern(n);
    const pr=pierceTotal();
    const baseY=player.y-player.r-6;

    // ‚úÖ ÊîîÊà™Ê¨°Êï∏ÔºöÈÅøÂÖç Boss ÂΩàÂπïÊää‰Ω†ÁÅ´ÂäõÂÖ®ÂêÉÊéâ
    const clashLeftBase = ((r>=6)?2:1) + Math.min(2, pr>0 ? 1 : 0);

    for(const vx of vxArr){
      pBullets.push({x:player.x,y:baseY,r,vx,vy:-player.bulletSpeed,dmg,pierce:pr,alive:true, clashLeft:clashLeftBase});
    }
  }

  function enemyShoot(e,ang,sMul=1,dMul=1,meta={}){
    if(eBullets.length>=enemyBulletCap())return;
    const empSpdMul=(buffs.empT>0)?0.55:1.0;
    let spd=(e.bulletSpeed??300)*sMul*empSpdMul;

    const isBeam = !!meta.beam;
    const r = clamp(meta.r ?? (isBeam?5:4), 3, 10);
    const pierce = meta.pierce ?? 0;

    // ‚úÖ Boss/ËèÅËã±ÂΩàÔºöÊäµÈä∑ HP ÂèØÁ®çÂæÆ‰∏çÂêåÔºàÈÅøÂÖçÊó©Êúü Boss ÂΩàÂπïÈêµÊùøÔºâ
    const baseHp = enemyBulletHpByStage(state.stage);
    const hp = isBeam ? 1 : (meta.hp ?? baseHp);

    const len = isBeam ? (meta.len ?? (state.stage>=26?34:28)) : 0;

    eBullets.push({x:e.x,y:e.y+e.r+4,r,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,dmg:(e.bulletDmg??8)*dMul,alive:true,pierce,hp,beam:isBeam,len});
  }

  function mobShoot(e){
    if(buffs.empT>0) return;

    const ang=Math.atan2(player.y-e.y,player.x-e.x);

    const evoS = e.evoSpread;
    const evoP = e.evoPierce;

    const en2=(state.stage>=3||state.wave>=4);
    const en3=(state.stage>=5||state.wave>=6);
    const enLate=(state.stage>=12);
    const enBrutal=(state.stage>=20);

    const isElite = (e.type==='elite');
    const useBeam = Math.random() < beamChanceByStage(state.stage, isElite);

    if(isElite){
      const wide = (enLate && Math.random()<0.22) ? 5 : 3;
      const spread = (wide===5)?0.26:0.18;
      const lanes = wide;
      for(let i=0;i<lanes;i++){
        const t=(i-(lanes-1)/2)/(((lanes-1)/2)||1);
        enemyShoot(e,ang+t*spread,1.0,0.98,{r: (enBrutal?5:4), pierce: evoP?1:0, beam: useBeam, len: useBeam ? (enBrutal?34:28) : 0});
      }
      return;
    }

    if(evoS && (enLate || Math.random()<0.55)){
      const lanes = enBrutal?4:3;
      const spread = enBrutal?0.22:0.18;
      for(let i=0;i<lanes;i++){
        const t=(i-(lanes-1)/2)/(((lanes-1)/2)||1);
        enemyShoot(e,ang+t*spread,1.0,0.95,{r: enBrutal?5:4, pierce: evoP?1:0, beam: useBeam, len: useBeam ? (enBrutal?32:26) : 0});
      }
      return;
    }

    if(en3&&Math.random()<.22){
      for(const da of [-.22,0,.22]) enemyShoot(e,ang+da,1.0,.92,{pierce:evoP?1:0, beam:useBeam, len: useBeam?26:0});
    }else if(en2&&Math.random()<.35){
      for(const da of [-.16,.16]) enemyShoot(e,ang+da,1.0,.95,{pierce:evoP?1:0, beam:useBeam, len: useBeam?26:0});
    }else{
      enemyShoot(e,ang,1.0,1.0,{pierce:evoP?1:0, beam:useBeam, len: useBeam?26:0});
    }
  }

  function bossTick(e,dt){
    if(buffs.empT>0) return;

    const r=e.hp/e.hpMax;
    const newPhase=(r<=.40)?3:(r<=.70?2:1);
    if(newPhase!==e.phase){
      e.phase=newPhase;
      if(e.phase===2){toastMsg('BossÔºöPhase 2',.7);e.ringCd=.90;e.spiralCd=.40}
      else if(e.phase===3){toastMsg('BossÔºöPhase 3',.7);e.summonCd=1.3+Math.random()*1.0;e.ringCd=.70;e.spiralCd=.28;e.burstCd=.55}
    }
    const spdMul=(e.phase===1?0.96:(e.phase===2?1.00:1.05));
    const dmgMul=(e.phase===1?1.00:(e.phase===2?1.02:1.05));

    const brutal = state.stage>=20;
    const bossEasy = state.stage < 10;
    const densMul = bossEasy ? 0.72 : 1.0;
    const cdMul   = bossEasy ? 1.18 : 1.0;
    
    if(brutal){
      e.medCd -= dt;
      if(e.medCd<=0){
        if(Math.random()<0.65){
          spawnRepairDrone(e);
        }else{
          const add = e.hpMax*0.035;
          e.hp = Math.min(e.hpMax, e.hp + add);
          toastMsg(`ü©π Boss Ëá™Êàë‰øÆÂæ© +${Math.floor(add)}`,0.85);
          addBurst(e.x,e.y,14);
        }
        e.medCd = 7.6 + Math.random()*4.6;
      }
    }

    // ‚úÖ Boss ÂΩàÁöÑÊäµÈä∑ HPÔºöÂàªÊÑèÊØî‰∏ÄËà¨ÂΩà‰Ωé‰∏ÄÈªûÔºàÈÅøÂÖç„ÄåÂΩàÂπïÈêµÊùø„ÄçÔºâ
    const bossBulletHp = enemyBulletHpByStage(state.stage) * 0.60;

    e.burstCd-=dt;
    if(e.burstCd<=0 && eBullets.length<enemyBulletCap()){
      e.burstLeft=(e.phase===1?2:(e.phase===2?3:4));
      e.burstGapCd=0;
      e.burstCd=(e.phase===1?0.85:(e.phase===2?0.70:0.55)) * cdMul;
    }
    if(e.burstLeft>0){
      e.burstGapCd-=dt;
      if(e.burstGapCd<=0){
        const ang=Math.atan2(player.y-e.y,player.x-e.x);
        const lanesBase=(e.phase===1?5:(e.phase===2?5:6));
        const lanes = Math.max(3, Math.round(lanesBase * densMul));
        const spread=(e.phase===1?0.30:(e.phase===2?0.32:0.36));
        for(let i=0;i<lanes;i++){
          const t=(i-(lanes-1)/2)/(((lanes-1)/2)||1);
          enemyShoot(e,ang+t*spread,spdMul,dmgMul,{r: brutal?5:4, pierce: brutal?1:0, hp: bossBulletHp});
        }
        e.burstLeft-=1;
        e.burstGapCd=(e.phase===1?0.12:(e.phase===2?0.11:0.10)) * cdMul;
      }
    }

    e.ringCd-=dt;
    if(e.ringCd<=0 && eBullets.length<enemyBulletCap()){
      const nBase=(e.phase===1?12:(e.phase===2?18:28)) + (brutal?6:0);
      const n=Math.max(10, Math.round(nBase * densMul));
      const base=Math.random()*Math.PI*2;
      for(let i=0;i<n;i++){
        const a=base+(i/n)*Math.PI*2;
        enemyShoot(e,a,spdMul*0.98,dmgMul*0.75,{r: brutal?5:4, hp: bossBulletHp});
      }
      e.ringCd=(e.phase===1?1.10:(e.phase===2?0.80:0.60)) * (brutal?0.92:1.0) * cdMul;
    }

    e.spiralCd-=dt;
    e.spin=(e.spin??0)+dt*(e.phase===1?1.4:(e.phase===2?2.0:2.6))*(brutal?1.08:1.0);
    if(e.spiralCd<=0 && eBullets.length<enemyBulletCap()){
      const n=(e.phase===1?5:(e.phase===2?8:10)) + (brutal?2:0);
      const base=e.spin;
      for(let i=0;i<n;i++){
        const a=base+(i/n)*Math.PI*2;
        enemyShoot(e,a,spdMul*1.00,dmgMul*0.65,{r: brutal?5:4, hp: bossBulletHp});
      }
      e.spiralCd=(e.phase===1?0.55:(e.phase===2?0.34:0.24))*(brutal?0.92:1.0);
    }

    if(e.phase===3){
      e.summonCd-=dt;
      if(e.summonCd<=0){
        spawnAdds(4+(Math.random()<0.5?1:0),.92);
        e.summonCd=5.2+(Math.random()*1.8-.7);
      }
    }
  }

  function damagePlayer(dmg){
    if(buffs.invulnT>0) return;
    if(hitIFrameT > 0) return;        // ‚úÖ ÂèóÊìäÂæåÁü≠Êö´ÂÖçÁñ´ÈÄ£Êâì
  
    if(player.shield>0){
      const use=Math.min(player.shield,dmg);
      player.shield-=use; dmg-=use;
    }
    if(dmg>0) player.hp=Math.max(0,player.hp-dmg);
  
    hitIFrameT = 0.35;                // ‚úÖ 0.35s ÁÑ°ÊïµÂπÄÔºà‰Ω†ÊÉ≥Êõ¥‰øùÂÆàÂèØÁî® 0.25Ôºâ
    if(player.hp<=0) gameOver();
  }

  function gameOver(){
    mode='gameover';
    paused=true;
    $btnPause.textContent='ÁπºÁ∫å';
    $toast.classList.remove('show');

    const bestKey='blaster_best_score_v3_fix';
    const best=Math.max(Number(localStorage.getItem(bestKey)||0), state.score);
    localStorage.setItem(bestKey,String(best));

    overlay.classList.add('show');
    opts.innerHTML='';
    $panelRow.innerHTML='';

    $panelTitle.textContent='Game Over';
    $panelSub.style.display='block';
    $panelSub.innerHTML=
      `Êú¨Â±ÄÂàÜÊï∏Ôºö<b>${state.score}</b><br>`+
      `ÊúÄÈ´òÂàÜÔºö<b>${best}</b><br>`+
      `ÈóúÂç° ${state.stage} / Ê≥¢Ê¨° ${state.wave} / Á≠âÁ¥ö ${state.level}`;
    $panelRow.style.display='flex';

    const btn=document.createElement('button');
    btn.className='pill';
    btn.textContent='ÈáçÊñ∞ÈñãÂßã';
    btn.addEventListener('click',()=>{
      overlay.classList.remove('show');
      resetRun();
      mode='play';
      paused=false;
      $btnPause.textContent='Êö´ÂÅú';
      lastT=performance.now();
    });
    $panelRow.appendChild(btn);

    const btnStay=document.createElement('button');
    btnStay.className='pill';
    btnStay.textContent='ÁïôÂú®ÈÄôË£°';
    btnStay.addEventListener('click',()=>{});
    $panelRow.appendChild(btnStay);
  }

  function resetRun(){
    state.stage=1;state.wave=1;state.score=0;state.xp=0;state.level=1;state.nextXp=60;state.waveClearCooldown=0;state.waveInProgress=false;

    player.hpMax=BASE_HP; player.hp=BASE_HP;
    player.moveSpeed=520;player.fireRate=6.2;player.dmg=26;player.bulletSpeed=820;
    player.spread_perm=1;player.pierce_perm=2;
    player.shield=0;player.shieldMax=0;
    player.regen=0; player.xpGainMul=1.0;
    player.bulletR=BULLET_R_BASE;

    for(const k in buffs) buffs[k]=0;

    special.bomb.count=3; special.bomb.cd=0;
    special.invuln.count=3; special.invuln.cd=0;
    special.emp.count=2; special.emp.cd=0;
    special.armor.count=2; special.armor.cd=0;
    special.heal.count=2; special.heal.cd=0;

    pBullets=[];eBullets=[];enemies=[];drops=[];particles=[];
    spawnWave();
  }

  function addBurst(x,y,n=10){
    for(let i=0;i<n;i++) particles.push({x,y,vx:rand(-220,220),vy:rand(-220,220),life:rand(.25,.55)});
  }
  let toastT=0;
  function toastMsg(text,sec=.75){$toast.textContent=text;$toast.classList.add('show');toastT=sec}

  // ---------- Update / Draw ----------
  function update(dt){
    for(const k of ['rapid','magnet','spreadBonusT','pierceBonusT','invulnT','empT','armorT']){
      if(buffs[k]>0) buffs[k]=Math.max(0,buffs[k]-dt);
    }
    for(const k in special){
      if(special[k].cd>0) special[k].cd=Math.max(0,special[k].cd-dt);
    }
    if(hitIFrameT > 0) hitIFrameT = Math.max(0, hitIFrameT - dt);
    if(player.regen>0 && player.hp>0) player.hp=clamp(player.hp+player.regen*dt,0,player.hpMax);

    player.y=H-42;
    player.x=clamp(player.x,player.r+8,W-player.r-8);
    shoot(dt);

    for(const e of enemies){
      e.y=lerp(e.y,e.targetY,clamp(dt*2.6,0,1));
      if(e.strafeAmp>0){
        e.strafePhase+=dt*e.strafeSpd;
        const ox=Math.sin(e.strafePhase)*e.strafeAmp;
        if(e.type==='boss') e.x=W*.5+ox;
        else {if(e.baseX==null)e.baseX=e.x; e.x=e.baseX+ox}
      }
      e.x=clamp(e.x,e.r+10,W-e.r-10);

      if(e.type==='boss') bossTick(e,dt);
      else if(e.type==='drone'){
        e.healT -= dt;
        if(e.healT<=0 && e.bossRef && e.bossRef.hp>0){
          const add = e.bossRef.hpMax * e.healPct;
          e.bossRef.hp = Math.min(e.bossRef.hpMax, e.bossRef.hp + add);
          toastMsg(`üß∞ Drone ‰øÆÂæ© +${Math.floor(add)}`,0.85);
          addBurst(e.bossRef.x,e.bossRef.y,18);
          e.hp = 0;
        }
      }
      else {e.fireCd-=dt; if(e.fireCd<=0){mobShoot(e); e.fireCd=1/e.fireRate}}

      if(e.hitFlash>0) e.hitFlash=Math.max(0,e.hitFlash-dt);
    }

    const empMoveMul=(buffs.empT>0)?0.55:1.0;

    for(const b of pBullets){
      b.x+=b.vx*dt; b.y+=b.vy*dt;
      if(b.y<-30||b.x<-40||b.x>W+40) b.alive=false;
    }
    for(const b of eBullets){
      b.x+=b.vx*dt*empMoveMul; b.y+=b.vy*dt*empMoveMul;
      if(b.y>H+40||b.x<-50||b.x>W+50) b.alive=false;
    }

    for(const d of drops){
      d.y+=d.vy*dt; d.life-=dt;
      if(buffs.magnet>0){
        const dx=player.x-d.x,dy=player.y-d.y,l=Math.hypot(dx,dy)||1;
        d.x+=(dx/l)*260*dt; d.y+=(dy/l)*260*dt;
      }
      if(d.y>H+60||d.life<=0) d.dead=true;
      if(dist2(d.x,d.y,player.x,player.y)<(d.r+player.r+8)**2){d.dead=true;applyDrop(d.type)}
    }

    for(const p of particles){
      p.x+=p.vx*dt; p.y+=p.vy*dt;
      p.vx*=(1-dt*2.8); p.vy*=(1-dt*2.8);
      p.life-=dt; if(p.life<=0) p.dead=true;
    }

    // ‚úÖ Áé©ÂÆ∂Â≠êÂΩà vs ÊïµÂΩàÔºö‰∏çÂÜç‰∏ÄÁ¢∞Â∞±Ê≠ªÔºåÊîπÁî® clashLeft
    if(buffs.armorT<=0){
      for(const b of pBullets){
        if(!b.alive) continue;
        if((b.clashLeft??0)<=0) continue;

        for(const eb of eBullets){
          if(!eb.alive) continue;
          if(eb.beam) continue;

          if(dist2(b.x,b.y,eb.x,eb.y)<(b.r+eb.r+2)**2){
            // ÊïµÂΩàÊúâÁ©øÈÄèÔºöÂÖàÁ°¨ÂêÉ‰∏ÄÊ¨°ÔºàÊõ¥Èõ£Ê∏ÖÔºâ
            if((eb.pierce||0)>0){
              eb.pierce -= 1;
              b.clashLeft = Math.max(0,(b.clashLeft||0)-1);
              if(b.clashLeft<=0) b.alive=false;
              addBurst(eb.x,eb.y,3);
              state.score+=1;
              break;
            }

            const clearDmg = b.dmg * bulletClearMul(b.r);
            eb.hp = (eb.hp ?? enemyBulletHpByStage(state.stage)) - clearDmg;

            addBurst(eb.x,eb.y,4);
            state.score+=1;

            b.clashLeft = Math.max(0,(b.clashLeft||0)-1);
            if(eb.hp<=0) eb.alive=false;
            if(b.clashLeft<=0) b.alive=false;

            // Âêå‰∏ÄÈ°ÜÁé©ÂÆ∂Â≠êÂΩàÂêå‰∏ÄÂπÄÂè™ËôïÁêÜ‰∏ÄÊ¨°Á¢∞ÊíûÔºåÈÅøÂÖçÂà∑ÁàÜ
            break;
          }
        }
      }
    }

    // player bullets vs enemies
    for(const b of pBullets){
      if(!b.alive) continue;
      for(const e of enemies){
        if(e.hp<=0) continue;
        if(dist2(b.x,b.y,e.x,e.y)<(b.r+e.r)**2){
          e.hp-=b.dmg; e.hitFlash=.12;
          addBurst(b.x,b.y,4);
          if(b.pierce<=0) b.alive=false; else b.pierce-=1;

          if(e.hp<=0){
            if(e.type==='boss'){
              state.score+=320; addXp(260); maybeDrop(e.x,e.y,true);
              addBurst(e.x,e.y,26);
            }else if(e.type==='elite'){
              state.score+=38; addXp(12); maybeDrop(e.x,e.y,false);
              addBurst(e.x,e.y,12);
            }else if(e.type==='drone'){
              state.score+=28; addXp(10);
              toastMsg('‚úÖ Drone Â∑≤ÊìäÁ†¥',0.7);
              addBurst(e.x,e.y,14);
            }else{
              state.score+=18; addXp(7); maybeDrop(e.x,e.y,false);
              addBurst(e.x,e.y,10);
            }
          }
          break;
        }
      }
    }

    // enemy bullets vs player (beam capsule Á¢∞Êíû)
    for(const eb of eBullets){
      if(!eb.alive) continue;

      if(eb.beam){
        const ang=Math.atan2(eb.vy,eb.vx);
        const L=eb.len||28, R=eb.r||5;
        const dx=Math.cos(ang)*(L/2), dy=Math.sin(ang)*(L/2);
        const ax=eb.x-dx, ay=eb.y-dy;
        const bx=eb.x+dx, by=eb.y+dy;

        const px=player.x, py=player.y;
        const vx=bx-ax, vy=by-ay;
        const wx=px-ax, wy=py-ay;
        const c1=wx*vx+wy*vy;
        const c2=vx*vx+vy*vy || 1;
        let t=c1/c2; t=clamp(t,0,1);
        const cx=ax+t*vx, cy=ay+t*vy;

        if(dist2(px,py,cx,cy) < (player.r + R + 1)**2){
          eb.alive=false;
          damagePlayer(eb.dmg);
          addBurst(player.x,player.y,10);
        }
        continue;
      }

      if(dist2(eb.x,eb.y,player.x,player.y)<(eb.r+player.r)**2){
        eb.alive=false;
        damagePlayer(eb.dmg);
        addBurst(player.x,player.y,10);
      }
    }

    // cleanup
    pBullets=pBullets.filter(b=>b.alive);
    eBullets=eBullets.filter(b=>b.alive);
    enemies=enemies.filter(e=>e.hp>0);
    drops=drops.filter(d=>!d.dead);
    particles=particles.filter(p=>!p.dead);

    // wave progression
    if(!state.waveInProgress){
      state.waveClearCooldown-=dt;
      if(state.waveClearCooldown<=0){
        if(state.wave===state.bossEveryWaves){spawnBoss();state.waveInProgress=true}
        else spawnWave();
      }
    }else{
      if(enemies.length===0){
        if(state.wave===state.bossEveryWaves) nextStage();
        else nextWave();
      }
    }

    if(toastT>0){
      toastT=Math.max(0,toastT-dt);
      if(toastT===0 && !paused) $toast.classList.remove('show');
    }
  }

  function draw(){
    ctx.clearRect(0,0,W,H);

    ctx.save();ctx.globalAlpha=.10;ctx.strokeStyle='#e7eefc';
    if(hitIFrameT > 0) ctx.globalAlpha = 0.55 + 0.35*Math.sin(performance.now()/70);
    const step=48;
    for(let x=0;x<=W;x+=step){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,H);ctx.stroke()}
    for(let y=0;y<=H;y+=step){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(W,y);ctx.stroke()}
    ctx.restore();

    ctx.save();ctx.fillStyle='rgba(120,255,200,.7)';
    for(const p of particles){ctx.globalAlpha=clamp(p.life*2.0,0,1);ctx.beginPath();ctx.arc(p.x,p.y,2.2,0,Math.PI*2);ctx.fill()}
    ctx.restore();

    for(const d of drops){
      ctx.save();
      ctx.fillStyle='rgba(255,255,255,.08)';ctx.strokeStyle='rgba(255,255,255,.18)';ctx.lineWidth=1;
      ctx.beginPath();ctx.arc(d.x,d.y,d.r,0,Math.PI*2);ctx.fill();ctx.stroke();
      ctx.globalAlpha=.9;ctx.fillStyle='rgba(120,255,200,.95)';ctx.font='12px system-ui,"Noto Sans TC"';
      ctx.textAlign='center';ctx.textBaseline='middle';
      const icon=d.type==='heal'?'‚úö':d.type==='shield'?'‚õ®':d.type==='rapid'?'‚ö°':d.type==='spread'?'‚ú¶':d.type==='pierce'?'‚ûπ':'üß≤';
      ctx.fillText(icon,d.x,d.y+.5);ctx.restore();
    }

    for(const e of enemies){
      ctx.save();
      const isBoss=e.type==='boss', flash=e.hitFlash>0;
      const isElite=e.type==='elite', isDrone=e.type==='drone';

      ctx.fillStyle = flash ? 'rgba(255,255,255,.18)'
        : isBoss ? 'rgba(255,120,120,.14)'
        : isElite ? 'rgba(220,180,255,.14)'
        : isDrone ? 'rgba(200,255,220,.10)'
        : 'rgba(255,255,255,.10)';

      ctx.strokeStyle = isBoss ? 'rgba(255,120,120,.35)'
        : isElite ? 'rgba(220,180,255,.40)'
        : isDrone ? 'rgba(200,255,220,.30)'
        : 'rgba(255,255,255,.20)';

      ctx.lineWidth = isBoss?2:(isElite?1.8:1);

      ctx.beginPath();ctx.arc(e.x,e.y,e.r,0,Math.PI*2);ctx.fill();ctx.stroke();

      const w=isBoss?96:(isElite?70:52),h=6,x=e.x-w/2,y=e.y-e.r-14;
      ctx.globalAlpha=.9;ctx.fillStyle='rgba(255,255,255,.10)';ctx.fillRect(x,y,w,h);

      const hpPct=clamp(e.hp/e.hpMax,0,1);
      ctx.fillStyle=isBoss?'rgba(255,120,120,.9)':(isElite?'rgba(220,180,255,.9)':'rgba(120,255,200,.9)');
      ctx.fillRect(x,y,w*hpPct,h);

      if(isBoss){
        ctx.globalAlpha=.85;ctx.fillStyle='rgba(255,255,255,.65)';
        ctx.font='11px system-ui,"Noto Sans TC"';ctx.textAlign='center';ctx.textBaseline='bottom';
        ctx.fillText(`P${e.phase||1}`,e.x,y-2);
      }
      if(isDrone){
        ctx.globalAlpha=.85;ctx.fillStyle='rgba(255,255,255,.70)';
        ctx.font='11px system-ui,"Noto Sans TC"';ctx.textAlign='center';ctx.textBaseline='top';
        ctx.fillText(`üß∞ ${Math.ceil(e.healT)}s`,e.x,e.y+e.r+6);
      }
      ctx.restore();
    }

    ctx.save();ctx.fillStyle='rgba(120,255,200,.95)';
    for(const b of pBullets){ctx.beginPath();ctx.arc(b.x,b.y,b.r,0,Math.PI*2);ctx.fill()}
    ctx.restore();

    // enemy bullets (beam capsule)
    ctx.save();ctx.fillStyle='rgba(255,160,160,.92)';
    for(const b of eBullets){
      if(!b.beam){
        ctx.beginPath();ctx.arc(b.x,b.y,b.r,0,Math.PI*2);ctx.fill();
      }else{
        const ang=Math.atan2(b.vy,b.vx);
        const L=b.len||28, R=b.r||5;
        ctx.save();
        ctx.translate(b.x,b.y);
        ctx.rotate(ang);
        if(ctx.roundRect){
          ctx.beginPath();
          ctx.roundRect(-L/2, -R, L, R*2, R);
          ctx.fill();
        }else{
          ctx.beginPath();ctx.rect(-L/2, -R, L, R*2);ctx.fill();
          ctx.beginPath();ctx.arc(-L/2,0,R,0,Math.PI*2);ctx.fill();
          ctx.beginPath();ctx.arc(L/2,0,R,0,Math.PI*2);ctx.fill();
        }
        ctx.restore();
      }
    }
    ctx.restore();

    ctx.save();
    ctx.translate(player.x,player.y);
    ctx.fillStyle='rgba(255,255,255,.10)';ctx.strokeStyle='rgba(255,255,255,.22)';ctx.lineWidth=1.5;
    ctx.beginPath();ctx.moveTo(0,-player.r-2);ctx.lineTo(player.r+2,player.r+4);ctx.lineTo(-player.r-2,player.r+4);ctx.closePath();ctx.fill();ctx.stroke();
    if(player.shield>0){
      ctx.globalAlpha=.85;ctx.strokeStyle='rgba(120,255,200,.45)';ctx.lineWidth=2;
      ctx.beginPath();ctx.arc(0,0,player.r+10,0,Math.PI*2);ctx.stroke();
    }
    if(buffs.invulnT>0){
      ctx.globalAlpha=.55;ctx.strokeStyle='rgba(255,255,255,.55)';ctx.lineWidth=2;
      ctx.beginPath();ctx.arc(0,0,player.r+15,0,Math.PI*2);ctx.stroke();
    }
    ctx.restore();
  }

  function syncHud(){
    $stage.textContent=`ÈóúÂç° ${state.stage}`;
    $wave.textContent=`Ê≥¢Ê¨° ${state.wave}`;
    $lv.textContent=`Á≠âÁ¥ö ${state.level}`;
    $score.textContent=`ÂàÜÊï∏ ${state.score}`;

    const hpPct=clamp(player.hp/player.hpMax,0,1);
    $hpFill.style.width=`${hpPct*100}%`;
    const shieldTxt=player.shield>0?` +${Math.floor(player.shield)}`:'';
    $hpNum.textContent=`${Math.floor(player.hp)}/${Math.floor(player.hpMax)}${shieldTxt}`;

    $cntBomb.textContent=`x${special.bomb.count}`;
    $cntInvuln.textContent=`x${special.invuln.count}`;
    $cntEMP.textContent=`x${special.emp.count}`;
    $cntArmor.textContent=`x${special.armor.count}`;
    $cntHeal.textContent=`x${special.heal.count}`;

    $btnBomb.disabled  = !canUseSpecial('bomb');
    $btnInvuln.disabled= !canUseSpecial('invuln');
    $btnEMP.disabled   = !canUseSpecial('emp');
    $btnArmor.disabled = !canUseSpecial('armor');
    $btnHeal.disabled  = !canUseSpecial('heal');
  }

  let lastT=performance.now();
  function frame(t){
    const dt=Math.min(.033,(t-lastT)/1000);lastT=t;
    if(mode==='play' && !paused) update(dt);
    draw(); syncHud();
    requestAnimationFrame(frame);
  }

  setPadX(.5);
  spawnWave();
  requestAnimationFrame(frame);
})();
</script></body></html>
