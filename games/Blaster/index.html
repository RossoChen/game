<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
  <title>Blaster</title>
  <meta name="theme-color" content="#0b1220" />

  <style>
    :root { color-scheme: dark; }
    html, body{
      height:100%;
      margin:0;
      background:#0b1220;
      color:#e7eefc;
      font-family: system-ui, "Noto Sans TC", sans-serif;
      -webkit-user-select:none; user-select:none;
      touch-action: manipulation;
      overflow:hidden;
    }
    body{ position:fixed; inset:0; }

    .app{
      height:100svh;
      padding-top: calc(env(safe-area-inset-top) + 10px);
      padding-right: calc(env(safe-area-inset-right) + 10px);
      padding-bottom: calc(env(safe-area-inset-bottom) + 10px);
      padding-left: calc(env(safe-area-inset-left) + 10px);
      display:flex;
      flex-direction:column;
      gap:10px;
      box-sizing:border-box;
    }

    .hud{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:space-between;
    }
    .hudLeft, .hudRight{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    .pill, button.pill{
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color:#e7eefc;
      padding:10px 12px;
      font-size:14px;
      line-height:1;
      white-space:nowrap;
      -webkit-tap-highlight-color: transparent;
    }
    button.pill{ cursor:pointer; }
    button.pill:active{ transform: scale(.99); }

    .hpbar{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
    }
    .hpbar .label{ opacity:.85; font-weight:700; }
    .hpbar .track{
      width:min(420px, 46vw);
      height:14px;
      border-radius:999px;
      background: rgba(255,255,255,.10);
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
    }
    .hpbar .fill{
      height:100%;
      width:50%;
      background: rgba(120,255,200,.95);
    }
    .hpbar .num{ opacity:.85; font-variant-numeric: tabular-nums; }

    /* ä¸»å€åŸŸï¼šç”¨ flex è®“ board è‡ªå‹•åƒå‰©é¤˜é«˜åº¦ï¼Œä¿è­‰ touchpad ä¸è¢«æ“ å‡ºç•«é¢ */
    .main{
      flex:1;
      min-height:0; /* è®“å…§éƒ¨ canvas å¯ä»¥ç¸®ï¼Œä¸æœƒæŠŠåº•éƒ¨æ“ èµ° */
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .boardWrap{
      flex:1;
      min-height:0;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      background: radial-gradient(1200px 800px at 50% 0%, rgba(90,120,255,.10), transparent 60%),
                  rgba(255,255,255,.03);
      overflow:hidden;
      position:relative;
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
    }

    .touchpad{
      flex:0 0 auto;
      height: max(86px, 13svh);
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      position:relative;
      overflow:hidden;
      -webkit-tap-highlight-color: transparent;
    }
    .touchpad .hint{
      position:absolute;
      inset:auto 0 10px 0;
      text-align:center;
      font-size:14px;
      opacity:.75;
      pointer-events:none;
    }
    .touchpad .bar{
      position:absolute;
      left:10px; right:10px;
      top:16px; bottom:16px;
      border-radius:14px;
      border:1px dashed rgba(255,255,255,.18);
      opacity:.7;
    }
    .touchpad .thumb{
      position:absolute;
      top:50%;
      width:46px; height:46px;
      transform: translate(-50%,-50%);
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.08);
      box-shadow: 0 8px 30px rgba(0,0,0,.35);
      pointer-events:none;
    }

    /* å‡ç´šé¸å–® */
    .overlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.58);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      z-index: 50;
    }
    .overlay.show{ display:flex; }
    .panel{
      width:min(720px, 92vw);
      border-radius:18px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(15,22,40,.92);
      padding:16px;
      box-shadow: 0 18px 70px rgba(0,0,0,.55);
    }
    .panel h2{
      margin:0 0 10px;
      font-size:18px;
      letter-spacing:.2px;
    }
    .opts{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
    }
    @media (min-width: 720px){
      .opts{ grid-template-columns: 1fr 1fr 1fr; }
    }
    .opt{
      border-radius:16px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      padding:14px;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
    }
    .opt:active{ transform: scale(.99); }
    .opt .t{ font-weight:900; margin-bottom:6px; }
    .opt .d{ opacity:.78; font-size:13px; line-height:1.4; }

    /* æš«åœ/æç¤º */
    .toast{
      position:absolute;
      left:50%;
      top:16px;
      transform: translateX(-50%);
      padding:10px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.35);
      font-size:13px;
      opacity:.9;
      display:none;
      pointer-events:none;
    }
    .toast.show{ display:block; }
  </style>
</head>

<body>
  <div class="app">
    <div class="hud">
      <div class="hudLeft">
        <button class="pill" id="btnHub">â† Hub</button>
        <span class="pill" id="hudStage">é—œå¡ 1</span>
        <span class="pill" id="hudWave">æ³¢æ¬¡ 1</span>
        <span class="pill" id="hudLv">ç­‰ç´š 1</span>
        <span class="pill" id="hudScore">åˆ†æ•¸ 0</span>
      </div>
      <div class="hudRight">
        <div class="hpbar">
          <span class="label">HP</span>
          <div class="track"><div class="fill" id="hpFill"></div></div>
          <span class="num" id="hpNum">100/100</span>
        </div>
        <button class="pill" id="btnPause">æš«åœ</button>
      </div>
    </div>

    <div class="main">
      <div class="boardWrap" id="boardWrap">
        <canvas id="c"></canvas>
        <div class="toast" id="toast">Paused</div>
      </div>

      <div class="touchpad" id="touchpad" aria-label="touchpad">
        <div class="bar"></div>
        <div class="thumb" id="thumb" style="left:50%;"></div>
        <div class="hint">å·¦å³æ‹–æ›³ï¼ç§»å‹•ï¼ˆè‡ªå‹•å°„æ“Šï¼‰</div>
      </div>
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="panel">
      <h2>å‡ç´šï¼šé¸ä¸€å€‹</h2>
      <div class="opts" id="opts"></div>
    </div>
  </div>

<script>
(() => {
  // -----------------------
  // Canvas / Resize
  // -----------------------
  const wrap = document.getElementById('boardWrap');
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });

  function resize(){
    const r = wrap.getBoundingClientRect();
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    canvas.width = Math.floor(r.width * dpr);
    canvas.height = Math.floor(r.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    W = r.width; H = r.height;
  }
  let W=0, H=0;
  window.addEventListener('resize', resize);
  resize();

  // -----------------------
  // HUD / UI
  // -----------------------
  const $stage = document.getElementById('hudStage');
  const $wave  = document.getElementById('hudWave');
  const $lv    = document.getElementById('hudLv');
  const $score = document.getElementById('hudScore');
  const $hpFill= document.getElementById('hpFill');
  const $hpNum = document.getElementById('hpNum');
  const $btnPause = document.getElementById('btnPause');
  const $toast = document.getElementById('toast');
  const $btnHub = document.getElementById('btnHub');

  // Hub linkï¼šå›ä¸Šä¸€å±¤ï¼ˆ/game/games/ï¼‰
  $btnHub.addEventListener('click', () => {
    // ä½ Hubåœ¨ /game/ ï¼ŒBlasteråœ¨ /game/games/Blaster/
    // å¾€ä¸Šå…©å±¤ -> /game/games/
    location.href = '../';
  });

  let paused = false;
  $btnPause.addEventListener('click', () => {
    paused = !paused;
    $btnPause.textContent = paused ? 'ç¹¼çºŒ' : 'æš«åœ';
    $toast.textContent = paused ? 'Paused' : '';
    $toast.classList.toggle('show', paused);
    if (!paused) lastT = performance.now();
  });

  // -----------------------
  // Touchpad control
  // -----------------------
  const pad = document.getElementById('touchpad');
  const thumb = document.getElementById('thumb');
  let padActive = false;
  let padX = 0.5; // 0..1
  function setPadX(nx){
    padX = Math.max(0, Math.min(1, nx));
    thumb.style.left = `${padX*100}%`;
    // player x uses padX
    player.x = lerp(player.x, padX * W, 1); // snap-ish
  }
  function pointerToPadX(e){
    const r = pad.getBoundingClientRect();
    return (e.clientX - r.left) / r.width;
  }
  pad.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    pad.setPointerCapture(e.pointerId);
    padActive = true;
    setPadX(pointerToPadX(e));
  });
  pad.addEventListener('pointermove', (e) => {
    if (!padActive) return;
    e.preventDefault();
    setPadX(pointerToPadX(e));
  });
  pad.addEventListener('pointerup', (e) => {
    padActive = false;
    try{ pad.releasePointerCapture(e.pointerId); }catch(_){}
  });
  pad.addEventListener('pointercancel', () => padActive = false);

  // -----------------------
  // Helpers
  // -----------------------
  const rand = (a,b)=> a + Math.random()*(b-a);
  const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
  const lerp = (a,b,t)=> a + (b-a)*t;
  const dist2 = (ax,ay,bx,by)=> { const dx=ax-bx, dy=ay-by; return dx*dx + dy*dy; };

  // -----------------------
  // Game State
  // -----------------------
  const state = {
    stage: 1,
    wave: 1,
    score: 0,
    time: 0,
    xp: 0,
    level: 1,
    nextXp: 40,
    waveClearCooldown: 0,
    waveInProgress: false,
    bossAlive: false,
    bossEveryWaves: 5, // æ¯é—œç¬¬5æ³¢Boss
  };

  // Player build
  const player = {
    x: W*0.5,
    y: 0,
    r: 14,
    hp: 100,
    hpMax: 100,
    moveSpeed: 520,      // px/s
    fireRate: 8,         // shots per sec
    dmg: 12,
    bulletSpeed: 820,
    spread: 0,           // 0..2
    pierce: 0,           // 0..2
    shield: 0,           // hit points shield
    shieldMax: 0,
    magnet: 0,           // 0/1
    slowAura: 0,         // 0/1
  };

  // Entities
  let pBullets = [];
  let eBullets = [];
  let enemies  = [];
  let drops    = [];
  let particles= [];

  // Spawn lines (enemies settle here)
  function enemyHoldY(){
    // è®“æ€ªåœåœ¨ä¸ŠåŠéƒ¨ï¼ˆåˆ¥å¤ªé è¿‘é ‚ç«¯ï¼‰
    return clamp(H * 0.18, 110, 190);
  }

  // -----------------------
  // Wave system (ä¸€æ³¢ä¸€æ³¢)
  // -----------------------
  function waveConfig(stage, wave){
    // éš¨é—œå¡ä¸Šå‡ï¼Œæ€ªæ›´å¤š/æ›´ç¡¬/å°„æ›´å¿«
    const baseCount = 4 + Math.floor((stage-1)*1.2) + Math.floor((wave-1)*0.8);
    const count = clamp(baseCount, 4, 14);

    const hp = 22 + stage*6 + wave*3;
    const fire = 0.6 + stage*0.08 + wave*0.06; // shots/sec
    const bullet = 260 + stage*18 + wave*10;

    return { count, hp, fire, bullet };
  }

  function spawnWave(){
    enemies.length = 0;
    eBullets.length = 0;
    state.waveInProgress = true;
    state.bossAlive = false;

    const cfg = waveConfig(state.stage, state.wave);
    const holdY = enemyHoldY();
    const lanes = cfg.count;

    for (let i=0;i<lanes;i++){
      const x = (i+1) * (W/(lanes+1));
      const isStrafe = Math.random() < (0.35 + state.stage*0.03); // æœ‰äº›å·¦å³èµ°ä½
      const strafeAmp = isStrafe ? rand(40, 120) : 0;
      const strafeSpd = isStrafe ? rand(0.8, 1.8) : 0;

      enemies.push({
        type: 'mob',
        x,
        y: -40 - i*18,
        targetY: holdY + rand(-18, 18),
        r: 15,
        hp: cfg.hp,
        hpMax: cfg.hp,
        fireCd: rand(0.3, 1.2),
        fireRate: cfg.fire,
        bulletSpeed: cfg.bullet,
        strafeAmp,
        strafeSpd,
        strafePhase: rand(0, Math.PI*2),
        hitFlash: 0,
      });
    }
  }

  function spawnBoss(){
    // Boss é€²å ´å¾Œåœåœ¨å›ºå®šç·šä½ + å·¦å³ç§»å‹•å°„æ“Š
    state.bossAlive = true;
    const holdY = enemyHoldY() - 10;
    enemies.push({
      type: 'boss',
      x: W*0.5,
      y: -80,
      targetY: holdY,
      r: 28,
      hp: 520 + state.stage*140,
      hpMax: 520 + state.stage*140,
      fireCd: 0.8,
      fireRate: 1.0 + state.stage*0.12,
      bulletSpeed: 320 + state.stage*20,
      strafeAmp: 220,
      strafeSpd: 1.05 + state.stage*0.08,
      strafePhase: 0,
      phase: 1,
      hitFlash: 0,
    });
  }

  function nextWave(){
    state.wave += 1;
    state.waveClearCooldown = 0.55; // çµ¦ç©å®¶å–˜æ°£
    state.waveInProgress = false;
    // æ¯é—œåˆ°ç¬¬ bossEveryWaves æ³¢å‡º Boss
    // Boss æ­»äº†æ‰ç®—éé—œï¼ˆstage+1, waveå›1ï¼‰
  }

  function nextStage(){
    state.stage += 1;
    state.wave = 1;
    state.waveClearCooldown = 0.8;
    state.waveInProgress = false;
  }

  // -----------------------
  // Drop system
  // -----------------------
  const DROP_TYPES = [
    { key:'heal',  t:'å›è¡€',   d:'+25 HP', w: 26 },
    { key:'shield',t:'è­·ç›¾',   d:'+20 Shield', w: 18 },
    { key:'rapid', t:'æ€¥é€Ÿå°„æ“Š', d:'å°„é€Ÿ +25%ï¼ˆçŸ­æ•ˆï¼‰', w: 16 },
    { key:'spread',t:'æ•£å°„',  d:'æ•£å°„ +1ï¼ˆçŸ­æ•ˆï¼‰', w: 14 },
    { key:'bomb',  t:'ç‚¸å½ˆ',  d:'æ¸…å ´ï¼ˆæ•µ/å½ˆï¼‰', w: 8 },
    { key:'magnet',t:'ç£éµ',  d:'å¸é“å…·ï¼ˆçŸ­æ•ˆï¼‰', w: 10 },
    { key:'slow',  t:'ç·©é€Ÿ',  d:'æ•µå½ˆè®Šæ…¢ï¼ˆçŸ­æ•ˆï¼‰', w: 8 },
  ];

  function pickDrop(){
    const total = DROP_TYPES.reduce((s,a)=>s+a.w,0);
    let r = Math.random()*total;
    for (const it of DROP_TYPES){
      r -= it.w;
      if (r<=0) return it.key;
    }
    return 'heal';
  }

  function maybeDrop(x,y, isBoss=false){
    const p = isBoss ? 0.95 : 0.22;
    if (Math.random() > p) return;
    drops.push({
      x, y,
      r: 10,
      vy: rand(40, 90),
      type: pickDrop(),
      life: 12,
    });
  }

  // Timed buffs
  const buffs = {
    rapid: 0,
    spread: 0,
    magnet: 0,
    slow: 0,
  };

  function applyDrop(type){
    if (type === 'heal'){
      player.hp = clamp(player.hp + 25, 0, player.hpMax);
      toastMsg('HP +25');
    } else if (type === 'shield'){
      player.shieldMax = Math.max(player.shieldMax, 20);
      player.shield = clamp(player.shield + 20, 0, player.shieldMax);
      toastMsg('Shield +20');
    } else if (type === 'rapid'){
      buffs.rapid = Math.max(buffs.rapid, 7.5);
      toastMsg('Rapid Fire!');
    } else if (type === 'spread'){
      buffs.spread = Math.max(buffs.spread, 7.5);
      toastMsg('Spread!');
    } else if (type === 'bomb'){
      // æ¸…å ´ï¼šæ¸…æ€ª + æ¸…æ•µå½ˆ
      let killed = 0;
      for (const e of enemies){
        if (e.type !== 'boss'){
          e.hp = 0;
          killed++;
          maybeDrop(e.x, e.y, false);
          addBurst(e.x,e.y, 12);
        }
      }
      eBullets.length = 0;
      toastMsg(`BOMB! (+${killed} mobs)`);
    } else if (type === 'magnet'){
      buffs.magnet = Math.max(buffs.magnet, 9.0);
      toastMsg('Magnet');
    } else if (type === 'slow'){
      buffs.slow = Math.max(buffs.slow, 7.5);
      toastMsg('Slow');
    }
  }

  // -----------------------
  // Level-up (3é¸1)
  // -----------------------
  const overlay = document.getElementById('overlay');
  const opts = document.getElementById('opts');

  const UPGRADES = [
    { key:'dmg', t:'ç«åŠ›æå‡', d:'å‚·å®³ +20%' },
    { key:'firerate', t:'å°„é€Ÿæå‡', d:'å°„é€Ÿ +18%' },
    { key:'hp', t:'æ“´å……è£ç”²', d:'HP ä¸Šé™ +20ï¼Œå›æ»¿' },
    { key:'speed', t:'æ©Ÿå‹•æå‡', d:'ç§»å‹•é€Ÿåº¦ +16%' },
    { key:'pierce', t:'ç©¿é€å½ˆ', d:'ç©¿é€ +1ï¼ˆæœ€å¤š 2ï¼‰' },
    { key:'spread_perm', t:'æ°¸ä¹…æ•£å°„', d:'æ•£å°„ +1ï¼ˆæœ€å¤š 2ï¼‰' },
    { key:'shield_cap', t:'è­·ç›¾æ“´å®¹', d:'è­·ç›¾ä¸Šé™ +20ï¼Œä¸¦å›æ»¿' },
  ];

  function openLevelUp(){
    paused = true;
    $btnPause.textContent = 'ç¹¼çºŒ';
    $toast.textContent = 'Level Up';
    $toast.classList.add('show');

    overlay.classList.add('show');
    opts.innerHTML = '';

    // æŠ½3å€‹ä¸é‡è¤‡
    const pool = [...UPGRADES];
    const picks = [];
    while (picks.length < 3 && pool.length){
      const i = Math.floor(Math.random()*pool.length);
      picks.push(pool.splice(i,1)[0]);
    }

    for (const u of picks){
      const el = document.createElement('div');
      el.className = 'opt';
      el.innerHTML = `<div class="t">${u.t}</div><div class="d">${u.d}</div>`;
      el.addEventListener('click', () => {
        applyUpgrade(u.key);
        overlay.classList.remove('show');
        paused = false;
        $btnPause.textContent = 'æš«åœ';
        $toast.classList.remove('show');
        lastT = performance.now();
      });
      opts.appendChild(el);
    }
  }

  function applyUpgrade(key){
    if (key === 'dmg'){
      player.dmg *= 1.20;
    } else if (key === 'firerate'){
      player.fireRate *= 1.18;
    } else if (key === 'hp'){
      player.hpMax += 20;
      player.hp = player.hpMax;
    } else if (key === 'speed'){
      player.moveSpeed *= 1.16;
    } else if (key === 'pierce'){
      player.pierce = Math.min(2, player.pierce + 1);
    } else if (key === 'spread_perm'){
      player.spread = Math.min(2, player.spread + 1);
    } else if (key === 'shield_cap'){
      player.shieldMax += 20;
      player.shield = player.shieldMax;
    }
  }

  function addXp(xp){
    state.xp += xp;
    while (state.xp >= state.nextXp){
      state.xp -= state.nextXp;
      state.level += 1;
      // nextXp grows
      state.nextXp = Math.floor(state.nextXp * 1.22 + 10);
      openLevelUp();
    }
  }

  // -----------------------
  // Combat
  // -----------------------
  let fireAcc = 0;

  function shoot(dt){
    const rate = player.fireRate * (buffs.rapid > 0 ? 1.25 : 1.0);
    fireAcc += dt * rate;
    while (fireAcc >= 1){
      fireAcc -= 1;
      spawnPlayerShot();
    }
  }

  function spawnPlayerShot(){
    const spreadBonus = (buffs.spread > 0 ? 1 : 0);
    const s = clamp(player.spread + spreadBonus, 0, 3);

    const base = { x: player.x, y: player.y - player.r - 6, r: 4, vx:0, vy: -player.bulletSpeed, dmg: player.dmg, pierce: player.pierce, alive:true };
    const shots = [];

    if (s <= 0){
      shots.push(base);
    } else if (s === 1){
      shots.push({ ...base, vx: -120, vy: -player.bulletSpeed });
      shots.push({ ...base, vx:  120, vy: -player.bulletSpeed });
    } else {
      shots.push({ ...base, vx: -160, vy: -player.bulletSpeed });
      shots.push({ ...base, vx:   0,  vy: -player.bulletSpeed });
      shots.push({ ...base, vx:  160, vy: -player.bulletSpeed });
    }

    for (const b of shots) pBullets.push(b);
  }

  function enemyShoot(e){
    // æœç©å®¶æ–¹å‘å°„
    const dx = player.x - e.x;
    const dy = player.y - e.y;
    const len = Math.hypot(dx,dy) || 1;
    let spd = e.bulletSpeed;
    if (buffs.slow > 0) spd *= 0.75;

    const vx = (dx/len) * spd;
    const vy = (dy/len) * spd;

    eBullets.push({ x:e.x, y:e.y+e.r+4, r:4, vx, vy, dmg: (e.type==='boss'? 12+state.stage*2 : 7+state.stage), alive:true });
  }

  function damagePlayer(dmg){
    if (player.shield > 0){
      const use = Math.min(player.shield, dmg);
      player.shield -= use;
      dmg -= use;
    }
    if (dmg > 0){
      player.hp = Math.max(0, player.hp - dmg);
    }
    if (player.hp <= 0){
      // game over: reset (ç°¡å–®ç²—æš´)
      toastMsg('ä½ å€’äº†â€¦é‡æ–°é–‹å§‹', 1.2);
      resetRun();
    }
  }

  function resetRun(){
    // ä¿ç•™ï¼šä½ å¯ä»¥æƒ³è¦ã€Œè·¨å±€é¤Šæˆã€æ™‚å†æ”¹æˆä¸é‡ç½®éƒ¨åˆ†åƒæ•¸
    state.stage = 1;
    state.wave  = 1;
    state.score = 0;
    state.xp = 0;
    state.level = 1;
    state.nextXp = 40;
    state.waveClearCooldown = 0;
    state.waveInProgress = false;
    state.bossAlive = false;

    player.hpMax = 100;
    player.hp = 100;
    player.moveSpeed = 520;
    player.fireRate = 8;
    player.dmg = 12;
    player.bulletSpeed = 820;
    player.spread = 0;
    player.pierce = 0;
    player.shield = 0;
    player.shieldMax = 0;

    for (const k in buffs) buffs[k]=0;

    pBullets = [];
    eBullets = [];
    enemies  = [];
    drops    = [];
    particles= [];

    spawnWave();
  }

  // -----------------------
  // Particles / Toast
  // -----------------------
  function addBurst(x,y,n=10){
    for (let i=0;i<n;i++){
      particles.push({
        x,y,
        vx: rand(-220,220),
        vy: rand(-220,220),
        life: rand(0.25, 0.55),
      });
    }
  }

  let toastT = 0;
  function toastMsg(text, sec=0.75){
    $toast.textContent = text;
    $toast.classList.add('show');
    toastT = sec;
  }

  // -----------------------
  // Update / Draw
  // -----------------------
  function update(dt){
    // buffs
    for (const k in buffs){
      if (buffs[k] > 0) buffs[k] = Math.max(0, buffs[k] - dt);
    }

    // player position: pad controls; clamp to board
    player.y = H - 42;
    player.x = clamp(player.x, player.r+8, W - player.r - 8);

    // auto shoot
    shoot(dt);

    // enemies behavior
    const holdY = enemyHoldY();
    let aliveBoss = false;

    for (const e of enemies){
      // enter to targetY, then hold/strafe
      e.y = lerp(e.y, e.targetY, clamp(dt*2.6, 0, 1));

      // strafe if any
      if (e.strafeAmp > 0){
        e.strafePhase += dt * e.strafeSpd;
        const ox = Math.sin(e.strafePhase) * e.strafeAmp;
        // boss: center around mid
        if (e.type === 'boss'){
          e.x = W*0.5 + ox;
        }else{
          // mobs: center around original lane x (store base?)
          if (e.baseX == null) e.baseX = e.x;
          e.x = e.baseX + ox;
        }
      }
      e.x = clamp(e.x, e.r+10, W-e.r-10);

      // fire
      e.fireCd -= dt;
      if (e.fireCd <= 0){
        enemyShoot(e);
        // boss å¶çˆ¾æ‰‡å½¢å½ˆ
        if (e.type === 'boss' && (e.hp/e.hpMax) < 0.65 && Math.random() < 0.45){
          // extra 2 bullets
          const spd = (buffs.slow>0? e.bulletSpeed*0.75 : e.bulletSpeed);
          const ang = Math.atan2(player.y - e.y, player.x - e.x);
          for (const da of [-0.22, 0.22]){
            eBullets.push({ x:e.x, y:e.y+e.r+4, r:4, vx: Math.cos(ang+da)*spd, vy: Math.sin(ang+da)*spd, dmg: 11+state.stage*2, alive:true });
          }
        }
        e.fireCd = 1 / e.fireRate;
      }

      if (e.hitFlash > 0) e.hitFlash = Math.max(0, e.hitFlash - dt);

      if (e.type === 'boss' && e.hp > 0) aliveBoss = true;
    }

    // bullets
    for (const b of pBullets){
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      if (b.y < -20 || b.x < -30 || b.x > W+30) b.alive = false;
    }
    for (const b of eBullets){
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      if (b.y > H+30 || b.x < -30 || b.x > W+30) b.alive = false;
    }

    // drops
    for (const d of drops){
      d.y += d.vy * dt;
      d.life -= dt;
      // magnet
      if (buffs.magnet > 0){
        const dx = player.x - d.x;
        const dy = player.y - d.y;
        const l = Math.hypot(dx,dy) || 1;
        d.x += (dx/l) * 240 * dt;
        d.y += (dy/l) * 240 * dt;
      }
      if (d.y > H+40 || d.life <= 0) d.dead = true;

      // collect
      if (dist2(d.x,d.y, player.x, player.y) < (d.r + player.r + 8)**2){
        d.dead = true;
        applyDrop(d.type);
      }
    }

    // particles
    for (const p of particles){
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= (1 - dt*2.8);
      p.vy *= (1 - dt*2.8);
      p.life -= dt;
      if (p.life <= 0) p.dead = true;
    }

    // collisions: player bullets vs enemies
    for (const b of pBullets){
      if (!b.alive) continue;

      // also allow shooting enemy bullets
      for (const eb of eBullets){
        if (!eb.alive) continue;
        if (dist2(b.x,b.y, eb.x, eb.y) < (b.r + eb.r + 2)**2){
          eb.alive = false;
          // bullet can continue unless no pierce, we treat as small hit
          if (b.pierce <= 0) b.alive = false;
          else b.pierce -= 1;
          addBurst(eb.x, eb.y, 4);
          state.score += 1;
        }
      }
      if (!b.alive) continue;

      for (const e of enemies){
        if (e.hp <= 0) continue;
        if (dist2(b.x,b.y, e.x, e.y) < (b.r + e.r)**2){
          e.hp -= b.dmg;
          e.hitFlash = 0.12;
          addBurst(b.x,b.y, 4);

          if (b.pierce <= 0) b.alive = false;
          else b.pierce -= 1;

          if (e.hp <= 0){
            // kill
            state.score += (e.type==='boss'? 220 : 18);
            addXp(e.type==='boss'? 90 : 8);
            maybeDrop(e.x, e.y, e.type==='boss');
            addBurst(e.x, e.y, e.type==='boss'? 22 : 10);
          }
          break;
        }
      }
    }

    // collisions: enemy bullets vs player
    for (const eb of eBullets){
      if (!eb.alive) continue;
      if (dist2(eb.x,eb.y, player.x, player.y) < (eb.r + player.r)**2){
        eb.alive = false;
        damagePlayer(eb.dmg);
        addBurst(player.x, player.y, 10);
      }
    }

    // cleanup
    pBullets = pBullets.filter(b=>b.alive);
    eBullets = eBullets.filter(b=>b.alive);
    enemies  = enemies.filter(e=>e.hp>0);
    drops    = drops.filter(d=>!d.dead);
    particles= particles.filter(p=>!p.dead);

    // wave progression
    if (!state.waveInProgress){
      state.waveClearCooldown -= dt;
      if (state.waveClearCooldown <= 0){
        // decide spawn: wave or boss or next stage
        if (state.wave === state.bossEveryWaves){
          spawnBoss();
          state.waveInProgress = true;
        }else{
          spawnWave();
        }
      }
    }else{
      // if wave in progress, check cleared
      if (enemies.length === 0){
        // if boss was wave boss => stage up
        if (state.wave === state.bossEveryWaves){
          nextStage();
        }else{
          nextWave();
        }
      }
    }

    // toast timer
    if (toastT > 0){
      toastT = Math.max(0, toastT - dt);
      if (toastT === 0 && !paused) $toast.classList.remove('show');
    }
  }

  function draw(){
    // clear (no trail!)
    ctx.clearRect(0,0,W,H);

    // background grid
    ctx.save();
    ctx.globalAlpha = 0.10;
    ctx.strokeStyle = '#e7eefc';
    const step = 48;
    for (let x=0;x<=W;x+=step){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
    }
    for (let y=0;y<=H;y+=step){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
    }
    ctx.restore();

    // particles
    ctx.save();
    ctx.fillStyle = 'rgba(120,255,200,.7)';
    for (const p of particles){
      ctx.globalAlpha = clamp(p.life*2.0, 0, 1);
      ctx.beginPath();
      ctx.arc(p.x,p.y,2.2,0,Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // drops
    for (const d of drops){
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,.08)';
      ctx.strokeStyle = 'rgba(255,255,255,.18)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(d.x,d.y,d.r,0,Math.PI*2);
      ctx.fill(); ctx.stroke();

      ctx.globalAlpha = 0.9;
      ctx.fillStyle = 'rgba(120,255,200,.95)';
      ctx.font = '12px system-ui, "Noto Sans TC"';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const icon = d.type==='heal'?'âœš': d.type==='shield'?'â›¨': d.type==='rapid'?'âš¡': d.type==='spread'?'âœ¦': d.type==='bomb'?'ğŸ’£': d.type==='magnet'?'ğŸ§²':'ğŸ¢';
      ctx.fillText(icon, d.x, d.y+0.5);
      ctx.restore();
    }

    // enemies
    for (const e of enemies){
      ctx.save();
      const isBoss = e.type==='boss';
      const flash = e.hitFlash > 0;
      ctx.fillStyle = flash ? 'rgba(255,255,255,.18)' : (isBoss ? 'rgba(255,120,120,.14)' : 'rgba(255,255,255,.10)');
      ctx.strokeStyle = isBoss ? 'rgba(255,120,120,.35)' : 'rgba(255,255,255,.20)';
      ctx.lineWidth = isBoss ? 2 : 1;

      ctx.beginPath();
      ctx.arc(e.x,e.y,e.r,0,Math.PI*2);
      ctx.fill();
      ctx.stroke();

      // hp bar
      const w = isBoss ? 90 : 52;
      const h = 6;
      const x = e.x - w/2;
      const y = e.y - e.r - 14;
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = 'rgba(255,255,255,.10)';
      ctx.fillRect(x,y,w,h);
      ctx.fillStyle = isBoss ? 'rgba(255,120,120,.9)' : 'rgba(120,255,200,.9)';
      ctx.fillRect(x,y, w * clamp(e.hp/e.hpMax,0,1), h);
      ctx.restore();
    }

    // player bullets
    ctx.save();
    ctx.fillStyle = 'rgba(120,255,200,.95)';
    for (const b of pBullets){
      ctx.beginPath();
      ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // enemy bullets
    ctx.save();
    ctx.fillStyle = 'rgba(255,160,160,.92)';
    for (const b of eBullets){
      ctx.beginPath();
      ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // player
    ctx.save();
    // body (triangle-ish)
    ctx.translate(player.x, player.y);
    ctx.fillStyle = 'rgba(255,255,255,.10)';
    ctx.strokeStyle = 'rgba(255,255,255,.22)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(0, -player.r-2);
    ctx.lineTo(player.r+2, player.r+4);
    ctx.lineTo(-player.r-2, player.r+4);
    ctx.closePath();
    ctx.fill(); ctx.stroke();

    // shield ring
    if (player.shield > 0){
      ctx.globalAlpha = 0.85;
      ctx.strokeStyle = 'rgba(120,255,200,.45)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0,0, player.r+10, 0, Math.PI*2);
      ctx.stroke();
    }
    ctx.restore();
  }

  function syncHud(){
    $stage.textContent = `é—œå¡ ${state.stage}`;
    $wave.textContent  = `æ³¢æ¬¡ ${state.wave}`;
    $lv.textContent    = `ç­‰ç´š ${state.level}`;
    $score.textContent = `åˆ†æ•¸ ${state.score}`;

    const hpPct = clamp(player.hp / player.hpMax, 0, 1);
    $hpFill.style.width = `${hpPct*100}%`;

    // é¡¯ç¤ºè­·ç›¾åŠ æˆåœ¨æ•¸å­—å¾Œï¼ˆä¸ä½”å¤ªå¤šç©ºé–“ï¼‰
    const shieldTxt = player.shield > 0 ? ` +${Math.floor(player.shield)}` : '';
    $hpNum.textContent = `${Math.floor(player.hp)}/${Math.floor(player.hpMax)}${shieldTxt}`;
  }

  // -----------------------
  // Main loop
  // -----------------------
  let lastT = performance.now();
  function frame(t){
    const dt = Math.min(0.033, (t - lastT)/1000);
    lastT = t;

    if (!paused){
      update(dt);
    }
    draw();
    syncHud();

    requestAnimationFrame(frame);
  }

  // init
  setPadX(0.5);
  spawnWave();
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
