<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
  <title>Blaster</title>
  <meta name="theme-color" content="#0b1220" />

  <style>
    :root { color-scheme: dark; }
    html, body{
      height:100%;
      margin:0;
      background:#0b1220;
      color:#e7eefc;
      font-family: system-ui, "Noto Sans TC", sans-serif;
      -webkit-user-select:none; user-select:none;
      touch-action: manipulation;
      overflow:hidden;
    }
    body{ position:fixed; inset:0; }

    .app{
      height:100svh;
      padding-top: calc(env(safe-area-inset-top) + 10px);
      padding-right: calc(env(safe-area-inset-right) + 10px);
      padding-bottom: calc(env(safe-area-inset-bottom) + 10px);
      padding-left: calc(env(safe-area-inset-left) + 10px);
      display:flex;
      flex-direction:column;
      gap:10px;
      box-sizing:border-box;
    }

    .hud{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:space-between;
    }
    .hudLeft, .hudRight{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    .pill, button.pill{
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color:#e7eefc;
      padding:10px 12px;
      font-size:14px;
      line-height:1;
      white-space:nowrap;
      -webkit-tap-highlight-color: transparent;
    }
    button.pill{ cursor:pointer; }
    button.pill:active{ transform: scale(.99); }

    .hpbar{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
    }
    .hpbar .label{ opacity:.85; font-weight:700; }
    .hpbar .track{
      width:min(420px, 46vw);
      height:14px;
      border-radius:999px;
      background: rgba(255,255,255,.10);
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
    }
    .hpbar .fill{
      height:100%;
      width:50%;
      background: rgba(120,255,200,.95);
    }
    .hpbar .num{ opacity:.85; font-variant-numeric: tabular-nums; }

    .main{
      flex:1;
      min-height:0;
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .boardWrap{
      flex:1;
      min-height:0;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      background: radial-gradient(1200px 800px at 50% 0%, rgba(90,120,255,.10), transparent 60%),
                  rgba(255,255,255,.03);
      overflow:hidden;
      position:relative;
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
    }

    .touchpad{
      flex:0 0 auto;
      height: max(86px, 13svh);
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      position:relative;
      overflow:hidden;
      -webkit-tap-highlight-color: transparent;
    }
    .touchpad .hint{
      position:absolute;
      inset:auto 0 10px 0;
      text-align:center;
      font-size:14px;
      opacity:.75;
      pointer-events:none;
    }
    .touchpad .bar{
      position:absolute;
      left:10px; right:10px;
      top:16px; bottom:16px;
      border-radius:14px;
      border:1px dashed rgba(255,255,255,.18);
      opacity:.7;
    }
    .touchpad .thumb{
      position:absolute;
      top:50%;
      width:46px; height:46px;
      transform: translate(-50%,-50%);
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.08);
      box-shadow: 0 8px 30px rgba(0,0,0,.35);
      pointer-events:none;
    }

    .overlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.58);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      z-index: 50;
    }
    .overlay.show{ display:flex; }
    .panel{
      width:min(720px, 92vw);
      border-radius:18px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(15,22,40,.92);
      padding:16px;
      box-shadow: 0 18px 70px rgba(0,0,0,.55);
    }
    .panel h2{
      margin:0 0 10px;
      font-size:18px;
      letter-spacing:.2px;
    }
    .opts{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
    }
    @media (min-width: 720px){
      .opts{ grid-template-columns: 1fr 1fr 1fr; }
    }
    .opt{
      border-radius:16px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      padding:14px;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
    }
    .opt:active{ transform: scale(.99); }
    .opt .t{ font-weight:900; margin-bottom:6px; }
    .opt .d{ opacity:.78; font-size:13px; line-height:1.4; }

    .toast{
      position:absolute;
      left:50%;
      top:16px;
      transform: translateX(-50%);
      padding:10px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.35);
      font-size:13px;
      opacity:.9;
      display:none;
      pointer-events:none;
    }
    .toast.show{ display:block; }
  </style>
</head>

<body>
  <div class="app">
    <div class="hud">
      <div class="hudLeft">
        <button class="pill" id="btnHub">â† Hub</button>
        <span class="pill" id="hudStage">é—œå¡ 1</span>
        <span class="pill" id="hudWave">æ³¢æ¬¡ 1</span>
        <span class="pill" id="hudLv">ç­‰ç´š 1</span>
        <span class="pill" id="hudScore">åˆ†æ•¸ 0</span>
      </div>
      <div class="hudRight">
        <div class="hpbar">
          <span class="label">HP</span>
          <div class="track"><div class="fill" id="hpFill"></div></div>
          <span class="num" id="hpNum">100/100</span>
        </div>
        <button class="pill" id="btnPause">æš«åœ</button>
      </div>
    </div>

    <div class="main">
      <div class="boardWrap" id="boardWrap">
        <canvas id="c"></canvas>
        <div class="toast" id="toast">Paused</div>
      </div>

      <div class="touchpad" id="touchpad" aria-label="touchpad">
        <div class="bar"></div>
        <div class="thumb" id="thumb" style="left:50%;"></div>
        <div class="hint">å·¦å³æ‹–æ›³ï¼ç§»å‹•ï¼ˆè‡ªå‹•å°„æ“Šï¼‰</div>
      </div>
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="panel">
      <h2>å‡ç´šï¼šé¸ä¸€å€‹</h2>
      <div class="opts" id="opts"></div>
    </div>
  </div>

<script>
(() => {
  // -----------------------
  // Canvas / Resize
  // -----------------------
  const wrap = document.getElementById('boardWrap');
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });

  function resize(){
    const r = wrap.getBoundingClientRect();
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    canvas.width = Math.floor(r.width * dpr);
    canvas.height = Math.floor(r.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    W = r.width; H = r.height;
  }
  let W=0, H=0;
  window.addEventListener('resize', resize);
  resize();

  // -----------------------
  // HUD / UI
  // -----------------------
  const $stage = document.getElementById('hudStage');
  const $wave  = document.getElementById('hudWave');
  const $lv    = document.getElementById('hudLv');
  const $score = document.getElementById('hudScore');
  const $hpFill= document.getElementById('hpFill');
  const $hpNum = document.getElementById('hpNum');
  const $btnPause = document.getElementById('btnPause');
  const $toast = document.getElementById('toast');
  const $btnHub = document.getElementById('btnHub');

  $btnHub.addEventListener('click', () => {
    location.href = '../';
  });

  let paused = false;
  $btnPause.addEventListener('click', () => {
    paused = !paused;
    $btnPause.textContent = paused ? 'ç¹¼çºŒ' : 'æš«åœ';
    $toast.textContent = paused ? 'Paused' : '';
    $toast.classList.toggle('show', paused);
    if (!paused) lastT = performance.now();
  });

  // -----------------------
  // Touchpad control
  // -----------------------
  const pad = document.getElementById('touchpad');
  const thumb = document.getElementById('thumb');
  let padActive = false;
  let padX = 0.5; // 0..1

  const lerp = (a,b,t)=> a + (b-a)*t;
  const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
  function setPadX(nx){
    padX = Math.max(0, Math.min(1, nx));
    thumb.style.left = `${padX*100}%`;
    player.x = lerp(player.x, padX * W, 1);
  }
  function pointerToPadX(e){
    const r = pad.getBoundingClientRect();
    return (e.clientX - r.left) / r.width;
  }
  pad.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    pad.setPointerCapture(e.pointerId);
    padActive = true;
    setPadX(pointerToPadX(e));
  });
  pad.addEventListener('pointermove', (e) => {
    if (!padActive) return;
    e.preventDefault();
    setPadX(pointerToPadX(e));
  });
  pad.addEventListener('pointerup', (e) => {
    padActive = false;
    try{ pad.releasePointerCapture(e.pointerId); }catch(_){}
  });
  pad.addEventListener('pointercancel', () => padActive = false);

  // -----------------------
  // Helpers
  // -----------------------
  const rand = (a,b)=> a + Math.random()*(b-a);
  const dist2 = (ax,ay,bx,by)=> { const dx=ax-bx, dy=ay-by; return dx*dx + dy*dy; };

  // -----------------------
  // Game State
  // -----------------------
  const state = {
    stage: 1,
    wave: 1,
    score: 0,
    time: 0,
    xp: 0,
    level: 1,

    // B) å‡ç´šè®Šæ…¢ï¼šèµ·å§‹ nextXp æ‹‰é«˜ + æˆé•·å€ç‡æé«˜
    nextXp: 70,
    waveClearCooldown: 0,
    waveInProgress: false,
    bossAlive: false,
    bossEveryWaves: 5,
  };

  // Player build
  const player = {
    x: W*0.5,
    y: 0,
    r: 14,
    hp: 100,
    hpMax: 100,
    moveSpeed: 520,
    fireRate: 8,
    dmg: 12,
    bulletSpeed: 820,
    spread: 0,           // 0..2 (perm)
    pierce: 0,           // 0..2
    shield: 0,
    shieldMax: 0,
  };

  // Entities
  let pBullets = [];
  let eBullets = [];
  let enemies  = [];
  let drops    = [];
  let particles= [];

  function enemyHoldY(){
    return clamp(H * 0.18, 110, 190);
  }

  // -----------------------
  // Wave system
  // -----------------------
  // C) å°æ€ªï¼šè¡€é‡/å°„é€Ÿ/å½ˆé€Ÿæ›´æœ‰æ„Ÿä¸Šå‡
  function waveConfig(stage, wave){
    const baseCount = 5 + Math.floor((stage-1)*1.35) + Math.floor((wave-1)*1.05);
    const count = clamp(baseCount, 5, 16);

    // æ›´ç¡¬
    const hp = 28 + stage*10 + wave*6;

    // æ›´å…‡ï¼šå°„æ›´é »ã€å½ˆæ›´å¿«
    const fire = 0.75 + stage*0.14 + wave*0.12; // shots/sec
    const bullet = 285 + stage*28 + wave*20;

    // è®“å‚·å®³ä¹Ÿè·Ÿè‘—æœ‰æ„Ÿï¼ˆé¿å…è®Šæˆç´”å½ˆå¹•è¡¨æ¼”ï¼‰
    const dmg = 7 + stage*1.2 + wave*0.8;

    return { count, hp, fire, bullet, dmg };
  }

  function spawnWave(){
    enemies.length = 0;
    eBullets.length = 0;
    state.waveInProgress = true;
    state.bossAlive = false;

    const cfg = waveConfig(state.stage, state.wave);
    const holdY = enemyHoldY();
    const lanes = cfg.count;

    for (let i=0;i<lanes;i++){
      const x = (i+1) * (W/(lanes+1));
      const isStrafe = Math.random() < (0.42 + state.stage*0.04);
      const strafeAmp = isStrafe ? rand(60, 150) : 0;
      const strafeSpd = isStrafe ? rand(0.95, 2.05) : 0;

      enemies.push({
        type: 'mob',
        x,
        y: -40 - i*18,
        targetY: holdY + rand(-18, 18),
        r: 15,
        hp: cfg.hp,
        hpMax: cfg.hp,
        fireCd: rand(0.25, 1.1),
        fireRate: cfg.fire,
        bulletSpeed: cfg.bullet,
        bulletDmg: cfg.dmg,
        strafeAmp,
        strafeSpd,
        strafePhase: rand(0, Math.PI*2),
        hitFlash: 0,
      });
    }
  }

  // å¬å–šç”¨ï¼šä¸é‡ç½®æ³¢æ¬¡ï¼Œç›´æ¥åŠ æ€ª
  function spawnAdds(count=4, power=0.78){
    const cfg = waveConfig(state.stage, state.wave);
    const holdY = enemyHoldY() + rand(8, 22);
    for (let i=0;i<count;i++){
      const x = rand(40, W-40);
      const isStrafe = Math.random() < 0.7;
      const strafeAmp = isStrafe ? rand(60, 140) : 0;
      const strafeSpd = isStrafe ? rand(1.0, 2.2) : 0;

      const hp = Math.max(18, cfg.hp * power);
      enemies.push({
        type: 'mob',
        x,
        y: -60 - i*24,
        targetY: holdY + rand(-14, 14),
        r: 14,
        hp: hp,
        hpMax: hp,
        fireCd: rand(0.25, 0.95),
        fireRate: cfg.fire * (0.95 + rand(-0.05,0.10)),
        bulletSpeed: cfg.bullet * (0.92 + rand(-0.04,0.08)),
        bulletDmg: cfg.dmg * (0.9 + rand(-0.05,0.10)),
        strafeAmp,
        strafeSpd,
        strafePhase: rand(0, Math.PI*2),
        hitFlash: 0,
      });
    }
    toastMsg(`Boss å¬å–šå°æ€ª x${count}`, 0.65);
  }

  // C) Boss è®Šç¡¬ã€è®Šå…‡ã€æœƒè®Šæ‹›ï¼šå¤šéšæ®µï¼ˆ70%/40%ï¼‰
  function spawnBoss(){
    state.bossAlive = true;
    const holdY = enemyHoldY() - 10;

    const hp = 680 + state.stage*190; // æ›´ç¡¬
    const baseFire = 1.05 + state.stage*0.14;
    const baseSpd  = 340 + state.stage*22;

    enemies.push({
      type: 'boss',
      x: W*0.5,
      y: -90,
      targetY: holdY,
      r: 28,

      hp,
      hpMax: hp,

      // base statsï¼ˆphase æœƒå¥— multiplierï¼‰
      baseFireRate: baseFire,
      baseBulletSpeed: baseSpd,
      baseBulletDmg: 13 + state.stage*2.2,

      fireRate: baseFire,
      bulletSpeed: baseSpd,
      bulletDmg: 13 + state.stage*2.2,

      fireCd: 0.8,
      strafeAmp: 240,
      strafeSpd: 1.10 + state.stage*0.09,
      strafePhase: 0,

      phase: 1,
      patternCd: 1.9,   // å½ˆå¹•æŠ€èƒ½å†·å»
      summonCd: 5.2,    // å¬å–šå†·å»ï¼ˆphase3 æ‰æœƒç”¨ï¼‰
      rageSpin: 0,      // phase3 ç”¨ï¼šæ—‹è½‰å½ˆå¹•
      hitFlash: 0,
    });

    toastMsg('Boss å…¥å ´', 0.75);
  }

  function nextWave(){
    state.wave += 1;
    state.waveClearCooldown = 0.55;
    state.waveInProgress = false;
  }

  function nextStage(){
    state.stage += 1;
    state.wave = 1;
    state.waveClearCooldown = 0.85;
    state.waveInProgress = false;
  }

  // -----------------------
  // Drop system
  // -----------------------
  const DROP_TYPES = [
    { key:'heal',  t:'å›è¡€',   d:'+25 HP', w: 26 },
    { key:'shield',t:'è­·ç›¾',   d:'+20 Shield', w: 18 },
    { key:'rapid', t:'æ€¥é€Ÿå°„æ“Š', d:'å°„é€Ÿ +25%ï¼ˆçŸ­æ•ˆï¼‰', w: 16 },
    { key:'spread',t:'æ•£å°„',  d:'æ•£å°„ +1ï¼ˆçŸ­æ•ˆï¼‰', w: 14 },
    { key:'bomb',  t:'ç‚¸å½ˆ',  d:'æ¸…å ´ï¼ˆæ•µ/å½ˆï¼‰', w: 8 },
    { key:'magnet',t:'ç£éµ',  d:'å¸é“å…·ï¼ˆçŸ­æ•ˆï¼‰', w: 10 },
    { key:'slow',  t:'ç·©é€Ÿ',  d:'æ•µå½ˆè®Šæ…¢ï¼ˆçŸ­æ•ˆï¼‰', w: 8 },
  ];

  function pickDrop(){
    const total = DROP_TYPES.reduce((s,a)=>s+a.w,0);
    let r = Math.random()*total;
    for (const it of DROP_TYPES){
      r -= it.w;
      if (r<=0) return it.key;
    }
    return 'heal';
  }

  function maybeDrop(x,y, isBoss=false){
    const p = isBoss ? 0.95 : 0.22;
    if (Math.random() > p) return;
    drops.push({
      x, y,
      r: 10,
      vy: rand(40, 90),
      type: pickDrop(),
      life: 12,
    });
  }

  // Timed buffs
  const buffs = {
    rapid: 0,
    spread: 0,
    magnet: 0,
    slow: 0,
  };

  function applyDrop(type){
    if (type === 'heal'){
      player.hp = clamp(player.hp + 25, 0, player.hpMax);
      toastMsg('HP +25');
    } else if (type === 'shield'){
      player.shieldMax = Math.max(player.shieldMax, 20);
      player.shield = clamp(player.shield + 20, 0, player.shieldMax);
      toastMsg('Shield +20');
    } else if (type === 'rapid'){
      buffs.rapid = Math.max(buffs.rapid, 7.5);
      toastMsg('Rapid Fire!');
    } else if (type === 'spread'){
      buffs.spread = Math.max(buffs.spread, 7.5);
      toastMsg('Spread!');
    } else if (type === 'bomb'){
      let killed = 0;
      for (const e of enemies){
        if (e.type !== 'boss'){
          e.hp = 0;
          killed++;
          maybeDrop(e.x, e.y, false);
          addBurst(e.x,e.y, 12);
        }
      }
      eBullets.length = 0;
      toastMsg(`BOMB! (+${killed} mobs)`);
    } else if (type === 'magnet'){
      buffs.magnet = Math.max(buffs.magnet, 9.0);
      toastMsg('Magnet');
    } else if (type === 'slow'){
      buffs.slow = Math.max(buffs.slow, 7.5);
      toastMsg('Slow');
    }
  }

  // -----------------------
  // Level-up (3é¸1)
  // -----------------------
  const overlay = document.getElementById('overlay');
  const opts = document.getElementById('opts');

  const UPGRADES = [
    { key:'dmg', t:'ç«åŠ›æå‡', d:'å‚·å®³ +20%' },
    { key:'firerate', t:'å°„é€Ÿæå‡', d:'å°„é€Ÿ +18%' },
    { key:'hp', t:'æ“´å……è£ç”²', d:'HP ä¸Šé™ +20ï¼Œå›æ»¿' },
    { key:'speed', t:'æ©Ÿå‹•æå‡', d:'ç§»å‹•é€Ÿåº¦ +16%' },
    { key:'pierce', t:'ç©¿é€å½ˆ', d:'ç©¿é€ +1ï¼ˆæœ€å¤š 2ï¼‰' },
    { key:'spread_perm', t:'æ°¸ä¹…æ•£å°„', d:'æ•£å°„ +1ï¼ˆæœ€å¤š 2ï¼‰' },
    { key:'shield_cap', t:'è­·ç›¾æ“´å®¹', d:'è­·ç›¾ä¸Šé™ +20ï¼Œä¸¦å›æ»¿' },
  ];

  function openLevelUp(){
    paused = true;
    $btnPause.textContent = 'ç¹¼çºŒ';
    $toast.textContent = 'Level Up';
    $toast.classList.add('show');

    overlay.classList.add('show');
    opts.innerHTML = '';

    const pool = [...UPGRADES];
    const picks = [];
    while (picks.length < 3 && pool.length){
      const i = Math.floor(Math.random()*pool.length);
      picks.push(pool.splice(i,1)[0]);
    }

    for (const u of picks){
      const el = document.createElement('div');
      el.className = 'opt';
      el.innerHTML = `<div class="t">${u.t}</div><div class="d">${u.d}</div>`;
      el.addEventListener('click', () => {
        applyUpgrade(u.key);
        overlay.classList.remove('show');
        paused = false;
        $btnPause.textContent = 'æš«åœ';
        $toast.classList.remove('show');
        lastT = performance.now();
      });
      opts.appendChild(el);
    }
  }

  function applyUpgrade(key){
    if (key === 'dmg'){
      player.dmg *= 1.20;
    } else if (key === 'firerate'){
      player.fireRate *= 1.18;
    } else if (key === 'hp'){
      player.hpMax += 20;
      player.hp = player.hpMax;
    } else if (key === 'speed'){
      player.moveSpeed *= 1.16;
    } else if (key === 'pierce'){
      player.pierce = Math.min(2, player.pierce + 1);
    } else if (key === 'spread_perm'){
      player.spread = Math.min(2, player.spread + 1);
    } else if (key === 'shield_cap'){
      player.shieldMax += 20;
      player.shield = player.shieldMax;
    }
  }

  function addXp(xp){
    state.xp += xp;
    while (state.xp >= state.nextXp){
      state.xp -= state.nextXp;
      state.level += 1;

      // B) å‡ç´šè®Šæ…¢ï¼šæˆé•·å€ç‡æé«˜ï¼ˆæ›´å¿«è®Šè²´ï¼‰
      state.nextXp = Math.floor(state.nextXp * 1.30 + 14);

      openLevelUp();
    }
  }

  // -----------------------
  // Combat
  // -----------------------
  let fireAcc = 0;

  function shoot(dt){
    const rate = player.fireRate * (buffs.rapid > 0 ? 1.25 : 1.0);
    fireAcc += dt * rate;
    while (fireAcc >= 1){
      fireAcc -= 1;
      spawnPlayerShot();
    }
  }

  // A) æ•£å°„ä¸å†ç­‰æ–¼å…è²» 3 å€è¼¸å‡ºï¼šå­å½ˆè®Šå¤šï¼Œä½†æ¯é¡†å‚·å®³ç¨€é‡‹
  // 2æ¢ï¼šæ¯é¡† Ã—0.72ï¼ˆç¸½ç´„ 1.44 å€ï¼‰
  // 3æ¢ï¼šæ¯é¡† Ã—0.58ï¼ˆç¸½ç´„ 1.74 å€ï¼‰
  function spreadDmgMultiplier(shots){
    if (shots === 2) return 0.72;
    if (shots === 3) return 0.58;
    return 1.0;
  }

  function spawnPlayerShot(){
    const spreadBonus = (buffs.spread > 0 ? 1 : 0);
    const s = clamp(player.spread + spreadBonus, 0, 3);

    // shots count: 1 / 2 / 3
    const shotsCount = (s <= 0) ? 1 : (s === 1 ? 2 : 3);
    const dmgMul = spreadDmgMultiplier(shotsCount);
    const perShotDmg = player.dmg * dmgMul;

    const base = {
      x: player.x,
      y: player.y - player.r - 6,
      r: 4,
      vx: 0,
      vy: -player.bulletSpeed,
      dmg: perShotDmg,
      pierce: player.pierce,
      alive: true
    };

    const shots = [];

    if (shotsCount === 1){
      shots.push(base);
    } else if (shotsCount === 2){
      shots.push({ ...base, vx: -120 });
      shots.push({ ...base, vx:  120 });
    } else {
      shots.push({ ...base, vx: -160 });
      shots.push({ ...base, vx:    0 });
      shots.push({ ...base, vx:  160 });
    }

    for (const b of shots) pBullets.push(b);
  }

  function enemyShoot(e, angleOverride=null, speedMul=1, dmgMul=1){
    const dx = player.x - e.x;
    const dy = player.y - e.y;
    const ang = angleOverride ?? Math.atan2(dy, dx);

    let spd = e.bulletSpeed * speedMul;
    if (buffs.slow > 0) spd *= 0.75;

    const vx = Math.cos(ang) * spd;
    const vy = Math.sin(ang) * spd;

    const dmg = (e.bulletDmg ?? (e.type==='boss' ? 14 : 8)) * dmgMul;
    eBullets.push({ x:e.x, y:e.y+e.r+4, r:4, vx, vy, dmg, alive:true });
  }

  // Boss å°ˆç”¨ï¼šå½ˆå¹•/è®Šæ‹›/å¬å–š
  function bossPhase(e){
    const ratio = e.hp / e.hpMax;
    if (ratio <= 0.40) return 3;
    if (ratio <= 0.70) return 2;
    return 1;
  }

  function bossApplyPhaseStats(e){
    const ph = bossPhase(e);
    if (ph !== e.phase){
      e.phase = ph;
      toastMsg(ph === 2 ? 'Bossï¼šPhase 2ï¼ˆå½ˆå¹•æ¨¡å¼ï¼‰' : 'Bossï¼šPhase 3ï¼ˆç‹‚æš´ï¼‰', 0.85);
      // phase åˆ‡æ›æ™‚ï¼Œç¨å¾®é‡ç½®æŠ€èƒ½å†·å»ï¼Œé¿å…å‰›é€² phase ç›´æ¥æ»¿å±æ ¸çˆ†
      e.patternCd = Math.min(e.patternCd, ph===3 ? 1.2 : 1.5);
      if (ph < 3) e.summonCd = 999; // phase3 æ‰å¬å–š
    }

    if (e.phase === 1){
      e.fireRate = e.baseFireRate * 1.0;
      e.bulletSpeed = e.baseBulletSpeed * 1.0;
      e.bulletDmg = e.baseBulletDmg * 1.0;
    } else if (e.phase === 2){
      e.fireRate = e.baseFireRate * 1.18;
      e.bulletSpeed = e.baseBulletSpeed * 1.06;
      e.bulletDmg = e.baseBulletDmg * 1.06;
    } else {
      // phase3ï¼šç‹‚æš´å°„é€Ÿ + æ›´å¿«å½ˆé€Ÿ + æ›´ç—›
      e.fireRate = e.baseFireRate * 1.65;
      e.bulletSpeed = e.baseBulletSpeed * 1.12;
      e.bulletDmg = e.baseBulletDmg * 1.14;
    }
  }

  function bossShootPattern(e, dt){
    const ang = Math.atan2(player.y - e.y, player.x - e.x);

    if (e.phase === 1){
      enemyShoot(e, ang);
      return;
    }

    if (e.phase === 2){
      // 3-way æ‰‡å½¢ + å¶çˆ¾ ring
      enemyShoot(e, ang);
      enemyShoot(e, ang - 0.18, 0.98, 0.95);
      enemyShoot(e, ang + 0.18, 0.98, 0.95);

      e.patternCd -= dt;
      if (e.patternCd <= 0){
        // ring burstï¼ˆå½ˆå¹•æ¨¡å¼ï¼‰
        const n = 10;
        const base = rand(0, Math.PI*2);
        for (let i=0;i<n;i++){
          const a = base + (i/n)*Math.PI*2;
          enemyShoot(e, a, 0.92, 0.9);
        }
        e.patternCd = 2.0 + rand(-0.2, 0.35);
      }
      return;
    }

    // phase 3ï¼š5-way + æ—‹è½‰å½ˆå¹• + å¬å–šå°æ€ª
    enemyShoot(e, ang, 1.02, 1.0);
    for (const da of [-0.24, -0.12, 0.12, 0.24]){
      enemyShoot(e, ang + da, 1.00, 0.92);
    }

    // spiral / rotating burst
    e.patternCd -= dt;
    e.rageSpin += dt * 1.6;
    if (e.patternCd <= 0){
      const n = 14;
      const base = e.rageSpin;
      for (let i=0;i<n;i++){
        const a = base + (i/n)*Math.PI*2;
        enemyShoot(e, a, 0.98, 0.88);
      }
      e.patternCd = 1.35 + rand(-0.15, 0.25);
    }

    // summon adds
    e.summonCd -= dt;
    if (e.summonCd <= 0){
      spawnAdds(4 + (Math.random()<0.35?1:0), 0.78);
      e.summonCd = 5.8 + rand(-0.6, 0.9);
    }
  }

  function damagePlayer(dmg){
    if (player.shield > 0){
      const use = Math.min(player.shield, dmg);
      player.shield -= use;
      dmg -= use;
    }
    if (dmg > 0){
      player.hp = Math.max(0, player.hp - dmg);
    }
    if (player.hp <= 0){
      toastMsg('ä½ å€’äº†â€¦é‡æ–°é–‹å§‹', 1.2);
      resetRun();
    }
  }

  function resetRun(){
    state.stage = 1;
    state.wave  = 1;
    state.score = 0;
    state.xp = 0;
    state.level = 1;

    // B) èµ·å§‹ nextXp æ‹‰é«˜
    state.nextXp = 70;

    state.waveClearCooldown = 0;
    state.waveInProgress = false;
    state.bossAlive = false;

    player.hpMax = 100;
    player.hp = 100;
    player.moveSpeed = 520;
    player.fireRate = 8;
    player.dmg = 12;
    player.bulletSpeed = 820;
    player.spread = 0;
    player.pierce = 0;
    player.shield = 0;
    player.shieldMax = 0;

    for (const k in buffs) buffs[k]=0;

    pBullets = [];
    eBullets = [];
    enemies  = [];
    drops    = [];
    particles= [];

    spawnWave();
  }

  // -----------------------
  // Particles / Toast
  // -----------------------
  function addBurst(x,y,n=10){
    for (let i=0;i<n;i++){
      particles.push({
        x,y,
        vx: rand(-220,220),
        vy: rand(-220,220),
        life: rand(0.25, 0.55),
      });
    }
  }

  let toastT = 0;
  function toastMsg(text, sec=0.75){
    $toast.textContent = text;
    $toast.classList.add('show');
    toastT = sec;
  }

  // -----------------------
  // Update / Draw
  // -----------------------
  function update(dt){
    for (const k in buffs){
      if (buffs[k] > 0) buffs[k] = Math.max(0, buffs[k] - dt);
    }

    player.y = H - 42;
    player.x = clamp(player.x, player.r+8, W - player.r - 8);

    shoot(dt);

    const holdY = enemyHoldY();

    for (const e of enemies){
      e.y = lerp(e.y, e.targetY, clamp(dt*2.6, 0, 1));

      if (e.strafeAmp > 0){
        e.strafePhase += dt * e.strafeSpd;
        const ox = Math.sin(e.strafePhase) * e.strafeAmp;
        if (e.type === 'boss'){
          e.x = W*0.5 + ox;
        }else{
          if (e.baseX == null) e.baseX = e.x;
          e.x = e.baseX + ox;
        }
      }
      e.x = clamp(e.x, e.r+10, W-e.r-10);

      // Boss phase update
      if (e.type === 'boss'){
        bossApplyPhaseStats(e);
      }

      // fire
      e.fireCd -= dt;
      if (e.fireCd <= 0){
        if (e.type === 'boss'){
          bossShootPattern(e, dt);
          e.fireCd = 1 / e.fireRate;
        } else {
          enemyShoot(e);
          e.fireCd = 1 / e.fireRate;
        }
      }

      if (e.hitFlash > 0) e.hitFlash = Math.max(0, e.hitFlash - dt);
    }

    // bullets
    for (const b of pBullets){
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      if (b.y < -20 || b.x < -30 || b.x > W+30) b.alive = false;
    }
    for (const b of eBullets){
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      if (b.y > H+30 || b.x < -30 || b.x > W+30) b.alive = false;
    }

    // drops
    for (const d of drops){
      d.y += d.vy * dt;
      d.life -= dt;

      if (buffs.magnet > 0){
        const dx = player.x - d.x;
        const dy = player.y - d.y;
        const l = Math.hypot(dx,dy) || 1;
        d.x += (dx/l) * 240 * dt;
        d.y += (dy/l) * 240 * dt;
      }

      if (d.y > H+40 || d.life <= 0) d.dead = true;

      if (dist2(d.x,d.y, player.x, player.y) < (d.r + player.r + 8)**2){
        d.dead = true;
        applyDrop(d.type);
      }
    }

    // particles
    for (const p of particles){
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= (1 - dt*2.8);
      p.vy *= (1 - dt*2.8);
      p.life -= dt;
      if (p.life <= 0) p.dead = true;
    }

    // collisions: player bullets vs enemy bullets
    for (const b of pBullets){
      if (!b.alive) continue;

      for (const eb of eBullets){
        if (!eb.alive) continue;
        if (dist2(b.x,b.y, eb.x, eb.y) < (b.r + eb.r + 2)**2){
          eb.alive = false;
          if (b.pierce <= 0) b.alive = false;
          else b.pierce -= 1;
          addBurst(eb.x, eb.y, 4);
          state.score += 1;
        }
      }
      if (!b.alive) continue;

      // collisions: player bullets vs enemies
      for (const e of enemies){
        if (e.hp <= 0) continue;
        if (dist2(b.x,b.y, e.x, e.y) < (b.r + e.r)**2){
          e.hp -= b.dmg;
          e.hitFlash = 0.12;
          addBurst(b.x,b.y, 4);

          if (b.pierce <= 0) b.alive = false;
          else b.pierce -= 1;

          if (e.hp <= 0){
            state.score += (e.type==='boss'? 280 : 18);

            // B) å°æ€ª XP ä¸‹ä¿®ã€Boss XP ä¸Šä¿®ï¼ˆé¼“å‹µæ‰“åˆ° Bossï¼‰
            addXp(e.type==='boss' ? 165 : 5);

            maybeDrop(e.x, e.y, e.type==='boss');
            addBurst(e.x, e.y, e.type==='boss'? 26 : 10);
          }
          break;
        }
      }
    }

    // collisions: enemy bullets vs player
    for (const eb of eBullets){
      if (!eb.alive) continue;
      if (dist2(eb.x,eb.y, player.x, player.y) < (eb.r + player.r)**2){
        eb.alive = false;
        damagePlayer(eb.dmg);
        addBurst(player.x, player.y, 10);
      }
    }

    // cleanup
    pBullets = pBullets.filter(b=>b.alive);
    eBullets = eBullets.filter(b=>b.alive);
    enemies  = enemies.filter(e=>e.hp>0);
    drops    = drops.filter(d=>!d.dead);
    particles= particles.filter(p=>!p.dead);

    // wave progression
    if (!state.waveInProgress){
      state.waveClearCooldown -= dt;
      if (state.waveClearCooldown <= 0){
        if (state.wave === state.bossEveryWaves){
          spawnBoss();
          state.waveInProgress = true;
        }else{
          spawnWave();
        }
      }
    }else{
      if (enemies.length === 0){
        if (state.wave === state.bossEveryWaves){
          nextStage();
        }else{
          nextWave();
        }
      }
    }

    if (toastT > 0){
      toastT = Math.max(0, toastT - dt);
      if (toastT === 0 && !paused) $toast.classList.remove('show');
    }
  }

  function draw(){
    ctx.clearRect(0,0,W,H);

    // background grid
    ctx.save();
    ctx.globalAlpha = 0.10;
    ctx.strokeStyle = '#e7eefc';
    const step = 48;
    for (let x=0;x<=W;x+=step){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
    }
    for (let y=0;y<=H;y+=step){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
    }
    ctx.restore();

    // particles
    ctx.save();
    ctx.fillStyle = 'rgba(120,255,200,.7)';
    for (const p of particles){
      ctx.globalAlpha = clamp(p.life*2.0, 0, 1);
      ctx.beginPath();
      ctx.arc(p.x,p.y,2.2,0,Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // drops
    for (const d of drops){
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,.08)';
      ctx.strokeStyle = 'rgba(255,255,255,.18)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(d.x,d.y,d.r,0,Math.PI*2);
      ctx.fill(); ctx.stroke();

      ctx.globalAlpha = 0.9;
      ctx.fillStyle = 'rgba(120,255,200,.95)';
      ctx.font = '12px system-ui, "Noto Sans TC"';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const icon = d.type==='heal'?'âœš': d.type==='shield'?'â›¨': d.type==='rapid'?'âš¡': d.type==='spread'?'âœ¦': d.type==='bomb'?'ğŸ’£': d.type==='magnet'?'ğŸ§²':'ğŸ¢';
      ctx.fillText(icon, d.x, d.y+0.5);
      ctx.restore();
    }

    // enemies
    for (const e of enemies){
      ctx.save();
      const isBoss = e.type==='boss';
      const flash = e.hitFlash > 0;

      ctx.fillStyle = flash ? 'rgba(255,255,255,.18)' : (isBoss ? 'rgba(255,120,120,.14)' : 'rgba(255,255,255,.10)');
      ctx.strokeStyle = isBoss ? 'rgba(255,120,120,.35)' : 'rgba(255,255,255,.20)';
      ctx.lineWidth = isBoss ? 2 : 1;

      ctx.beginPath();
      ctx.arc(e.x,e.y,e.r,0,Math.PI*2);
      ctx.fill();
      ctx.stroke();

      // hp bar
      const w = isBoss ? 96 : 52;
      const h = 6;
      const x = e.x - w/2;
      const y = e.y - e.r - 14;
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = 'rgba(255,255,255,.10)';
      ctx.fillRect(x,y,w,h);
      ctx.fillStyle = isBoss ? 'rgba(255,120,120,.9)' : 'rgba(120,255,200,.9)';
      ctx.fillRect(x,y, w * clamp(e.hp/e.hpMax,0,1), h);

      // boss phase indicator (subtle)
      if (isBoss){
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = 'rgba(255,255,255,.65)';
        ctx.font = '11px system-ui, "Noto Sans TC"';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        const ph = e.phase ?? 1;
        ctx.fillText(`P${ph}`, e.x, y-2);
      }

      ctx.restore();
    }

    // player bullets
    ctx.save();
    ctx.fillStyle = 'rgba(120,255,200,.95)';
    for (const b of pBullets){
      ctx.beginPath();
      ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // enemy bullets
    ctx.save();
    ctx.fillStyle = 'rgba(255,160,160,.92)';
    for (const b of eBullets){
      ctx.beginPath();
      ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // player
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.fillStyle = 'rgba(255,255,255,.10)';
    ctx.strokeStyle = 'rgba(255,255,255,.22)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(0, -player.r-2);
    ctx.lineTo(player.r+2, player.r+4);
    ctx.lineTo(-player.r-2, player.r+4);
    ctx.closePath();
    ctx.fill(); ctx.stroke();

    if (player.shield > 0){
      ctx.globalAlpha = 0.85;
      ctx.strokeStyle = 'rgba(120,255,200,.45)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0,0, player.r+10, 0, Math.PI*2);
      ctx.stroke();
    }
    ctx.restore();
  }

  function syncHud(){
    $stage.textContent = `é—œå¡ ${state.stage}`;
    $wave.textContent  = `æ³¢æ¬¡ ${state.wave}`;
    $lv.textContent    = `ç­‰ç´š ${state.level}`;
    $score.textContent = `åˆ†æ•¸ ${state.score}`;

    const hpPct = clamp(player.hp / player.hpMax, 0, 1);
    $hpFill.style.width = `${hpPct*100}%`;

    const shieldTxt = player.shield > 0 ? ` +${Math.floor(player.shield)}` : '';
    $hpNum.textContent = `${Math.floor(player.hp)}/${Math.floor(player.hpMax)}${shieldTxt}`;
  }

  // -----------------------
  // Main loop
  // -----------------------
  let lastT = performance.now();
  function frame(t){
    const dt = Math.min(0.033, (t - lastT)/1000);
    lastT = t;

    if (!paused){
      update(dt);
    }
    draw();
    syncHud();

    requestAnimationFrame(frame);
  }

  // init
  setPadX(0.5);
  spawnWave();
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
