<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
  <title>Snake</title>

  <!-- PWA / Add to Home Screen (iOS/Android) -->
  <meta name="theme-color" content="#0b1220" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Snake" />
  <link rel="manifest" href="/game/manifest.webmanifest" />
  <link rel="apple-touch-icon" href="/game/icons/icon-192.png" />

  <style>
    :root { color-scheme: dark; }

    /* ✅ 全站鎖定：不捲動、不回彈、不被瀏覽器拉著跑 */
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      overscroll-behavior: none;
      background: #0b1220;
      color: #e7eefc;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", Arial, sans-serif;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
    }
    body {
      position: fixed; /* iOS Safari: 真的鎖住畫面 */
      inset: 0;
    }

    /* ✅ 動態島 / Home Indicator 安全區 */
    .app {
      height: 100svh; /* 比 100vh 更抗手機瀏覽器工具列跳動 */
      padding-top: calc(env(safe-area-inset-top) + 10px);
      padding-right: calc(env(safe-area-inset-right) + 12px);
      padding-bottom: calc(env(safe-area-inset-bottom) + 12px);
      padding-left: calc(env(safe-area-inset-left) + 12px);
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
    }

    /* 計分板 */
    .hud {
      width: min(520px, 96vw);
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
    }
    .pill {
      flex: 1;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      border-radius: 999px;
      padding: 10px 12px;
      font-size: 14px;
      text-align: center;
      white-space: nowrap;
    }
    .pill strong { font-weight: 800; }

    /* 遊戲區（固定方形） */
    .stage {
      width: min(520px, 96vw);
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .stageInner {
      width: 100%;
      height: 100%;
      max-height: min(520px, 58svh);
      aspect-ratio: 1 / 1;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.12);
      background: #0a0f1c;
      position: relative;
      overflow: hidden;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
    }

    /* Game Over / Paused */
    .overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 16px;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(6px);
    }
    .overlay.show { display: flex; }
    .overlay h2 { margin: 0 0 6px; font-size: 18px; }
    .overlay p { margin: 0; opacity: .85; font-size: 13px; line-height: 1.4; }

    /* 方向鍵（只留你要的） */
    .dpad {
      width: min(520px, 96vw);
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }
    .btn {
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      border-radius: 14px;
      padding: 14px 0;
      color: #e7eefc;
      font-size: 18px;
      font-weight: 700;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }
    .btn:active { transform: scale(0.985); }
    .blank { opacity: 0; pointer-events: none; }

    /* 小一點的手機：按鍵跟棋盤也能塞得下 */
    @media (max-height: 720px) {
      .stageInner { max-height: min(520px, 52svh); }
      .btn { padding: 12px 0; }
      .pill { padding: 9px 10px; }
    }
  </style>
</head>

<body>
  <div class="app" id="app">
    <div class="hud">
      <div class="pill">分數：<strong id="score">0</strong></div>
      <div class="pill">最高：<strong id="best">0</strong></div>
      <div class="pill">狀態：<strong id="state">Ready</strong></div>
    </div>

    <div class="stage">
      <div class="stageInner" id="stage">
        <canvas id="cv"></canvas>
        <div class="overlay" id="overlay">
          <div>
            <h2 id="ovTitle">Paused</h2>
            <p id="ovText">點一下畫面或按方向鍵開始</p>
          </div>
        </div>
      </div>
    </div>

    <div class="dpad" id="dpad">
      <button class="btn blank"> </button>
      <button class="btn" data-dir="U">▲</button>
      <button class="btn blank"> </button>

      <button class="btn" data-dir="L">◀</button>
      <button class="btn" id="toggle">⏯</button>
      <button class="btn" data-dir="R">▶</button>

      <button class="btn blank"> </button>
      <button class="btn" data-dir="D">▼</button>
      <button class="btn blank"> </button>
    </div>
  </div>

<script>
(() => {
  // ===== Config =====
  const GRID = 22;
  const BASE_STEP_MS = 140;
  const SPEEDUP_EVERY = 6;
  const SPEEDUP_FACTOR = 0.92;
  const BEST_KEY = "snake_best_v2";

  // ===== DOM =====
  const stage = document.getElementById("stage");
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");

  const elScore = document.getElementById("score");
  const elBest  = document.getElementById("best");
  const elState = document.getElementById("state");

  const overlay = document.getElementById("overlay");
  const ovTitle = document.getElementById("ovTitle");
  const ovText  = document.getElementById("ovText");
  const toggleBtn = document.getElementById("toggle");

  let best = Number(localStorage.getItem(BEST_KEY) || 0) || 0;
  elBest.textContent = best;

  // ===== Canvas sizing (square, crisp) =====
  function resizeCanvas() {
    const rect = stage.getBoundingClientRect();
    const sizeCss = Math.floor(Math.min(rect.width, rect.height));
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    cv.width = Math.floor(sizeCss * dpr);
    cv.height = Math.floor(sizeCss * dpr);
    cv.style.width = sizeCss + "px";
    cv.style.height = sizeCss + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    draw();
  }
  window.addEventListener("resize", resizeCanvas);

  // ===== Game state =====
  let snake, dir, pendingDir, food, score, foodsEaten;
  let running = false;
  let gameOver = false;
  let stepMs = BASE_STEP_MS;
  let lastStepAt = 0;

  function randInt(n){ return Math.floor(Math.random() * n); }
  function same(a,b){ return a.x===b.x && a.y===b.y; }
  function isReverse(nd){ return (nd.x === -dir.x && nd.y === -dir.y); }

  function setOverlay(show, title, text){
    if(show){
      ovTitle.textContent = title;
      ovText.textContent  = text;
      overlay.classList.add("show");
    } else {
      overlay.classList.remove("show");
    }
  }

  function setStateLabel(){
    if(gameOver) elState.textContent = "Over";
    else if(running) elState.textContent = "Run";
    else elState.textContent = "Ready";
  }

  function syncUI(){
    elScore.textContent = score;
    elBest.textContent = best;
    setStateLabel();
  }

  function resetGame() {
    const mid = Math.floor(GRID/2);
    snake = [{x:mid, y:mid}, {x:mid-1, y:mid}, {x:mid-2, y:mid}];
    dir = {x:1, y:0};
    pendingDir = null;
    score = 0;
    foodsEaten = 0;
    stepMs = BASE_STEP_MS;
    gameOver = false;
    running = false;
    lastStepAt = 0;
    placeFood();
    syncUI();
    setOverlay(true, "Ready", "點一下畫面或按方向鍵開始");
    toggleBtn.textContent = "⏯";
    draw();
  }

  function placeFood() {
    while(true){
      const p = {x: randInt(GRID), y: randInt(GRID)};
      if(!snake.some(s => same(s,p))){ food = p; return; }
    }
  }

  function queueDir(dx, dy){
    const nd = {x:dx, y:dy};
    if(isReverse(nd)) return;
    pendingDir = nd;
    if(!running && !gameOver) setRunning(true); // 手機：按方向就直接跑
  }

  function applyDirQueue(){
    if(!pendingDir) return;
    if(isReverse(pendingDir)) return;
    dir = pendingDir;
    pendingDir = null;
  }

  function step(){
    applyDirQueue();

    const head = snake[0];
    const next = {x: head.x + dir.x, y: head.y + dir.y};

    // hit wall
    if(next.x < 0 || next.x >= GRID || next.y < 0 || next.y >= GRID){
      endGame();
      return;
    }

    const willEat = same(next, food);
    const bodyToCheck = willEat ? snake : snake.slice(0, -1);
    if(bodyToCheck.some(p => same(p, next))){
      endGame();
      return;
    }

    snake.unshift(next);
    if(willEat){
      foodsEaten += 1;
      score += 10;
      if(score > best){
        best = score;
        localStorage.setItem(BEST_KEY, String(best));
      }
      if(foodsEaten % SPEEDUP_EVERY === 0){
        stepMs = Math.max(60, Math.floor(stepMs * SPEEDUP_FACTOR));
      }
      placeFood();
    } else {
      snake.pop();
    }

    syncUI();
    draw();
  }

  function endGame(){
    gameOver = true;
    running = false;
    syncUI();
    setOverlay(true, "Game Over", "碰到牆或身體就結束。點一下重新開始");
    draw(true);
  }

  function setRunning(v){
    if(gameOver) return;
    running = v;
    syncUI();
    if(running){
      setOverlay(false);
      requestAnimationFrame(loop);
    } else {
      setOverlay(true, "Paused", "點一下畫面或按 ⏯ 繼續");
    }
  }

  function loop(t){
    if(!running) return;
    if(!lastStepAt) lastStepAt = t;

    if(t - lastStepAt >= stepMs){
      lastStepAt = t;
      step();
    }
    requestAnimationFrame(loop);
  }

  function draw(isOver=false){
    const w = cv.getBoundingClientRect().width;
    const cell = w / GRID;

    ctx.clearRect(0,0,w,w);

    // grid (subtle)
    ctx.globalAlpha = 0.10;
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let i=1;i<GRID;i++){
      const p = i*cell;
      ctx.moveTo(p, 0); ctx.lineTo(p, w);
      ctx.moveTo(0, p); ctx.lineTo(w, p);
    }
    ctx.strokeStyle = "#e7eefc";
    ctx.stroke();
    ctx.globalAlpha = 1;

    // food
    ctx.fillStyle = "#ffcc66";
    ctx.beginPath();
    ctx.arc((food.x+0.5)*cell, (food.y+0.5)*cell, cell*0.36, 0, Math.PI*2);
    ctx.fill();

    // snake
    for(let i=snake.length-1; i>=0; i--){
      const p = snake[i];
      const x = p.x*cell, y = p.y*cell;
      const r = cell*0.18;
      ctx.fillStyle = (i===0) ? "#7cf7b6" : "#57b8ff";
      roundRect(ctx, x+2, y+2, cell-4, cell-4, r);
      ctx.fill();
    }

    if(isOver){
      ctx.globalAlpha = 0.10;
      ctx.fillStyle = "#ff668a";
      ctx.fillRect(0,0,w,w);
      ctx.globalAlpha = 1;
    }
  }

  function roundRect(ctx, x, y, w, h, r){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  // ===== Controls =====
  // Keyboard
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if(["arrowup","arrowdown","arrowleft","arrowright","w","a","s","d"," "].includes(k)) e.preventDefault();

    if(k === " "){
      if(gameOver) { resetGame(); setRunning(true); }
      else setRunning(!running);
      return;
    }
    if(gameOver) return;

    if(k === "arrowup" || k === "w") queueDir(0,-1);
    else if(k === "arrowdown" || k === "s") queueDir(0, 1);
    else if(k === "arrowleft" || k === "a") queueDir(-1,0);
    else if(k === "arrowright" || k === "d") queueDir(1,0);
  }, {passive:false});

  // D-pad
  document.querySelectorAll("[data-dir]").forEach(btn => {
    btn.addEventListener("click", () => {
      if(gameOver) return;
      const d = btn.dataset.dir;
      if(d==="U") queueDir(0,-1);
      if(d==="D") queueDir(0, 1);
      if(d==="L") queueDir(-1,0);
      if(d==="R") queueDir(1, 0);
    });
  });

  // Toggle
  toggleBtn.addEventListener("click", () => {
    if(gameOver){ resetGame(); setRunning(true); return; }
    setRunning(!running);
  });

  // Tap stage: start/pause or restart on game over
  stage.addEventListener("click", () => {
    if(gameOver){ resetGame(); setRunning(true); return; }
    setRunning(!running);
  });

  // Swipe on canvas (optional but好用)
  let start = null;
  cv.addEventListener("pointerdown", (e) => {
    cv.setPointerCapture(e.pointerId);
    start = {x:e.clientX, y:e.clientY};
  });
  cv.addEventListener("pointerup", (e) => {
    if(!start) return;
    const dx = e.clientX - start.x;
    const dy = e.clientY - start.y;
    start = null;

    const ax = Math.abs(dx), ay = Math.abs(dy);
    if(Math.max(ax, ay) < 18) return; // ignore tiny swipe

    if(ax > ay){
      if(dx > 0) queueDir(1,0);
      else queueDir(-1,0);
    }else{
      if(dy > 0) queueDir(0,1);
      else queueDir(0,-1);
    }
  });

  // ===== Init =====
  resizeCanvas();
  resetGame();
})();
</script>
</body>
</html>
