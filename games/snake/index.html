<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Snake</title>
  <style>
    :root { color-scheme: dark; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", Arial, sans-serif;
      background:#0b1220; color:#e7eefc;
      display:flex; min-height:100vh; align-items:center; justify-content:center;
    }
    .card{
      width:min(720px, 94vw);
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      border-radius:18px;
      box-shadow:0 20px 60px rgba(0,0,0,.45);
      padding:18px;
    }
    h1{ margin:0 0 10px; font-size:20px; }
    .top{
      display:flex; gap:12px; flex-wrap:wrap;
      align-items:center; justify-content:space-between;
      margin-bottom:12px;
    }
    .stats{ display:flex; gap:10px; flex-wrap:wrap; }
    .pill{
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      padding:6px 10px;
      border-radius:999px;
      font-size:13px;
      opacity:.95;
    }
    .wrap{
      display:grid; grid-template-columns: 1fr 260px; gap:14px;
      align-items:start;
    }
    @media (max-width: 780px){
      .wrap{ grid-template-columns:1fr; }
    }
    .panel{
      background:rgba(0,0,0,.24);
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      padding:12px;
    }
    canvas{
      width:100%;
      aspect-ratio: 1 / 1;
      background:#0a0f1c;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      display:block;
      touch-action: none; /* allow swipe */
    }
    .btnRow{ display:flex; gap:10px; margin-top:10px; }
    button{
      flex:1;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:#e7eefc;
      cursor:pointer;
    }
    button:hover{ background:rgba(255,255,255,.09); }
    .hint{
      font-size:12px; opacity:.8; line-height:1.5;
      margin-top:10px;
    }
    .dpad{
      margin-top:12px;
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:8px;
      max-width: 260px;
    }
    .dpad button{ padding:12px 0; }
    .dpad .blank{
      border:1px dashed rgba(255,255,255,.10);
      background:transparent;
      cursor:default;
    }
    .overlay{
      position:relative;
    }
    .banner{
      position:absolute;
      inset:12px;
      border-radius:14px;
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.12);
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding:16px;
      backdrop-filter: blur(6px);
      opacity:0;
      pointer-events:none;
      transition: opacity .15s ease;
    }
    .banner.show{ opacity:1; pointer-events:auto; }
    .banner h2{ margin:0 0 6px; font-size:18px; }
    .banner p{ margin:0; opacity:.85; font-size:13px; line-height:1.4; }
    .badge{
      display:inline-block;
      font-size:12px;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      margin-left:8px;
      opacity:.9;
    }
  </style>
</head>
<body>
  <div class="card">
    <div class="top">
      <h1>Snake <span class="badge">單檔可部署</span></h1>
      <div class="stats">
        <div class="pill">分數：<span id="score">0</span></div>
        <div class="pill">最高：<span id="best">0</span></div>
        <div class="pill">速度：<span id="speed">1.0x</span></div>
      </div>
    </div>

    <div class="wrap">
      <div class="panel overlay">
        <canvas id="cv"></canvas>
        <div id="banner" class="banner">
          <div>
            <h2 id="bannerTitle">Paused</h2>
            <p id="bannerText">按 Space 或「開始/暫停」繼續。手機可滑動控制方向。</p>
          </div>
        </div>
        <div class="btnRow">
          <button id="toggleBtn">開始</button>
          <button id="restartBtn">重新開始</button>
        </div>
        <div class="hint">
          控制：方向鍵 / WASD / 手機滑動（上、下、左、右）<br/>
          規則：碰到牆或身體 → Game Over。吃到食物加分，速度會慢慢變快。
        </div>
      </div>

      <div class="panel">
        <div class="hint" style="margin-top:0">
          手機如果你覺得滑動不夠穩（Safari 有時候很挑），就用這個方向鍵。<br/>
         （放心，這不是「多此一舉」，這叫風險控管。）
        </div>

        <div class="dpad">
          <button class="blank" disabled> </button>
          <button data-dir="U">▲</button>
          <button class="blank" disabled> </button>
          <button data-dir="L">◀</button>
          <button class="blank" disabled> </button>
          <button data-dir="R">▶</button>
          <button class="blank" disabled> </button>
          <button data-dir="D">▼</button>
          <button class="blank" disabled> </button>
        </div>

        <div class="hint">
          小抬槓：你如果想「存檔」，單機遊戲就存 localStorage / IndexedDB；但你要防作弊？別鬧，前端永遠不可信。
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Config =====
  const GRID = 22;           // 22x22
  const BASE_STEP_MS = 140;  // base speed
  const SPEEDUP_EVERY = 5;   // every N foods, speed up
  const SPEEDUP_FACTOR = 0.92; // step_ms *= factor (faster)
  const BEST_KEY = "snake_best_v1";

  // ===== DOM =====
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");
  const elScore = document.getElementById("score");
  const elBest = document.getElementById("best");
  const elSpeed = document.getElementById("speed");
  const toggleBtn = document.getElementById("toggleBtn");
  const restartBtn = document.getElementById("restartBtn");
  const banner = document.getElementById("banner");
  const bannerTitle = document.getElementById("bannerTitle");
  const bannerText = document.getElementById("bannerText");

  let best = Number(localStorage.getItem(BEST_KEY) || 0) || 0;
  elBest.textContent = best;

  // ===== Canvas sizing for crisp lines =====
  function resizeCanvas() {
    const rect = cv.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    cv.width = Math.floor(rect.width * dpr);
    cv.height = Math.floor(rect.width * dpr); // square
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
  }
  window.addEventListener("resize", () => { resizeCanvas(); draw(); });

  // ===== Game state =====
  let snake, dir, pendingDir, food, score, foodsEaten;
  let running = false;
  let gameOver = false;
  let stepMs = BASE_STEP_MS;
  let lastStepAt = 0;

  function randInt(n){ return Math.floor(Math.random() * n); }
  function same(a,b){ return a.x===b.x && a.y===b.y; }

  function resetGame() {
    // Start snake in the middle
    const mid = Math.floor(GRID/2);
    snake = [{x:mid, y:mid}, {x:mid-1, y:mid}, {x:mid-2, y:mid}];
    dir = {x:1, y:0}; // moving right
    pendingDir = null;
    score = 0;
    foodsEaten = 0;
    stepMs = BASE_STEP_MS;
    gameOver = false;
    running = false;
    lastStepAt = 0;
    placeFood();
    syncUI();
    showBanner("Paused", "按 Space 或「開始/暫停」開始。手機可滑動控制方向。");
    toggleBtn.textContent = "開始";
    draw();
  }

  function placeFood() {
    while(true){
      const p = {x: randInt(GRID), y: randInt(GRID)};
      if(!snake.some(s => same(s,p))){
        food = p;
        return;
      }
    }
  }

  function syncUI(){
    elScore.textContent = score;
    const speedMul = (BASE_STEP_MS / stepMs);
    elSpeed.textContent = speedMul.toFixed(2) + "x";
    elBest.textContent = best;
  }

  function setRunning(v){
    running = v;
    if(running){
      hideBanner();
      toggleBtn.textContent = "暫停";
      requestAnimationFrame(loop);
    }else{
      showBanner(gameOver ? "Game Over" : "Paused",
        gameOver
          ? "碰到牆或身體就結束。按「重新開始」再來一局。"
          : "按 Space 或「開始/暫停」繼續。");
      toggleBtn.textContent = gameOver ? "開始" : "開始";
    }
  }

  function showBanner(title, text){
    bannerTitle.textContent = title;
    bannerText.textContent = text;
    banner.classList.add("show");
  }
  function hideBanner(){
    banner.classList.remove("show");
  }

  function isReverse(newDir){
    return (newDir.x === -dir.x && newDir.y === -dir.y);
  }

  function applyDirQueue(){
    if(!pendingDir) return;
    if(isReverse(pendingDir)) return;
    dir = pendingDir;
    pendingDir = null;
  }

  function step(){
    applyDirQueue();

    const head = snake[0];
    const next = {x: head.x + dir.x, y: head.y + dir.y};

    // Wall collision
    if(next.x < 0 || next.x >= GRID || next.y < 0 || next.y >= GRID){
      endGame();
      return;
    }

    // Body collision (note: tail may move unless eating)
    const willEat = same(next, food);
    const bodyToCheck = willEat ? snake : snake.slice(0, -1);
    if(bodyToCheck.some(p => same(p, next))){
      endGame();
      return;
    }

    snake.unshift(next);

    if(willEat){
      foodsEaten += 1;
      score += 10;
      if(score > best){
        best = score;
        localStorage.setItem(BEST_KEY, String(best));
      }
      if(foodsEaten % SPEEDUP_EVERY === 0){
        stepMs = Math.max(60, Math.floor(stepMs * SPEEDUP_FACTOR));
      }
      placeFood();
    }else{
      snake.pop();
    }

    syncUI();
    draw();
  }

  function endGame(){
    gameOver = true;
    running = false;
    showBanner("Game Over", "碰到牆或身體就結束。按「重新開始」再來一局。");
    toggleBtn.textContent = "開始";
    draw(true);
  }

  function draw(isOver=false){
    const rect = cv.getBoundingClientRect();
    const w = rect.width;
    const cell = w / GRID;

    // background
    ctx.clearRect(0,0,w,w);

    // subtle grid (optional)
    ctx.globalAlpha = 0.12;
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let i=1;i<GRID;i++){
      const p = i*cell;
      ctx.moveTo(p, 0); ctx.lineTo(p, w);
      ctx.moveTo(0, p); ctx.lineTo(w, p);
    }
    ctx.strokeStyle = "#e7eefc";
    ctx.stroke();
    ctx.globalAlpha = 1;

    // food
    ctx.fillStyle = "#ffcc66";
    ctx.beginPath();
    ctx.arc((food.x+0.5)*cell, (food.y+0.5)*cell, cell*0.36, 0, Math.PI*2);
    ctx.fill();

    // snake
    for(let i=snake.length-1; i>=0; i--){
      const p = snake[i];
      const x = p.x*cell, y=p.y*cell;
      const r = cell*0.18;
      ctx.fillStyle = (i===0) ? "#7cf7b6" : "#57b8ff";
      roundRect(ctx, x+2, y+2, cell-4, cell-4, r);
      ctx.fill();
    }

    if(isOver){
      ctx.globalAlpha = 0.10;
      ctx.fillStyle = "#ff668a";
      ctx.fillRect(0,0,w,w);
      ctx.globalAlpha = 1;
    }
  }

  function roundRect(ctx, x, y, w, h, r){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  function loop(t){
    if(!running) return;
    if(!lastStepAt) lastStepAt = t;

    const dt = t - lastStepAt;
    if(dt >= stepMs){
      // Catch up only one step to keep it simple/stable
      lastStepAt = t;
      step();
    }
    requestAnimationFrame(loop);
  }

  // ===== Controls =====
  function queueDir(dx, dy){
    const nd = {x:dx, y:dy};
    if(isReverse(nd)) return;
    pendingDir = nd;
  }

  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if(["arrowup","arrowdown","arrowleft","arrowright","w","a","s","d"," "].includes(k)) e.preventDefault();

    if(k === " "){
      if(gameOver){
        resetGame();
        setRunning(true);
      }else{
        setRunning(!running);
      }
      return;
    }

    if(gameOver) return;

    if(k === "arrowup" || k === "w") queueDir(0,-1);
    else if(k === "arrowdown" || k === "s") queueDir(0, 1);
    else if(k === "arrowleft" || k === "a") queueDir(-1,0);
    else if(k === "arrowright" || k === "d") queueDir(1, 0);

    if(!running && !gameOver) draw();
  }, {passive:false});

  // D-pad buttons
  document.querySelectorAll(".dpad button[data-dir]").forEach(btn => {
    btn.addEventListener("click", () => {
      if(gameOver) return;
      const d = btn.dataset.dir;
      if(d==="U") queueDir(0,-1);
      if(d==="D") queueDir(0, 1);
      if(d==="L") queueDir(-1,0);
      if(d==="R") queueDir(1, 0);
      if(!running) setRunning(true); // mobile convenience
    });
  });

  // Touch swipe on canvas
  let touchStart = null;
  cv.addEventListener("pointerdown", (e) => {
    cv.setPointerCapture(e.pointerId);
    touchStart = {x: e.clientX, y: e.clientY};
  });
  cv.addEventListener("pointerup", (e) => {
    if(!touchStart) return;
    const dx = e.clientX - touchStart.x;
    const dy = e.clientY - touchStart.y;
    touchStart = null;

    const ax = Math.abs(dx), ay = Math.abs(dy);
    if(Math.max(ax, ay) < 18) {
      // tap: toggle start/pause for convenience
      if(gameOver){
        resetGame();
        setRunning(true);
      }else{
        setRunning(!running);
      }
      return;
    }

    if(ax > ay){
      if(dx > 0) queueDir(1,0);
      else queueDir(-1,0);
    }else{
      if(dy > 0) queueDir(0,1);
      else queueDir(0,-1);
    }

    if(!running && !gameOver) setRunning(true);
  });

  toggleBtn.addEventListener("click", () => {
    if(gameOver){
      resetGame();
      setRunning(true);
      return;
    }
    setRunning(!running);
  });

  restartBtn.addEventListener("click", () => {
    resetGame();
    setRunning(true);
  });

  // ===== Init =====
  resizeCanvas();
  resetGame();
})();
</script>
</body>
</html>
